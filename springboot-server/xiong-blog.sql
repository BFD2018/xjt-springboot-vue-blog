/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.32 : Database - my-star-light-blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`my-star-light-blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */;

USE `my-star-light-blog`;

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL COMMENT '博客id',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '标题',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '描述',
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '首图地址',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL COMMENT '博客内容',
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT '原创' COMMENT '原创/转载',
  `published` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否公开',
  `appreciation` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否开启赞赏',
  `commentabled` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否开启评论',
  `recommend` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否可以回复',
  `share_statement` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否已发布(草稿0/正文1)',
  `views` int(11) DEFAULT '0' COMMENT '浏览量',
  `type_id` bigint(20) DEFAULT NULL COMMENT '分类id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `comment_count` bigint(20) DEFAULT '0' COMMENT '评论次数',
  `is_delete` tinyint(1) DEFAULT '0' COMMENT '逻辑删除',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '\r\n创建时间',
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`) USING BTREE,
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_blog` */

insert  into `t_blog`(`id`,`title`,`description`,`first_picture`,`content`,`flag`,`published`,`appreciation`,`commentabled`,`recommend`,`share_statement`,`views`,`type_id`,`user_id`,`comment_count`,`is_delete`,`create_time`,`update_time`) values (1350003826215661569,'SpringBoot+Mybatis+thymeleaf 增删改查','使用 SpringBoot+Mybatis+thymeleaf 增删改查小例子','https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1767203791,1848851172&fm=26&gp=0.jpg','@[TOC]\n## 先看效果\n- 列表展示\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227103541821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n- 根据手机号码查询\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227103632812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n- 添加\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227103718750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020122710373529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n- 编辑\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227103816203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227103840787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n- 删除\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202012271040002.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70)\n\n\n\n\n## 1、建表phone_type\n\n```java\nDROP TABLE IF EXISTS `phone_type`;\nCREATE TABLE `phone_type` (\n  `type_id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'类型id\',\n  `number_part` varchar(50) DEFAULT NULL COMMENT \'号码段\',\n  `type_name` varchar(50) DEFAULT NULL COMMENT \'类型名称\',\n  `type_remark` varchar(255) DEFAULT NULL COMMENT \'类型备注\',\n  PRIMARY KEY (`type_id`),\n  KEY `type_id` (`type_id`,`type_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\nINSERT INTO `phone_type` VALUES (\'1\', \'131\', \'中国联通\', \'老号码\');\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201113221622457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n\n## 2、导入依赖并修改配置文件\npom.xml文件：\n```java\n <!-- mybatis -->\n   <dependency>\n       <groupId>org.mybatis.spring.boot</groupId>\n       <artifactId>mybatis-spring-boot-starter</artifactId>\n       <version>2.1.3</version>\n   </dependency>\n   \n <!-- thymeleaf -->\n   <dependency>\n       <groupId>org.springframework.boot</groupId>\n       <artifactId>spring-boot-starter-thymeleaf</artifactId>\n   </dependency>\n   \n   <!-- mysql -->\n   <dependency>\n       <groupId>mysql</groupId>\n       <artifactId>mysql-connector-java</artifactId>\n       <scope>runtime</scope>\n   </dependency>\n   \n   <!-- web -->\n   <dependency>\n       <groupId>org.springframework.boot</groupId>\n       <artifactId>spring-boot-starter-web</artifactId>\n   </dependency>\n```\n\napplication. properties：\n需要修改数据库信息和dao包路径\n\n```java\nspring.datasource.url=jdbc:mysql://xx.xx.xx.xx:3306/xx?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\nspring.datasource.username=xx\nspring.datasource.password=xx\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n# thymeleaf\nspring.thymeleaf.mode=HTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.cache=false\nspring.thymeleaf.prefix=classpath:/templates/\nspring.thymeleaf.suffix=.html\n\n# mybatis\nmybatis.mapper-locations=classpath:/mappers/*Mapper.xml\nmybatis.type-aliases-package=com.example.jpa.demo_jpa.dao\n\n```\n\n## 3、实体类\n\n```java\npublic class PhoneType {\n    private String type_id;\n    private String number_part;\n    private String type_name;\n    private String type_remark;\n\n    public String getType_id() {\n        return type_id;\n    }\n\n    public void setType_id(String type_id) {\n        this.type_id = type_id;\n    }\n\n    public String getNumber_part() {\n        return number_part;\n    }\n\n    public void setNumber_part(String number_part) {\n        this.number_part = number_part;\n    }\n\n    public String getType_name() {\n        return type_name;\n    }\n\n    public void setType_name(String type_name) {\n        this.type_name = type_name;\n    }\n\n    public String getType_remark() {\n        return type_remark;\n    }\n\n    public void setType_remark(String type_remark) {\n        this.type_remark = type_remark;\n    }\n}\n```\n## 4、PhoneTypeDao\n\n```java\n@Mapper\npublic interface PhoneTypeDao {\n    PhoneType findByNumber(@Param(\"number_part\") String number_part);\n    void addPhone(PhoneType phoneType);\n    void updatePhone(PhoneType phoneType);\n    void deletePhone(@Param(\"type_id\") String type_id);\n    List<PhoneType> findAll();\n    PhoneType findById(@Param(\"type_id\") String type_id);\n\n}\n```\n\n## 5、PhoneTypeMapper.xml\n这里需要改namespace 和 parameterType 的路径\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.example.jpa.demo_jpa.dao.PhoneTypeDao\" >\n\n    <resultMap id=\"phoneTypeMap\" type=\"com.example.jpa.demo_jpa.model.PhoneType\" >\n        <id column=\"type_id\" property=\"type_id\" jdbcType=\"INTEGER\" />\n        <result column=\"number_part\" property=\"number_part\" jdbcType=\"VARCHAR\" />\n        <result column=\"type_name\" property=\"type_name\" jdbcType=\"VARCHAR\" />\n        <result column=\"type_remark\" property=\"type_remark\" jdbcType=\"VARCHAR\" />\n    </resultMap>\n\n    <select id=\"findByNumber\" resultMap=\"phoneTypeMap\" parameterType=\"String\">\n        select * from phone_type\n        <where>\n            number_part = #{number_part}\n        </where>\n    </select>\n\n    <!--添加-->\n    <insert id=\"addPhone\" parameterType=\"com.example.jpa.demo_jpa.model.PhoneType\">\n        insert into phone_type value (#{type_id},#{number_part},#{type_name},#{type_remark})\n    </insert>\n\n    <!--修改-->\n    <update id=\"updatePhone\" parameterType=\"com.example.jpa.demo_jpa.model.PhoneType\">\n        update phone_type\n        set type_id = #{type_id}, number_part= #{number_part},type_name = #{type_name},type_remark = #{type_remark}\n        where type_id = #{type_id}\n    </update>\n\n    <!--删除-->\n    <delete id=\"deletePhone\" parameterType=\"String\">\n        delete from phone_type where type_id = #{type_id}\n    </delete>\n\n    <!--查询所有-->\n    <select id=\"findAll\"  resultMap=\"phoneTypeMap\">\n        select * from phone_type\n    </select>\n\n    <!--根据id查找-->\n    <select id=\"findById\" resultMap=\"phoneTypeMap\" parameterType=\"com.example.jpa.demo_jpa.model.PhoneType\">\n        select * from phone_type\n        where type_id = #{type_id}\n    </select>\n\n</mapper>\n```\n\n## 6、PhoneTypeService\n\n```java\npublic interface PhoneTypeService {\n    PhoneType findById(String id);\n    List<PhoneType> findAll();\n    void addPhone(PhoneType phoneType);\n    void updatePhone(PhoneType phoneType);\n    void deletePhone(String id);\n\n    PhoneType findByNumber(String number_part);\n}\n```\n## 7、PhoneTypeServiceImpl \n\n```java\n@Service\npublic class PhoneTypeServiceImpl implements PhoneTypeService {\n   @Autowired\n   private PhoneTypeDao phoneTypeDao;\n\n    @Override\n    public PhoneType findById(String id) {\n        return phoneTypeDao.findById(id);\n    }\n\n    @Override\n    public List<PhoneType> findAll() {\n        return phoneTypeDao.findAll();\n    }\n\n    @Override\n    public void addPhone(PhoneType phoneType) {\n         phoneTypeDao.addPhone(phoneType);\n    }\n\n    @Override\n    public void updatePhone(PhoneType phoneType) {\n         phoneTypeDao.updatePhone(phoneType);\n    }\n\n    @Override\n    public void deletePhone(String id) {\n        phoneTypeDao.deletePhone(id);\n    }\n\n\n    @Override\n    public PhoneType findByNumber(String number_part) {\n        return phoneTypeDao.findByNumber(number_part);\n    }\n\n}\n```\n## 8、PhoneTypeController\n\n```java\n@Controller\npublic class PhoneTypeController {\n    @Autowired\n    PhoneTypeService phoneTypeService;\n\n    //查看所有\n    @RequestMapping(\"/\")\n    public String phone_type1(Model model){\n        List<PhoneType> phoneTypes = phoneTypeService.findAll();\n        model.addAttribute(\"phones\",phoneTypes);\n        return \"phone_type.html\";\n    }\n\n    //查看所有\n    @RequestMapping(\"/phone\")\n    public String phone_type(Model model){\n        List<PhoneType> phoneTypes = phoneTypeService.findAll();\n        model.addAttribute(\"phones\",phoneTypes);\n        return \"phone_type.html\";\n    }\n\n    //跳转去添加页面\n    @GetMapping(\"/add\")\n    public String toAdd(Model model){\n        return \"add.html\";\n    }\n\n    //添加操作\n    @PostMapping(\"/add\")\n    public String addPT(PhoneType phoneType){\n       //保存信息\n        phoneTypeService.addPhone(phoneType);\n        //重定向到列表页面\n        return \"redirect:/phone\";\n    }\n\n    //跳转到更新页面\n    @GetMapping(\"/toUpdate/{id}\")\n    public String toUpdate(@PathVariable(\"id\") String id,  Model model){\n        //根据id查出来的信息\n        PhoneType phoneType =  phoneTypeService.findById(id);\n        //将信息返回给页面\n        model.addAttribute(\"phones\",phoneType);\n        return \"update.html\";\n    }\n\n    //更新操作\n    @PostMapping(\"/update\")\n    public String updatePT(PhoneType phoneType){\n        phoneTypeService.updatePhone(phoneType);\n        return \"redirect:/phone\";\n    }\n\n    //通过号码查询\n   @RequestMapping(\"/searchByNumber\")\n    public String findByNumber(HttpServletRequest request, Model model){\n        //获取搜索框的值\n        String search_input = request.getParameter(\"search_number\");\n        //根据号码查询的信息\n       PhoneType phones2 = phoneTypeService.findByNumber(search_input);\n       System.out.println(phones2);\n        //将信息返回给页面\n        model.addAttribute(\"phones\",phones2);\n        return \"phone_type.html\";\n    }\n\n\n    //删除操作\n    @GetMapping(\"/delPhone/{id}\")\n    public String delPhone(@PathVariable(\"id\") String id){\n        phoneTypeService.deletePhone(id);\n        return \"redirect:/phone\";\n    }\n}\n\n```\n## 9、phone_type.html\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>手机号类型</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\">\n    <script src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"></script>\n    <script src=\"https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js\"></script>\n    <script src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"></script>\n</head>\n<style type=\"text/css\">\n    button{\n        padding: 5px 20px 5px 20px;\n        background-color: #8488f0;\n        color: white;\n    }\n</style>\n<body>\n<form action=\"/searchByNumber\">\n    <input type=\"text\" name=\"search_number\" placeholder=\"请输入号码搜索\">\n    <input type=\"submit\" value=\"搜索\"  class=\"btn btn-success\">\n</form>\n\n<div>\n    <a th:href=\"@{/add}\"><button type=\"button\" class=\"btn btn-primary\">添加</button></a>\n    <a th:href=\"@{/phone}\"><button type=\"button\" class=\"btn btn-primary\">查看全部</button></a>\n</div>\n<table class=\"table table-hover\" style=\"width: 70%;\">\n    <thead>\n    <tr>\n        <th>编号</th>\n        <th>手机号码</th>\n        <th>运营商类型</th>\n        <th>备注</th>\n        <th>操作</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr th:each=\"phone:${phones}\">\n        <td th:text=\"${phone.type_id}\"></td>\n        <td th:text=\"${phone.number_part}\"></td>\n        <td th:text=\"${phone.type_name}\"></td>\n        <td th:text=\"${phone.type_remark}\"></td>\n        <td >\n            <a class=\"btn btn-sm btn-primary\" th:href=\"@{/toUpdate/}+${phone.type_id}\">编辑</a>\n            <a class=\"btn btn-sm btn-danger\" th:href=\"@{/delPhone/}+${phone.type_id}\">删除</a>\n        </td>\n    </tr>\n    </tbody>\n</table>\n\n\n</body>\n</html>\n```\n\n## 10、add.html\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>添加</title>\n</head>\n<body>\n<h2>添加信息</h2>\n<form th:action=\"@{/add}\" method=\"post\">\n    <table>\n        <tr>\n            <td><label for=\"InputNum\">手机号</label></td>\n            <td><input name=\"number_part\" type=\"text\" required id=\"InputNum\" placeholder=\"手机号\"></td>\n        </tr>\n        <tr>\n            <td><label for=\"InputName\">运营商</label></td>\n            <td> <input name=\"type_name\" type=\"text\" required id=\"InputName\" placeholder=\"运营商类型\" ></td>\n        </tr>\n        <tr>\n            <td><label for=\"InputText\">备注</label></td>\n            <td> <input name=\"type_remark\" type=\"text\" required id=\"InputText\" placeholder=\"备注\" ></td>\n        </tr>\n        <tr>\n            <td> <button type=\"submit\" >提交</button></td>\n        </tr>\n    </table>\n</form>\n</body>\n</html>\n```\n## 11、update.html\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>更新</title>\n</head>\n<body>\n<h2>更新操作</h2>\n<form th:action=\"@{/update}\" th:method=\"post\">\n    <table>\n        <tr>\n            <td><label>手机号</label></td>\n            <td><input name=\"number_part\" type=\"text\" th:value=\"${phones.number_part}\"></td>\n        </tr>\n        <tr>\n            <td><label>运营商</label></td>\n            <td><input name=\"type_name\" type=\"text\"  th:value=\"${phones.type_name}\"></td>\n        </tr>\n        <tr>\n            <td><label>备注</label></td>\n            <td><input name=\"type_remark\" type=\"text\" th:value=\"${phones.type_remark}\"></td>\n        </tr>\n        <!--id也要传过去，不过这里把id隐藏不显示在页面-->\n        <input name=\"type_id\" type=\"hidden\" th:value=\"${phones.type_id}\"/>\n        <tr>\n            <td> <button type=\"submit\" >提交</button></td>\n        </tr>\n\n    </table>\n</form>\n</body>\n</html>\n```\n\n- -- \n启动项目测试。','原创','','','','','',16,1350003757823340545,1,0,0,'2021-01-15 16:56:08','2022-02-02 11:01:13'),(1350017862483345409,'Springboot《整合JPA、thymeleaf、监听器和过滤器、增删改查小案例》','Springboot《整合JPA、thymeleaf、监听器和过滤器、增删改查小案例》','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3807662522,345950890&fm=15&gp=0.jpg','@[TOC](目录)\n\n# 一、整合JPA\n## 1、添加依赖\n\n```java\n		<dependency>\n			<groupId>mysql</groupId>\n			<artifactId>mysql-connector-java</artifactId>\n		</dependency>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-jdbc</artifactId>\n		</dependency>\n\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-data-jpa</artifactId>\n		</dependency>\n```\n## 2、创建数据库(mydb2019)和表\n\n```java\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for ay_user\n-- ----------------------------\nDROP TABLE IF EXISTS `ay_user`;\nCREATE TABLE `ay_user`  (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of ay_user\n-- ----------------------------\nINSERT INTO `ay_user` VALUES (1, \'libai\', \'123456\');\n\n-- ----------------------------\n-- Table structure for checking_in\n-- ----------------------------\nDROP TABLE IF EXISTS `checking_in`;\nCREATE TABLE `checking_in`  (\n  `id` int(11) NOT NULL,\n  `employee_id` int(11) NULL DEFAULT NULL,\n  `employee_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `work_day` int(11) NULL DEFAULT NULL,\n  `month_rest_day` int(11) NULL DEFAULT NULL,\n  `leave_day` int(11) NULL DEFAULT NULL,\n  `late_min` int(11) NULL DEFAULT NULL,\n  `fine_money` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Table structure for phone_type\n-- ----------------------------\nDROP TABLE IF EXISTS `phone_type`;\nCREATE TABLE `phone_type`  (\n  `type_id` int(11) NOT NULL AUTO_INCREMENT,\n  `number_part` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type_remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`type_id`) USING BTREE,\n  INDEX `type_id`(`type_id`, `type_name`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of phone_type\n-- ----------------------------\nINSERT INTO `phone_type` VALUES (1, \'15100000000\', \'中国联通\', \'10010\');\nINSERT INTO `phone_type` VALUES (3, \'111111111\', \'中国移动\', \'test\');\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n```\n\n## 3、修改数据库连接等配置\n\n```java\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mydb2019?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\nspring.datasource.name=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n## 4、新建model/AyUser 实体类\n\n```java\n@Entity\n@Table(name=\"ay_user\")\npublic class AyUser {\n    @Id //声明主键\n    @GeneratedValue(strategy=GenerationType.IDENTITY)  //主键策略\n    private String id;\n    private String name;\n    private String password;\n\n	//省略get/set方法\n}\n```\n## 5、新建AyUserRepository\n\n```java\npublic interface AyUserRepository extends JpaRepository<AyUser,String> {\n}\n```\n\n## 6、AyUserService\n\n```java\npublic interface AyUserService {\n    AyUser findbyId(String id);\n    List<AyUser> findAll();\n    AyUser save(AyUser ayUser);\n    void delete(String id);\n}\n\n```\n## 7、AyUserServiceImpl\n\n```java\n@Service\npublic class AyUserServiceImpl implements AyUserService {\n    @Resource\n    private AyUserRepository ayUserRepository;\n    @Override\n    public AyUser findbyId(String id) {\n        return ayUserRepository.findById(id).orElse(null);\n    }\n    @Override\n    public List<AyUser> findAll() {\n        return ayUserRepository.findAll();\n    }\n    @Override\n    public AyUser save(AyUser ayUser) {\n        return ayUserRepository.save(ayUser);\n    }\n    @Override\n    public void delete(String id) {\n        ayUserRepository.deleteById(id);\n    }\n}\n```\n## 8、HelloController\n\n```java\n@RestController\npublic class HelloController {\n    @Autowired\n    AyUserService myService;\n    @RequestMapping(\"/hello\")\n    public String First() {\n        return myService.findAll().get(0).getName();\n    }\n\n}\n```\n## 9、测试\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020101621390275.png#pic_center)\n# 二、整合thymeleaf\n## 1、添加依赖\n\n```java\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n```\n\n## 2、修改配置文件\n\n```java\nspring.thymeleaf.mode=HTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.cache=false\nspring.thymeleaf.prefix=classpath:/templates/\nspring.thymeleaf.suffix=.html\n```\n\n## 3、index.html\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201016213614284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n\n```java\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>hello</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n</head>\n<body>\n<table border=\"1\" cellspacing=\"0\">\n    <tr>\n        <td>用户名</td>\n        <td>密码</td>\n    </tr>\n    <tr th:each=\"user:${users}\">\n        <td th:text=\"${user.name}\"></td>\n        <td th:text=\"${user.password}\"></td>\n    </tr>\n</table>\n</body>\n</html>\n```\n\n## 4、AyUserController \n\n```java\n@Controller\npublic class AyUserController {\n    @Resource\n    private AyUserService ayUserService;\n\n    @RequestMapping(\"/showusers\")\n    public String showusers( Model model) {\n        List<AyUser> ayUser=ayUserService.findAll();\n        model.addAttribute(\"users\",ayUser);\n        return \"index\";\n    }\n\n}\n```\n\n## 5、测试\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020101621413432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n# 三、开启事务\n在ServiceImpl 方法或者类上添加 `@Transactional`  注解即可。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201016214607738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n# 四、Filter过滤器 和 Listener监听器\n## 1、过滤器\n\n> 过滤器和拦截器在功能方面很类似，但是在具体技术实现方面，差距还是比较大的。在面向对象编程的过程中，我们很容易通过继承、多态来解决纵向扩展。 但是对于横向的功能，比如，在所有的service方法中开启事务，或者统一记录日志等功能，面向对象的是无法解决的。所以AOP——面向切面编程其实是面向对象编程思想的一个补充。而过滤器和拦截器都属于面向切面编程的具体实现。而两者的主要区别包括以下几个方面：\n　　1、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。\n　　2、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。\n　　3、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。\n\n## 2、新建UrlFilter 类\n当访问/success/info时，正常访问；访问/success/ 下的其他页面时，会跳转到/failed 页面。\n```java\n@WebFilter(filterName = \"test\", urlPatterns = \"/success/*\")\npublic class UrlFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"----------------------->过滤器被创建\");\n    }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) servletRequest;\n        String requestURI = req.getRequestURI();\n        System.out.println(\"--------------------->过滤器：请求地址\"+requestURI);\n        if(!requestURI.contains(\"info\")){\n            servletRequest.getRequestDispatcher(\"/failed\").forward(servletRequest, servletResponse);\n        }else{\n            filterChain.doFilter(servletRequest, servletResponse);\n        }\n    }\n    @Override\n    public void destroy() {\n        System.out.println(\"----------------------->过滤器被销毁\");\n    }\n}\n```\n\n## 3、HelloController\n添加/failed 和/success/info 两个接口\n\n```java\n@RestController\npublic class HelloController {\n    @Autowired\n    AyUserService myService;\n    @RequestMapping(\"/hello\")\n    public String First() {\n        return myService.findAll().get(0).getName();\n    }\n\n    @RequestMapping(\"/failed\")\n    public Map<String, String> requestFailed(){\n\n        Map<String, String> map = new HashMap<>();\n        map.put(\"code\", \"-1\");\n        map.put(\"msg\", \"请求错误\");\n        return map;\n    }\n\n    @RequestMapping(\"/success/info\")\n    public AyUser userInfo(){\n        AyUser user = new AyUser();\n        user.setName(\"xiaodong\");\n        user.setPassword(\"123456\");\n        user.setId(\"2020\");\n        return user;\n    }\n\n}\n\n```\n\n## 4、在启动类添加注解\n\n```java\n@ServletComponentScan\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201016215553611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n\n## 5、测试\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201016215255101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n## 6、监听器\n\n> 监听器也叫Listener,是servlet的监听器，可以用于监听Web应用中某些对象，信息的创建，销毁，增加，修改，删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生变化时，服务器自动调用监听器对象中的方法，常用于统计在线人数和在线用户，系统加载时进行信息初始化，统计网站的访问量等。\n\n## 7、新建RequestListener 类\n\n```java\n@WebListener\npublic class RequestListener implements ServletRequestListener {\n    @Override\n    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {\n        System.out.println(\"---------------------------->请求Listener销毁\");\n    }\n    @Override\n    public void requestInitialized(ServletRequestEvent servletRequestEvent) {\n        System.out.println(\"---------------------------->请求Listener创建\");\n    }\n}\n\n```\n## 7、测试\n当访问页面时，控制台打印：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201016215817667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n# 五、增删改查小案例\n\n## 1、PhoneType\n\n```java\n@Entity\n@Table(name = \"phone_type\")\npublic class PhoneType {\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private String type_id;\n    private String number_part;\n    private String type_name;\n    private String type_remark;\n\n    public String getType_id() {\n        return type_id;\n    }\n\n    public void setType_id(String type_id) {\n        this.type_id = type_id;\n    }\n\n    public String getNumber_part() {\n        return number_part;\n    }\n\n    public void setNumber_part(String number_part) {\n        this.number_part = number_part;\n    }\n\n    public String getType_name() {\n        return type_name;\n    }\n\n    public void setType_name(String type_name) {\n        this.type_name = type_name;\n    }\n\n    public String getType_remark() {\n        return type_remark;\n    }\n\n    public void setType_remark(String type_remark) {\n        this.type_remark = type_remark;\n    }\n}\n\n```\n\n## 2、PhoneTypeRepository\n\n```java\npublic interface PhoneTypeRepository extends JpaRepository<PhoneType,String> {\n}\n```\n## 3、PhoneTypeService\n\n```java\npublic interface PhoneTypeService {\n    PhoneType findById(String id);\n    List<PhoneType> findAll();\n    PhoneType save(PhoneType phoneType);\n    void delete(String id);\n}\n\n```\n## 4、PhoneTypeServiceImpl\n\n```java\n@Service\npublic class PhoneTypeServiceImpl implements PhoneTypeService {\n   @Resource\n   private PhoneTypeRepository phoneTypeRepository;\n\n    @Override\n    public PhoneType findById(String id) {\n        return phoneTypeRepository.findById(id).orElse(null);\n    }\n\n    @Override\n    public List<PhoneType> findAll() {\n        return phoneTypeRepository.findAll();\n    }\n\n    @Override\n    public PhoneType save(PhoneType phoneType) {\n        return phoneTypeRepository.save(phoneType);\n    }\n\n\n    @Override\n    public void delete(String id) {\n         phoneTypeRepository.deleteById(id);\n    }\n}\n\n```\n\n## 5、PhoneTypeController \n\n```java\n\n@Controller\npublic class PhoneTypeController {\n    @Autowired\n    PhoneTypeService phoneTypeService;\n    String uid;\n\n    @RequestMapping(\"/phone\")\n    public String phone_type(Model model){\n        List<PhoneType> phoneTypes = phoneTypeService.findAll();\n        model.addAttribute(\"phones\",phoneTypes);\n        return \"phone_type.html\";\n    }\n\n    //跳转去添加页面\n    @GetMapping(\"/add\")\n    public String toAdd(Model model){\n        return \"phoneType/add.html\";\n    }\n\n    //添加操作\n    @PostMapping(\"/add\")\n    public String addPT(PhoneType phoneType){\n       //保存信息\n        phoneTypeService.save(phoneType);\n        //重定向到列表页面\n        return \"redirect:/phone\";\n    }\n\n    //跳转到更新页面\n    @GetMapping(\"/toUpdate/{id}\")\n    public String toUpdate(@PathVariable(\"id\") String id,  Model model){\n        //根据id查出来的信息\n        PhoneType phoneType =  phoneTypeService.findById(id);\n        uid = id;\n\n        //将信息返回给页面\n        model.addAttribute(\"phones\",phoneType);\n        return \"phoneType/update.html\";\n\n    }\n\n    //更新操作\n    @PostMapping(\"/update\")\n    public String updatePT(PhoneType phoneType){\n        //根据id查出来的信息\n        PhoneType py =  phoneTypeService.findById(uid);\n        py.setType_name(phoneType.getType_name());\n        py.setNumber_part(phoneType.getNumber_part());\n        py.setType_remark(phoneType.getType_remark());\n        phoneTypeService.save(py);\n        return \"redirect:/phone\";\n    }\n\n    //删除操作\n    @GetMapping(\"/delPhone/{id}\")\n    public String delPhone(@PathVariable(\"id\") String id){\n        phoneTypeService.delete(id);\n        return \"redirect:/phone\";\n    }\n}\n```\n\n## 6、列表页面\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>手机号类型</title>\n</head>\n<style type=\"text/css\">\n    button{\n        padding: 5px 20px 5px 20px;\n        background-color: #8488f0;\n        color: white;\n    }\n</style>\n<body>\n<div>\n    <!--<input type=\"text\"><button>点我查询</button>-->\n    <a th:href=\"@{/add}\"><button>添加</button></a>\n</div>\n<table border=\"1\" cellspacing=\"0\">\n    <thead>\n    <tr>\n        <th>编号</th>\n        <th>手机号码</th>\n        <th>运营商类型</th>\n        <th>备注</th>\n        <th>操作</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr th:each=\"phone:${phones}\">\n        <td th:text=\"${phone.type_id}\"></td>\n        <td th:text=\"${phone.number_part}\"></td>\n        <td th:text=\"${phone.type_name}\"></td>\n        <td th:text=\"${phone.type_remark}\"></td>\n        <td >\n            <a class=\"btn btn-sm btn-primary\" th:href=\"@{/toUpdate/}+${phone.type_id}\">编辑</a>\n            <a class=\"btn btn-sm btn-danger\" th:href=\"@{/delPhone/}+${phone.type_id}\">删除</a>\n        </td>\n    </tr>\n    </tbody>\n</table>\n\n</body>\n</html>\n```\n\n## 7、添加页面\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>添加</title>\n</head>\n<body>\n<h2>添加信息</h2>\n<form th:action=\"@{/add}\" method=\"post\">\n    <table>\n        <tr>\n            <td><label for=\"InputNum\">手机号</label></td>\n            <td><input name=\"number_part\" type=\"text\" required id=\"InputNum\" placeholder=\"手机号\"></td>\n        </tr>\n        <tr>\n            <td><label for=\"InputName\">运营商</label></td>\n            <td> <input name=\"type_name\" type=\"text\" required id=\"InputName\" placeholder=\"运营商类型\" ></td>\n        </tr>\n        <tr>\n            <td><label for=\"InputText\">备注</label></td>\n            <td> <input name=\"type_remark\" type=\"text\" required id=\"InputText\" placeholder=\"备注\" ></td>\n        </tr>\n        <tr>\n            <td> <button type=\"submit\" >提交</button></td>\n        </tr>\n    </table>\n</form>\n</body>\n</html>\n```\n\n## 8、更新页面\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>更新</title>\n</head>\n<body>\n<h2>更新操作</h2>\n<form th:action=\"@{/update}\" th:method=\"post\">\n    <table>\n        <tr>\n            <td><label>手机号</label></td>\n            <td><input name=\"number_part\" type=\"text\" th:value=\"${phones.number_part}\"></td>\n        </tr>\n        <tr>\n            <td><label>运营商</label></td>\n            <td><input name=\"type_name\" type=\"text\"  th:value=\"${phones.type_name}\"></td>\n        </tr>\n        <tr>\n            <td><label>备注</label></td>\n            <td><input name=\"type_remark\" type=\"text\" th:value=\"${phones.type_remark}\"></td>\n        </tr>\n        <tr>\n            <td> <button type=\"submit\" >提交</button></td>\n        </tr>\n    </table>\n</form>\n</body>\n</html>\n```\n## 9、效果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018193446906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n添加\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018194136807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202010181941538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n更新\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018194229911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018194240913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n删除编号18的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018194256238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjM0NTEw,size_16,color_FFFFFF,t_70#pic_center)\n','原创','','','','','',17,1455457539423105025,1,0,1,'2021-01-15 17:51:55','2021-12-10 15:39:45'),(1479450970399211521,'【Python爬虫】1、网络请求','重点学习requests 和 selenium两种请求方式','https://ae04.alicdn.com/kf/H11278db8dc8943bbb6dc6f9f543d41ac7.png','## 第一节：爬虫前奏\n### 爬虫的实际例子：\n\n1. 搜索引擎（百度、谷歌、360搜索等）。\n1. 伯乐在线。\n1. 惠惠购物助手。\n1. 数据分析与研究（数据冰山知乎专栏）。\n1. 抢票软件等。\n### 什么是网络爬虫：\n\n1. 通俗理解：爬虫是一个模拟人类请求网站行为的程序。可以自动请求网页、并数据抓取下来，然后使用一定的规则提取有价值的数据。\n1. 专业介绍：[百度百科](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711?fr=aladdin)。\n### 通用爬虫和聚焦爬虫：\n\n1. 通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。\n1. 聚焦爬虫：是面向特定需求的一种网络爬虫程序，他与通用爬虫的区别在于：聚焦爬虫在实施网页抓取的时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。\n### 为什么用Python写爬虫程序：\n\n1. PHP：PHP是世界是最好的语言，但他天生不是做这个的，而且对多线程、异步支持不是很好，并发处理能力弱。爬虫是工具性程序，对速度和效率要求比较高。\n1. Java：生态圈很完善，是Python爬虫最大的竞争对手。但是Java语言本身很笨重，代码量很大。重构成本比较高，任何修改会导致代码大量改动。爬虫经常要修改采集代码。\n1. C/C++：运行效率是无敌的。但是学习和开发成本高。写个小爬虫程序可能要大半天时间。\n1. Python：语法优美、代码简洁、开发效率高、支持的模块多。相关的HTTP请求模块和HTML解析模块非常丰富。还有Scrapy和Scrapy-redis框架让我们开发爬虫变得异常简单。\n### 准备工具：\n\n1. Python3.6开发环境。\n1. Pycharm 2017 professional版。\n1. 虚拟环境。`virtualenv/virtualenvwrapper`。\n\n---\n\n## 第二节：http协议和Chrome抓包工具\n### 什么是http和https协议：\nHTTP协议：全称是`HyperText Transfer Protocol`，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是`80`端口。 HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是`443`端口。\n### 在浏览器中发送一个http请求的过程：\n\n1. 当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。\n1. 当我们在浏览器输入URL [http://www.baidu.com](http://www.baidu.com) 的时候，浏览器发送一个Request请求去获取 [http://www.baidu.com](http://www.baidu.com) 的html文件，服务器把Response文件对象发送回给浏览器。\n1. 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。\n1. 当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。\n### url组成详解：\n`URL`是`Uniform Resource Locator`的简写，统一资源定位符。 一个`URL`由以下几部分组成：\n```\nscheme://host:port/path/?query-string=xxx#anchor\n```\n\n- **scheme**：代表的是访问的协议，一般为`http`或者`https`以及`ftp`等。\n- **host**：主机名，域名，比如`www.baidu.com`。\n- **port**：端口号。当你访问一个网站的时候，浏览器默认使用80端口。\n- **path**：查找路径。比如：`www.jianshu.com/trending/now`，后面的`trending/now`就是`path`。\n- **query-string**：查询字符串，比如：`www.baidu.com/s?wd=python`，后面的`wd=python`就是查询字符串。\n- **anchor**：锚点，后台一般不用管，前端用来做页面定位的。\n\n在浏览器中请求一个`url`，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。\n### 常用的请求方法：\n在`Http`协议中，定义了八种请求方法（get post put delete patch）。这里介绍两种常用的请求方法，分别是`get`请求和`post`请求。\n\n1. `get`请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用`get`请求。\n1. `post`请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用`post`请求。 以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用`get`方法的请求就一定要改成`post`请求，这个要视情况而定。\n### 请求头常见参数：\n在`http`协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在`body`中（在`post`请求中），第三个就是把数据放在`head`中。这里介绍在网络爬虫中经常会用到的一些请求头参数：\n\n1. `User-Agent`：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的`User-Agent`就是`Python`，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。\n1. `Referer`：表明当前这个请求是从哪个`url`过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。\n1. `Cookie`：`http`协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用`cookie`来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送`cookie`信息了。\n### 常见响应状态码：\n\n1. `200`：请求正常，服务器正常的返回数据。\n1. `301`：永久重定向。比如在访问`www.jingdong.com`的时候会重定向到`www.jd.com`。\n1. `302`：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。\n1. `400`：请求的`url`在服务器上找不到。换句话说就是请求`url`错误。\n1. `403`：服务器拒绝访问，权限不够。\n1. `500`：服务器内部错误。可能是服务器出现`bug`了。\n### Chrome浏览器抓包工具：\n`Chrome`浏览器是一个非常亲近开发者的浏览器。可以方便的查看网络请求以及发送的参数。对着网页`右键->检查`。然后就可以打开开发者选项。以下用图片来说明。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1602378542349-7cf6b5b2-5891-4132-b2d4-72a0f4316d5b.png#height=454&id=hlIQJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=1277&originalType=binary&ratio=1&size=229926&status=done&style=none&width=638.5)\n\n---\n\n## 第三节：urllib库（了解）\n`urllib`库是`Python`中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。现在已被requests库取代，requests库在urllib库的基础上进行了封装，使用起来更加简便，但是底层还是urllib的原理。\n### urlopen函数：\n在`Python3`的`urllib`库中，所有和网络请求相关的方法，都被集到`urllib.request`模块下面了，以先来看下`urlopen`函数基本的使用：\n```python\nfrom urllib import request\nresp = request.urlopen(\'http://www.baidu.com\')\nprint(resp.read())\n```\n实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。\n以下对`urlopen`函数的进行详细讲解：\n\n1. `url`：请求的url。\n1. `data`：请求的`data`，如果设置了这个值，那么将变成`post`请求。\n1. 返回值：返回值是一个`http.client.HTTPResponse`对象，这个对象是一个类文件句柄对象。有`read(size)`、`readline`、`readlines`以及`getcode`等方法。\n### urlretrieve函数：\n这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：\n```python\nfrom urllib import request\nrequest.urlretrieve(\'http://www.baidu.com/\',\'baidu.html\')\n```\n### urlencode函数：\n用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用`urlencode`函数来实现。`urlencode`可以把字典数据转换为`URL`编码的数据。示例代码如下：\n```python\nfrom urllib import parse\ndata = {\'name\':\'爬虫基础\',\'greet\':\'hello world\',\'age\':100}\nqs = parse.urlencode(data)\nprint(qs)\n```\n### parse_qs函数：\n可以将经过编码后的url参数进行解码。示例代码如下：\n```python\nfrom urllib import parse\nqs = \"name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&greet=hello+world&age=100\"\nprint(parse.parse_qs(qs))\n```\n### urlparse和urlsplit：\n有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用`urlparse`或者是`urlsplit`来进行分割。示例代码如下：\n```python\nfrom urllib import request,parse\nurl = \'http://www.baidu.com/s?username=zhiliao\'\nresult = parse.urlsplit(url)\n# result = parse.urlparse(url)\nprint(\'scheme:\',result.scheme)\nprint(\'netloc:\',result.netloc)\nprint(\'path:\',result.path)\nprint(\'query:\',result.query)\n```\n`urlparse`和`urlsplit`基本上是一模一样的。唯一不一样的地方是，`urlparse`里面多了一个`params`属性，而`urlsplit`没有这个`params`属性。比如有一个`url`为：`url = \'http://www.baidu.com/s;hello?wd=python&username=abc#1\'`，\n那么`urlparse`可以获取到`hello`，而`urlsplit`不可以获取到。`url`中的`params`也用得比较少。\n### request.Request类：\n如果想要在请求的时候增加一些请求头，那么就必须使用`request.Request`类来实现。比如要增加一个`User-Agent`，示例代码如下：\n```python\nfrom urllib import request\nheaders = {\n\'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\'\n}\nreq = request.Request(\"http://www.baidu.com/\",headers=headers)\nresp = request.urlopen(req)\nprint(resp.read())\n```\n### ProxyHandler处理器（代理设置）\n很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。\n所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。\nurllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：\n```python\nfrom urllib import request\n# 这个是没有使用代理的\n# resp = request.urlopen(\'http://httpbin.org/get\')\n# print(resp.read().decode(\"utf-8\"))\n# 这个是使用了代理的\nhandler = request.ProxyHandler({\"http\":\"218.66.161.88:31769\"})\nopener = request.build_opener(handler)\nreq = request.Request(\"http://httpbin.org/ip\")\nresp = opener.open(req)\nprint(resp.read())\n```\n常用的代理有：\n\n- 西刺免费代理IP：[http://www.xicidaili.com/](http://www.xicidaili.com/)\n- 快代理：[http://www.kuaidaili.com/](http://www.kuaidaili.com/)\n- 代理云：[http://www.dailiyun.com/](http://www.dailiyun.com/)\n### 什么是cookie：\n在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。`cookie`的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的`cookie`数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。`cookie`存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用`cookie`只能存储一些小量的数据。\n#### cookie的格式：\n```shell\nSet-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE\n```\n参数意义：\n\n- NAME：cookie的名字。\n- VALUE：cookie的值。\n- Expires：cookie的过期时间。\n- Path：cookie作用的路径。\n- Domain：cookie作用的域名。\n- SECURE：是否只在https协议下起作用。\n### 使用cookielib库和HTTPCookieProcessor模拟登录：\nCookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。\n这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。\n解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：\n```python\nfrom urllib import request\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\',\n    \'Cookie\': \'anonymid=jacdwz2x-8bjldx; depovince=GW; _r01_=1; _ga=GA1.2.1455063316.1511436360; _gid=GA1.2.862627163.1511436360; wp=1; JSESSIONID=abczwY8ecd4xz8RJcyP-v; jebecookies=d4497791-9d41-4269-9e2b-3858d4989785|||||; ick_login=884e75d4-f361-4cff-94bb-81fe6c42b220; _de=EA5778F44555C091303554EBBEB4676C696BF75400CE19CC; p=61a3c7d0d4b2d1e991095353f83fa2141; first_login_flag=1; ln_uact=970138074@qq.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn121/20170428/1700/main_nhiB_aebd0000854a1986.jpg; t=3dd84a3117737e819dd2c32f1cdb91d01; societyguester=3dd84a3117737e819dd2c32f1cdb91d01; id=443362311; xnsid=169efdc0; loginfrom=syshome; ch_id=10016; jebe_key=9c062f5a-4335-4a91-bf7a-970f8b86a64e%7Ca022c303305d1b2ab6b5089643e4b5de%7C1511449232839%7C1; wp_fold=0\'\n}\nurl = \'http://www.renren.com/880151247/profile\'\nreq = request.Request(url,headers=headers)\nresp = request.urlopen(req)\nwith open(\'renren.html\',\'w\') as fp:\n    fp.write(resp.read().decode(\'utf-8\'))\n```\n但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过`http.cookiejar`模块和`urllib模块的HTTPCookieProcessor`处理器类一起使用。`http.cookiejar`模块主要作用是提供用于存储cookie的对象。而`HTTPCookieProcessor`处理器主要作用是处理这些cookie对象，并构建handler对象。\n#### http.cookiejar模块：\n该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：\n\n1. CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。\n1. FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。\n1. MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。\n1. LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。\n#### 登录人人网：\n利用`http.cookiejar`和`request.HTTPCookieProcessor`登录人人网。相关示例代码如下：\n```python\nfrom urllib import request,parse\nfrom http.cookiejar import CookieJar\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\'\n}\ndef get_opener():\n    cookiejar = CookieJar()\n    handler = request.HTTPCookieProcessor(cookiejar)\n    opener = request.build_opener(handler)\n    return opener\ndef login_renren(opener):\n    data = {\"email\": \"970138074@qq.com\", \"password\": \"pythonspider\"}\n    data = parse.urlencode(data).encode(\'utf-8\')\n    login_url = \"http://www.renren.com/PLogin.do\"\n    req = request.Request(login_url, headers=headers, data=data)\n    opener.open(req)\ndef visit_profile(opener):\n    url = \'http://www.renren.com/880151247/profile\'\n    req = request.Request(url,headers=headers)\n    resp = opener.open(req)\n    with open(\'renren.html\',\'w\') as fp:\n        fp.write(resp.read().decode(\"utf-8\"))\nif __name__ == \'__main__\':\n    opener = get_opener()\n    login_renren(opener)\n    visit_profile(opener)\n```\n#### 保存cookie到本地：\n保存`cookie`到本地，可以使用`cookiejar`的`save`方法，并且需要指定一个文件名：\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\ncookiejar = MozillaCookieJar(\"cookie.txt\")\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\'\n}\nreq = request.Request(\'http://httpbin.org/cookies\',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\ncookiejar.save(ignore_discard=True,ignore_expires=True)\n```\n#### 从本地加载cookie：\n从本地加载`cookie`，需要使用`cookiejar`的`load`方法，并且也需要指定方法：\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\ncookiejar = MozillaCookieJar(\"cookie.txt\")\ncookiejar.load(ignore_expires=True,ignore_discard=True)\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\'\n}\nreq = request.Request(\'http://httpbin.org/cookies\',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\n```\n\n---\n\n## 第四节：requests库\n虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。\n### 安装和文档地址：\n利用`pip`可以非常方便的安装：\n```\npip install requests\n```\n中文文档：[https://docs.python-requests.org/zh_CN/latest/](https://docs.python-requests.org/zh_CN/latest/)\ngithub地址：[https://github.com/requests/requests](https://github.com/requests/requests)\n参考我的博客：[https://www.cnblogs.com/XJT2018/p/10312750.html](https:_www.cnblogs.com_xjt2018_p_10312750)\n### 发送GET请求：\n\n1. 最简单的发送`get`请求就是通过`requests.get`来调用：\n```python\nresponse = requests.get(\"http://www.baidu.com/\")\n```\n\n1. 添加headers和查询参数：\n如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下：\n```python\nimport requests\nkw = {\'wd\':\'中国\'}\nheaders = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\"}\n# params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()\nresponse = requests.get(\"http://www.baidu.com/s\", params = kw, headers = headers)\n# 查看响应内容，response.text 返回的是Unicode格式的数据\nprint(response.text)\n# 查看响应内容，response.content返回的字节流数据，即Unicode编码信息\nprint(response.content)\n# 查看完整url地址\nprint(response.url)\n# 查看响应头部字符编码\nprint(response.encoding)\n# 查看响应码\nprint(response.status_code)\n```\nresponse方法总结：\n```python\nresponse = requests.get(url=\"http://www.baidu.com\",params=None)     # get(url, params=None, **kwargs)\n\nresponse.text       #获取网页HTML\nresponse.content        #响应内容是二进制数据 如图片 视频等\nresponse.encoding       #设置编码\nresponse.apparent_encoding      #获取网页的编码方式\nresponse.status_code        #获取请求的状态码\nrespone.headers        #获取请求头\nrespone.cookies        #获取cookies返回一个对象\nrespone.cookies.get_dict()        #返回cookies具体内容\nrespone.url        #获取请求地址\nrespone.history        #重定向\nresponse.close()        ##关闭response\nresponse.json() 	#直接获取json数据\n```\n### 发送POST请求：\n\n1. 最基本的POST请求可以使用`post`方法：\n```python\nresponse = requests.post(\"http://www.baidu.com/\",data=data)\n```\n\n1. 传入data数据：\n这时候就不要再使用`urlencode`进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码：\n```python\nimport requests\nurl = \"https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&needAddtionalResult=false&isSchoolJob=0\"\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\',\n    \'Referer\': \'https://www.lagou.com/jobs/list_python?labelWords=&fromSearch=true&suginput=\'\n}\ndata = {\n    \'first\': \'true\',\n    \'pn\': 1,\n    \'kd\': \'python\'\n}\nresp = requests.post(url,headers=headers,data=data)\n# 如果是json数据，直接可以调用json方法\nprint(resp.json())\n```\n### 使用代理：\n使用`requests`添加代理也非常简单，只要在请求的方法中（比如`get`或者`post`）传递`proxies`参数就可以了。示例代码如下：\n```python\nimport requests\nurl = \"http://httpbin.org/get\"\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\',\n}\nproxy = {\n    \'http\': \'171.14.209.180:27829\'\n}\nresp = requests.get(url,headers=headers,proxies=proxy)\nwith open(\'xx.html\',\'w\',encoding=\'utf-8\') as fp:\n    fp.write(resp.text)\n```\n### cookie：\n如果在一个响应中包含了`cookie`，那么可以利用`cookies`属性拿到这个返回的`cookie`值：\n```python\nimport requests\nurl = \"http://www.renren.com/PLogin.do\"\ndata = {\"email\":\"970138074@qq.com\",\'password\':\"pythonspider\"}\nresp = requests.get(\'http://www.baidu.com/\')\nprint(resp.cookies)\nprint(resp.cookies.get_dict())\n```\n### session：\n之前使用`urllib`库，是可以使用`opener`发送多个请求，多个请求之间是可以共享`cookie`的。那么如果使用`requests`，也要达到共享`cookie`的目的，那么可以使用`requests`库给我们提供的`session`对象。注意，这里的`session`不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用`requests`来实现。示例代码如下：\n```python\nimport requests\nurl = \"http://www.renren.com/PLogin.do\"\ndata = {\"email\":\"970138074@qq.com\",\'password\':\"pythonspider\"}\nheaders = {\n    \'User-Agent\': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\"\n}\n# 登录\nsession = requests.session()\nsession.post(url,data=data,headers=headers)\n# 访问大鹏个人中心\nresp = session.get(\'http://www.renren.com/880151247/profile\')\nprint(resp.text)\n```\n### 处理不信任的SSL证书：\n对于那些已经被信任的SSL整数的网站，比如`[https://www.baidu.com/](https://www.baidu.com/)`，那么使用`requests`直接就可以正常的返回响应。示例代码如下：\n```python\nresp = requests.get(\'http://www.12306.cn/mormhweb/\',verify=False)\nprint(resp.content.decode(\'utf-8\'))\n```\n','原创','','','','','',8,1455457901559312386,1,0,0,'2022-01-07 21:52:52','2022-01-08 20:59:30'),(1479451767195336706,'【Python爬虫】2、数据解析','常见的解析方式有：正则、pyquery、beautifulSoup、xpath，重点掌握正则和xpath这两种解析方式即可','https://ae02.alicdn.com/kf/Hbf259df9c96840478411355917e357a6t.png','## 一、XPath（推荐）\n参考崔庆才博客：[https://cuiqingcai.com/2621.html](https:_cuiqingcai.com_2621)\n[https://www.cnblogs.com/zhangxinqi/p/9210211.html](https://www.cnblogs.com/zhangxinqi/p/9210211.html)\n### 1、概念\n**什么是XPath？**\nxpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。\n**XPath开发工具**\n\n1. Chrome插件XPath Helper。\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1640613517952-ac12800b-df52-4cd4-816c-a7145a855607.png#clientId=u7a3a2df5-fadd-4&from=paste&height=442&id=u0a598999&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1500&originalType=binary&ratio=1&size=259402&status=done&style=stroke&taskId=u64c193d9-1cc1-4b3f-bb39-5002024371f&width=750)\n\n2. Firefox插件Try XPath。\n### 3.XPath语法\n#### 3.1 选取节点：\nXPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。\n\n| 表达式 | 描述 | 示例 | 结果 |\n| --- | --- | --- | --- |\n| nodename | 选取此节点的所有子节点 | bookstore | 选取bookstore下所有的子节点 |\n| / | 如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点 | /bookstore | 选取根元素下所有的bookstore节点 |\n| // | 从全局节点中选择节点，随便在哪个位置 | //book | 从全局节点中找到所有的book节点 |\n| @ | 选取某个节点的属性 | //book[@price] | 选择所有拥有price属性的book节点 |\n| . | 当前节点 | ./a | 选取当前节点下的a标签 |\n| .. | 选取当前节点的父节点 |  |  |\n\n#### 3.2 谓语：\n谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。\n在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：\n\n| 路径表达式 | 描述 |\n| --- | --- |\n| /bookstore/book[1] | 选取bookstore下的第1个子元素 |\n| /bookstore/book[last()] | 选取bookstore下的倒数第1个book元素。 |\n| bookstore/book[position()<3] | 选取bookstore下前面两个子元素。 |\n| //book[@price] | 选取拥有price属性的book元素 |\n| //book[@price=10] | 选取所有属性price等于10的book元素 |\n| /bookstore/book[price>35.00] | 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 |\n\n#### 3.3 通配符\n*表示通配符。\n\n| 通配符 | 描述 | 示例 | 结果 |\n| --- | --- | --- | --- |\n| * | 匹配任意节点 | /bookstore/* | 选取bookstore下的所有子元素。 |\n| @* | 匹配节点中的任何属性 | //book[@*] | 选取所有带有属性的book元素。 |\n| //title[@*] | 选取所有带有属性的 title 元素。 |  |  |\n\n#### 3.4 选取多个路径：\n通过在路径表达式中使用“|”运算符，可以选取若干个路径。\n示例如下：\n```\n//bookstore/book | //book/title\n# 选取所有book元素以及book元素下所有的title元素\n```\n#### 3.5 运算符：\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1601216559655-dda9762a-a685-40e9-8f97-7f0b59135748.png#id=MyZHe&originHeight=879&originWidth=828&originalType=binary&ratio=1&status=done&style=none)\n#### 3.6 功能函数\n使用功能函数能够更好的进行模糊搜索\n\n| 函数 | 用法 | 解释 |\n| --- | --- | --- |\n| starts-with | xpath(‘//div[starts-with(@id,”ma”)]‘) | 选取id值以ma开头的div节点 |\n| contains | xpath(‘//div[contains(@id,”ma”)]‘) | 选取id值包含ma的div节点 |\n| and | xpath(‘//div[contains(@id,”ma”) and contains(@id,”in”)]‘) | 选取id值包含ma和in的div节点 |\n| text() | xpath(‘//div[contains(text(),”ma”)]‘) | 选取节点文本包含ma的div节点 |\n\n补充：\n//input[not(@id=\'123\')] 　　　　　　　　　　　　　　找id不为123的input\n//span[substring(@name,3,5)=\'xxxxx\'] 　　　　　　　name属性第3个字符开始的5个字符是xxxxx的\n//span[sbustring-before(@class,\"-\")=\"spanclass1\"]　　class属性中-字符前面的字符是spanclass1\n//span[sbustring-after(@class,\"-\")=\"spanclass1\"]　　　class属性中-字符后面的字符是spanclass1\n//div[div[@id=\'xxx\']]　　　　　　　　　　　　　　　　依靠子节点定位\n### 4.lxml库\nlxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。\nlxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。\nlxml python 官方文档：[http://lxml.de/index.html](http:_lxml.de_index)\n需要安装C语言库，可使用 pip 安装：`pip install lxml`\n#### 4.1 基本使用：\n我们可以利用它来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，它会自动的进行补全。示例代码如下：\n```python\n# 使用 lxml 的 etree 库\nfrom lxml import etree \ntext = \'\'\'\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5\">fifth item</a> # 注意，此处缺少一个 </li> 闭合标签\n     </ul>\n </div>\n\'\'\'\n#利用etree.HTML，将字符串解析为HTML文档\nhtml = etree.HTML(text) \n# 按字符串序列化HTML文档\nresult = etree.tostring(html) \nprint(result)\n```\n输入结果如下：\n```html\n<html><body>\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5\">fifth item</a></li>\n</ul>\n</div>\n</body></html>\n```\n可以看到。lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。\n#### 4.2 从文件中读取html代码：\n除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件：\n```html\n<!-- hello.html -->\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3\"><span class=\"bold\">third item</span></a></li>\n         <li class=\"item-1\"><a href=\"link4\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5\">fifth item</a></li>\n     </ul>\n </div>\n```\n然后利用`etree.parse()`方法来读取文件。示例代码如下：\n```python\nfrom lxml import etree\n# 读取外部文件 hello.html\nhtml = etree.parse(\'hello.html\')\nresult = etree.tostring(html, pretty_print=True)\nprint(result)\n```\n输入结果和之前是相同的。\n#### 4.3 在lxml中使用XPath语法：\n\n1. 获取所有li标签：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n print(type(html))  # 显示etree.parse()返回类型\n result = html.xpath(\'//li\')\n print(result)  # 打印<li>标签的元素集合\n```\n\n1. 获取所有li元素下的所有class属性的值：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li/@class\')\n print(result)\n```\n\n1. 获取li标签下href为`www.baidu.com`的a标签：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li/a[@href=\"www.baidu.com\"]\')\n print(result)\n```\n\n1. 获取li标签下所有span标签：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n #result = html.xpath(\'//li/span\')\n #注意这么写是不对的：\n #因为 / 是用来获取子元素的，而 <span> 并不是 <li> 的子元素，所以，要用双斜杠\n result = html.xpath(\'//li//span\')\n print(result)\n```\n\n1. 获取li标签下的a标签里的所有class：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li/a//@class\')\n print(result)\n```\n\n1. 获取最后一个li的a的href属性对应的值：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li[last()]/a/@href\')\n # 谓语 [last()] 可以找到最后一个元素\n print(result)\n```\n\n1. 获取倒数第二个li元素的a标签内容：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li[last()-1]/a\')\n # text 方法可以获取元素内容\n print(result[0].text)\n```\n\n1. 获取倒数第二个li元素的a标签内容的第二种方式：\n```python\nfrom lxml import etree\n html = etree.parse(\'hello.html\')\n result = html.xpath(\'//li[last()-1]/a/text()\')\n print(result)\n```\n#### 4.4 使用requests和xpath爬取电影天堂\n示例代码如下：\n```python\nimport requests\nfrom lxml import etree\nBASE_DOMAIN = \'https://www.dytt8.net/\'\nHEADERS = {\n    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\',\n    \'Referer\': \'http://www.dytt8.net/html/gndy/dyzz/list_23_2.html\'\n}\ndef spider():\n    url = \'http://www.dytt8.net/html/gndy/dyzz/list_23_1.html\'\n    resp = requests.get(url,headers=HEADERS)\n    # resp.content：经过编码后的字符串\n    # resp.text：没有经过编码，也就是unicode字符串\n    # text：相当于是网页中的源代码了\n    text = resp.content.decode(\'gbk\')\n    # tree：经过lxml解析后的一个对象，以后使用这个对象的xpath方法，就可以\n    # 提取一些想要的数据了\n    tree = etree.HTML(text)\n    # xpath/beautifulsou4\n    all_a = tree.xpath(\"//div[@class=\'co_content8\']//a\")\n    for a in all_a:\n        title = a.xpath(\"text()\")[0]\n        href = a.xpath(\"@href\")[0]\n        if href.startswith(\'/\'):\n            detail_url = BASE_DOMAIN + href\n            crawl_detail(detail_url)\n            break\ndef crawl_detail(url):\n    resp = requests.get(url,headers=HEADERS)\n    text = resp.content.decode(\'gbk\')\n    tree = etree.HTML(text)\n    create_time = tree.xpath(\"//div[@class=\'co_content8\']/ul/text()\")[0].strip()\n    imgs = tree.xpath(\"//div[@id=\'Zoom\']//img/@src\")\n    # 电影海报\n    cover = imgs[0]\n    # 电影截图\n    screenshoot = imgs[1]\n    # 获取span标签下所有的文本\n    infos = tree.xpath(\"//div[@id=\'Zoom\']//text()\")\n    for index,info in enumerate(infos):\n        if info.startswith(\"◎年　　代\"):\n            year = info.replace(\"◎年　　代\",\"\").strip()\n        if info.startswith(\"◎豆瓣评分\"):\n            douban_rating = info.replace(\"◎豆瓣评分\",\'\').strip()\n            print(douban_rating)\n        if info.startswith(\"◎主　　演\"):\n            # 从当前位置，一直往下面遍历\n            actors = [info]\n            for x in range(index+1,len(infos)):\n                actor = infos[x]\n                if actor.startswith(\"◎\"):\n                    break\n                actors.append(actor.strip())\n            print(\",\".join(actors))\nif __name__ == \'__main__\':\n    spider()\n```\n### 5.chrome相关问题：\n在62版本（目前最新）中有一个bug，在页面302重定向的时候不能记录FormData数据。这个是这个版本的一个bug。详细见以下链接：[https://stackoverflow.com/questions/34015735/http-post-payload-not-visible-in-chrome-debugger](https://stackoverflow.com/questions/34015735/http-post-payload-not-visible-in-chrome-debugger)。\n在金丝雀版本中已经解决了这个问题，可以下载这个版本继续，链接如下：[https://www.google.com/chrome/browser/canary.html](https:_www.google.com_chrome_browser_canary)\n### 6.作业：\n使用requests和xpath爬取腾讯招聘网信息。要求为获取每个职位的详情信息。\n\n---\n\n## 二、BeautifulSoup4库\n和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。lxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM（Document Object Model）的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。\nBeautifulSoup 用来解析 HTML 比较简单，API非常人性化，支持CSS选择器、Python标准库中的HTML解析器，也支持 lxml 的 XML解析器。\nBeautiful Soup 3 目前已经停止开发，推荐现在的项目使用Beautiful Soup 4。\n参考我的博客：[https://www.cnblogs.com/XJT2018/p/10315533.html](https:_www.cnblogs.com_xjt2018_p_10315533)\n### 1.安装和文档：\n\n1. 安装：`pip install bs4`。\n1. 中文文档：[https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html](https:_www.crummy.com_software_beautifulsoup_bs4_doc_index.zh)\n### 2.几大解析工具对比：\n| 解析工具 | 解析速度 | 使用难度 |\n| --- | --- | --- |\n| BeautifulSoup | 最慢 | 最简单 |\n| lxml | 快 | 简单 |\n| 正则 | 最快 | 最难 |\n\n### 3.简单使用：\n```python\nfrom bs4 import BeautifulSoup\nhtml = \"\"\"\n<html><head><title>The Dormouse\'s story</title></head>\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse\'s story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n\"\"\"\n#创建 Beautiful Soup 对象\n# 使用lxml来进行解析\nsoup = BeautifulSoup(html,\"lxml\")\nprint(soup.prettify())\n```\n### 4.四个常用的对象：\nBeautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:\n\n1. Tag\n1. NavigatableString\n1. BeautifulSoup\n1. Comment\n#### 4.1 Tag：\nTag 通俗点讲就是 HTML 中的一个个标签。示例代码如下：\n```python\nfrom bs4 import BeautifulSoup\nhtml = \"\"\"\n<html><head><title>The Dormouse\'s story</title></head>\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse\'s story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n\"\"\"\n#创建 Beautiful Soup 对象\nsoup = BeautifulSoup(html,\'lxml\')\nprint soup.title\n# <title>The Dormouse\'s story</title>\nprint soup.head\n# <head><title>The Dormouse\'s story</title></head>\nprint soup.a\n# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\nprint soup.p\n# <p class=\"title\" name=\"dromouse\"><b>The Dormouse\'s story</b></p>\nprint type(soup.p)\n# <class \'bs4.element.Tag\'>\n```\n我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。\n对于Tag，它有两个重要的属性，分别是name和attrs。示例代码如下：\n```python\nprint soup.name\n# [document] #soup 对象本身比较特殊，它的 name 即为 [document]\nprint soup.head.name\n# head #对于其他内部标签，输出的值便为标签本身的名称\nprint soup.p.attrs\n# {\'class\': [\'title\'], \'name\': \'dromouse\'}\n# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。\nprint soup.p[\'class\'] # soup.p.get(\'class\')\n# [\'title\'] #还可以利用get方法，传入属性的名称，二者是等价的\nsoup.p[\'class\'] = \"newClass\"\nprint soup.p # 可以对这些属性和内容等等进行修改\n# <p class=\"newClass\" name=\"dromouse\"><b>The Dormouse\'s story</b></p>\n```\n#### 4.2 NavigableString：\n如果拿到标签后，还想获取标签中的内容。那么可以通过`tag.string`获取标签中的文字。示例代码如下：\n```python\nprint soup.p.string\n# The Dormouse\'s story\nprint type(soup.p.string)\n# <class \'bs4.element.NavigableString\'>thon\n```\n#### 4.3 BeautifulSoup：\nBeautifulSoup 对象表示的是一个文档的全部内容。大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法.\n因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name\n```python\nsoup.name\n# \'[document]\'\n```\n#### 4.4 Comment：\nTag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:\n```python\nmarkup = \"<b><!--Hey, buddy. Want to buy a used parser?--></b>\"\nsoup = BeautifulSoup(markup)\ncomment = soup.b.string\ntype(comment)\n# <class \'bs4.element.Comment\'>\n```\nComment 对象是一个特殊类型的 NavigableString 对象:\n```python\ncomment\n# \'Hey, buddy. Want to buy a used parser\'\n```\n### 5.遍历文档树：\n#### 5.1 contents和children：\n```python\nhtml_doc = \"\"\"\n<html><head><title>The Dormouse\'s story</title></head>\n<p class=\"title\"><b>The Dormouse\'s story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n\"\"\"\nfrom bs4 import BeautifulSoup\nsoup = BeautifulSoup(html_doc,\'lxml\')\nhead_tag = soup.head\n# 返回所有子节点的列表\nprint(head_tag.contents)\n# 返回所有子节点的迭代器\nfor child in head_tag.children:\n    print(child)\n```\n#### 5.2 strings 和 stripped_strings\n如果tag中包含多个字符串 [2] ,可以使用 .strings 来循环获取：\n```python\nfor string in soup.strings:\n    print(repr(string))\n    # u\"The Dormouse\'s story\"\n    # u\'\\n\\n\'\n    # u\"The Dormouse\'s story\"\n    # u\'\\n\\n\'\n    # u\'Once upon a time there were three little sisters; and their names were\\n\'\n    # u\'Elsie\'\n    # u\',\\n\'\n    # u\'Lacie\'\n    # u\' and\\n\'\n    # u\'Tillie\'\n    # u\';\\nand they lived at the bottom of a well.\'\n    # u\'\\n\\n\'\n    # u\'...\'\n    # u\'\\n\'\n```\n输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容：\n```python\nfor string in soup.stripped_strings:\n    print(repr(string))\n    # u\"The Dormouse\'s story\"\n    # u\"The Dormouse\'s story\"\n    # u\'Once upon a time there were three little sisters; and their names were\'\n    # u\'Elsie\'\n    # u\',\'\n    # u\'Lacie\'\n    # u\'and\'\n    # u\'Tillie\'\n    # u\';\\nand they lived at the bottom of a well.\'\n    # u\'...\'\n```\n### 6.搜索文档树：\n#### 6.1 find和find_all方法：\n搜索文档树，一般用得比较多的就是两个方法，一个是`find`，一个是`find_all`。`find`方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。`find_all`方法是把所有满足条件的标签都选到，然后返回回去。使用这两个方法，最常用的用法是出入`name`以及`attr`参数找出符合要求的标签。\n```python\nsoup.find_all(\"a\",attrs={\"id\":\"link2\"})\n```\n或者是直接传入属性的的名字作为关键字参数：\n```python\nsoup.find_all(\"a\",id=\'link2\')\n```\n#### 6.2 select方法：\n使用以上方法可以方便的找出元素。但有时候使用`css`选择器的方式可以更加的方便。使用`css`选择器的语法，应该使用`select`方法。以下列出几种常用的`css`选择器方法：\n#### （1）通过标签名查找：\n```python\nprint(soup.select(\'a\'))\n```\n#### （2）通过类名查找：\n通过类名，则应该在类的前面加一个`.`。比如要查找`class=sister`的标签。示例代码如下：\n```python\nprint(soup.select(\'.sister\'))\n```\n#### （3）通过id查找：\n通过id查找，应该在id的名字前面加一个＃号。示例代码如下：\n```python\nprint(soup.select(\"#link1\"))\n```\n#### （4）组合查找：\n组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开：\n```python\nprint(soup.select(\"p #link1\"))\n```\n直接子标签查找，则使用 > 分隔：\n```python\nprint(soup.select(\"head > title\"))\n```\n#### （5）通过属性查找：\n查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下：\n```python\nprint(soup.select(\'a[href=\"http://example.com/elsie\"]\'))\n```\n#### （6）获取内容\n以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。\n```python\nsoup = BeautifulSoup(html, \'lxml\')\nprint type(soup.select(\'title\'))\nprint soup.select(\'title\')[0].get_text()\nfor title in soup.select(\'title\'):\n    print title.get_text()\n```\n\n---\n\n## 三、正则表达式（re）：\n什么是正则表达式：\n通俗理解：按照一定的规则，从某个字符串中匹配出想要的数据。这个规则就是正则表达式。\n标准答案：[https://baike.baidu.com/item/](https://baike.baidu.com/item/)正则表达式/1700215?fr=aladdin\n一个段子：\n世界是分为两种人，一种是懂正则表达式的，一种是不懂正则表达式的。\n参考我的博客：[https://www.cnblogs.com/XJT2018/p/10872274.html](https:_www.cnblogs.com_xjt2018_p_10872274)\n[https://www.cnblogs.com/XJT2018/p/10312830.html](https:_www.cnblogs.com_xjt2018_p_10312830)\n### 1.正则表达式常用匹配规则：\n| 模式 | 描述 |\n| --- | --- |\n| **\\w** | 匹配字母数字及下划线 |\n| **\\W** | 匹配非字母数字下划线 |\n| **\\s** | 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. |\n| **\\S** | 匹配任意非空字符 |\n| **\\d** | 匹配任意数字，等价于 [0-9] |\n| **\\D** | 匹配任意非数字 |\n| **\\A** | 匹配字符串开始 |\n| **\\Z** | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 |\n| **\\z** | 匹配字符串结束 |\n| **\\G** | 匹配最后匹配完成的位置 |\n| **\\n** | 匹配一个换行符 |\n| **\\t** | 匹配一个制表符 |\n| **^** | 匹配字符串的开头 |\n| **$** | 匹配字符串的末尾。 |\n| **.** | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |\n| **[...]** | 用来表示一组字符,单独列出：[amk] 匹配 \'a\'，\'m\'或\'k\' |\n| **[^...]** | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 |\n| * | 匹配0个或多个的表达式。 |\n| **+** | 匹配1个或多个的表达式。 |\n| **?** | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 |\n| **{n}** | 精确匹配n个前面表达式。 |\n| **{n, m}** | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 |\n| **a|b** | 匹配a或b |\n| **( )** | 匹配括号内的表达式，也表示一个组 |\n\n#### 1.1 匹配某个字符串：\n```python\ntext = \'hello\'\nret = re.match(\'he\',text)\nprint(ret.group())\n>> he\n```\n以上便可以在`hello`中，匹配出`he`。\n#### 1.2 点（.）匹配任意的字符：\n```python\ntext = \"ab\"\nret = re.match(\'.\',text)\nprint(ret.group())\n>> a\n```\n但是点（.）不能匹配不到换行符。示例代码如下：\n```python\ntext = \"ab\"\nret = re.match(\'.\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute \'group\'\n```\n#### 1.3 \\d匹配任意的数字：\n```python\ntext = \"123\"\nret = re.match(\'\\d\',text)\nprint(ret.group())\n>> 1\n```\n#### 1.4 \\D匹配任意的非数字：\n```python\ntext = \"a\"\nret = re.match(\'\\D\',text)\nprint(ret.group())\n>> a\n```\n而如果text是等于一个数字，那么就匹配不成功了。示例代码如下：\n```python\ntext = \"1\"\nret = re.match(\'\\D\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute \'group\'\n```\n#### 1.5 \\s匹配的是空白字符（包括：\\n，\\t，\\r和空格）：\n```python\ntext = \"\\t\"\nret = re.match(\'\\s\',text)\nprint(ret.group())\n>> 空白\n```\n#### 1.6 \\S匹配任意的非空白字符\n#### 1.7 \\w匹配的是`a-z`和`A-Z`以及数字和下划线：\n```python\ntext = \"_\"\nret = re.match(\'\\w\',text)\nprint(ret.group())\n>> _\n```\n而如果要匹配一个其他的字符，那么就匹配不到。示例代码如下：\n```python\ntext = \"+\"\nret = re.match(\'\\w\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute\n```\n#### 1.8 \\W匹配的是和\\w相反的：\n```python\ntext = \"+\"\nret = re.match(\'\\W\',text)\nprint(ret.group())\n>> +\n```\n而如果你的text是一个下划线或者英文字符，那么就匹配不到了。示例代码如下：\n```python\ntext = \"_\"\nret = re.match(\'\\W\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute\n```\n#### 1.9 []组合的方式，只要满足中括号中的某一项都算匹配成功：\n```python\ntext = \"0731-88888888\"\nret = re.match(\'[\\d\\-]+\',text)\nprint(ret.group())\n>> 0731-88888888\n```\n之前讲到的几种匹配规则，其实可以使用中括号的形式来进行替代：\n\n- \\d：[0-9]\n- \\D：[0-9](#fn_0-9)\n- \\w：[0-9a-zA-Z_]\n- \\W：[^0-9a-zA-Z_]\n#### 1.10 * + ？：\n\n1. `*`：可以匹配0或者任意多个字符。示例代码如下：\n```python\ntext = \"0731\"\n ret = re.match(\'\\d*\',text)\n print(ret.group())\n >> 0731\n```\n\n1. 以上因为匹配的要求是`\\d`，那么就要求是数字，后面跟了一个星号，就可以匹配到0731这四个字符。\n1. `+`：可以匹配1个或者多个字符。最少一个。示例代码如下：\n```python\ntext = \"abc\"\n ret = re.match(\'\\w+\',text)\n print(ret.group())\n >> abc\n```\n\n1. 因为匹配的是`\\w`，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足`\\w`的字符才能够匹配到。如果text是一个空白字符或者是一个不满足\\w的字符，那么就会报错。示例代码如下：\n```python\ntext = \"\"\n ret = re.match(\'\\w+\',text)\n print(ret.group())\n >> AttributeError: \'NoneType\' object has no attribute\n```\n\n1. `?`：匹配的字符可以出现一次或者不出现（0或者1）。示例代码如下：\n```python\ntext = \"123\"\n ret = re.match(\'\\d?\',text)\n print(ret.group())\n >> 1\n```\n\n1. `{m}`：匹配m个字符。示例代码如下：\n```python\ntext = \"123\"\n ret = re.match(\'\\d{2}\',text)\n print(ret.group())\n >> 12\n```\n\n1. `{m,n}`：匹配m-n个字符。在这中间的字符都可以匹配到。示例代码如下：\n```python\ntext = \"123\"\n ret = re.match(\'\\d{1,2}\',text)\n prit(ret.group())\n >> 12\n```\n\n1. 如果text只有一个字符，那么也可以匹配出来。示例代码如下：\n```python\ntext = \"1\"\n ret = re.match(\'\\d{1,2}\',text)\n prit(ret.group())\n >> 1\n```\n### 2.案例：\n\n1. 验证手机号码：手机号码的规则是以`1`开头，第二位可以是`34587`，后面那9位就可以随意了。示例代码如下：\n```python\ntext = \"18570631587\"\n ret = re.match(\'1[34587]\\d{9}\',text)\n print(ret.group())\n >> 18570631587\n```\n\n1. 而如果是个不满足条件的手机号码。那么就匹配不到了。示例代码如下：\n```python\ntext = \"1857063158\"\n ret = re.match(\'1[34587]\\d{9}\',text)\n print(ret.group())\n >> AttributeError: \'NoneType\' object has no attribute\n```\n\n1. 验证邮箱：邮箱的规则是邮箱名称是用`数字、数字、下划线`组成的，然后是`@`符号，后面就是域名了。示例代码如下：\n```python\ntext = \"hynever@163.com\"\n ret = re.match(\'\\w+@\\w+\\.[a-zA-Z\\.]+\',text)\n print(ret.group())\n```\n\n1. 验证URL：URL的规则是前面是`http`或者`https`或者是`ftp`然后再加上一个冒号，再加上一个斜杠，再后面就是可以出现任意非空白字符了。示例代码如下：\n```python\ntext = \"http://www.baidu.com/\"\n ret = re.match(\'(http|https|ftp)://[^\\s]+\',text)\n print(ret.group())\n```\n\n1. 验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X。示例代码如下：\n```python\ntext = \"3113111890812323X\"\n ret = re.match(\'\\d{17}[\\dxX]\',text)\n print(ret.group())\n```\n#### 1.11 ^ ：表示以...开始：\n```python\ntext = \"hello\"\nret = re.match(\'^h\',text)\nprint(ret.group())\n```\n如果是在中括号中，那么代表的是取反操作.\n#### 1.12 $：表示以...结束：\n```python\n# 匹配163.com的邮箱\ntext = \"xxx@163.com\"\nret = re.search(\'\\w+@163\\.com$\',text)\nprint(ret.group())\n>> xxx@163.com\n```\n#### 1.13 |：匹配多个表达式或者字符串：\n```python\ntext = \"hello|world\"\nret = re.search(\'hello\',text)\nprint(ret.group())\n>> hello\n```\n#### 1.14 贪婪模式和非贪婪模式：\n贪婪模式：正则表达式会匹配尽量多的字符。默认是贪婪模式。\n非贪婪模式：正则表达式会尽量少的匹配字符。\n示例代码如下：\n```python\ntext = \"0123456\"\nret = re.match(\'\\d+\',text)\nprint(ret.group())\n# 因为默认采用贪婪模式，所以会输出0123456\n>> 0123456\n```\n可以改成非贪婪模式，那么就只会匹配到0。示例代码如下：\n```python\ntext = \"0123456\"\nret = re.match(\'\\d+?\',text)\nprint(ret.group())\n```\n### 3.案例：匹配`0-100`之间的数字：\n```python\ntext = \'99\'\nret = re.match(\'[1-9]?\\d$|100$|0\',text)\nprint(ret.group())\n>> 99\n```\n而如果`text=101`，那么就会抛出一个异常。示例代码如下：\n```python\ntext = \'101\'\nret = re.match(\'[1-9]?\\d$|100$\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute \'group\'\n```\n#### 1.15 转义字符和原生字符串：\n在正则表达式中，有些字符是有特殊意义的字符。因此如果想要匹配这些字符，那么就必须使用反斜杠进行转义。比如`$`代表的是以...结尾，如果想要匹配`$`，那么就必须使用`\\$`。示例代码如下：\n```python\ntext = \"apple price is \\$99,orange paice is $88\"\nret = re.search(\'\\$(\\d+)\',text)\nprint(ret.group())\n>> $99\n```\n原生字符串：\n在正则表达式中，`\\`是专门用来做转义的。在Python中`\\`也是用来做转义的。因此如果想要在普通的字符串中匹配出`\\`，那么要给出四个`\\`。示例代码如下：\n```python\ntext = \"apple \\c\"\nret = re.search(\'\\\\\\\\c\',text)\nprint(ret.group())\n```\n因此要使用原生字符串就可以解决这个问题：\n```python\ntext = \"apple \\c\"\nret = re.search(r\'\\\\c\',text)\nprint(ret.group())\n```\n\n---\n\n### 4.re模块中常用函数：\n#### match：\n从开始的位置进行匹配。如果开始的位置没有匹配到。就直接失败了。示例代码如下：\n```python\ntext = \'hello\'\nret = re.match(\'h\',text)\nprint(ret.group())\n>> h\n```\n如果第一个字母不是`h`，那么就会失败。示例代码如下：\n```python\ntext = \'ahello\'\nret = re.match(\'h\',text)\nprint(ret.group())\n>> AttributeError: \'NoneType\' object has no attribute \'group\'\n```\n如果想要匹配换行的数据，那么就要传入一个`flag=re.DOTALL`，就可以匹配换行符了。示例代码如下：\n```python\ntext = \"abc\\nabc\"\nret = re.match(\'abc.*abc\',text,re.DOTALL)\nprint(ret.group())\n```\n#### search：\n在字符串中找满足条件的字符。如果找到，就返回。说白了，就是只会找到第一个满足条件的。\n```python\ntext = \'apple price $99 orange price $88\'\nret = re.search(\'\\d+\',text)\nprint(ret.group())\n>> 99\n```\n#### 分组：\n在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式。\n\n1. `group`：和`group(0)`是等价的，返回的是整个满足条件的字符串。\n1. `groups`：返回的是里面的子组。索引从1开始。\n1. `group(1)`：返回的是第一个子组，可以传入多个。\n示例代码如下：\n```python\ntext = \"apple price is $99,orange price is $10\"\nret = re.search(r\".*(\\$\\d+).*(\\$\\d+)\",text)\nprint(ret.group())\nprint(ret.group(0))\nprint(ret.group(1))\nprint(ret.group(2))\nprint(ret.groups())\n```\n#### findall：\n找出所有满足条件的，返回的是一个列表。\n```python\ntext = \'apple price $99 orange price $88\'\nret = re.findall(\'\\d+\',text)\nprint(ret)\n>> [\'99\', \'88\']\n```\n#### sub：\n用来替换字符串。将字符串中匹配到的内容替换为其他字符串。\n```python\ntext = \'apple price $99 orange price $88\'\nret = re.sub(\'\\d+\',\'0\',text)\nprint(ret)\n>> apple price $0 orange price $0\n```\n源码释义：\n```python\ndef sub(pattern, repl, string, count=0, flags=0):\n	    \"\"\"Return the string obtained by replacing the leftmost\n	    non-overlapping occurrences of the pattern in string by the\n	    replacement repl.  repl can be either a string or a callable;\n	    if a string, backslash escapes in it are processed.  If it is\n	    a callable, it\'s passed the match object and must return\n	    a replacement string to be used.\"\"\"\n	    return _compile(pattern, flags).sub(repl, string, count)\n```\n从上面的代码中可以看到re.sub()方法中含有5个参数，下面进行一一说明（加粗的为必须参数）：\n（1）**pattern**：该参数表示正则中的模式字符串；\n（2）**repl**：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数；\n（3）**string**：该参数表示要被处理（查找替换）的原始字符串；\n（4）count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换；\n（5）flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。\n参考：[https://blog.csdn.net/jackandsnow/article/details/103885422](https://blog.csdn.net/jackandsnow/article/details/103885422)\n`sub`函数的案例，获取拉勾网中的数据：\n```python\nhtml = \"\"\"\n<div>\n<p>基本要求：</p>\n<p>1、精通HTML5、CSS3、 JavaScript等Web前端开发技术，对html5页面适配充分了解，熟悉不同浏览器间的差异，熟练写出兼容各种浏览器的代码；</p>\n<p>2、熟悉运用常见JS开发框架，如JQuery、vue、angular，能快速高效实现各种交互效果；</p>\n<p>3、熟悉编写能够自动适应HTML5界面，能让网页格式自动适应各款各大小的手机；</p>\n<p>4、利用HTML5相关技术开发移动平台、PC终端的前端页面，实现HTML5模板化；</p>\n<p>5、熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；6、良好的沟通能力和团队协作精神，对移动互联网行业有浓厚兴趣，有较强的研究能力和学习能力；</p>\n<p>7、能够承担公司前端培训工作，对公司各业务线的前端（HTML5\\CSS3）工作进行支撑和指导。</p>\n<p><br></p>\n<p>岗位职责：</p>\n<p>1、利用html5及相关技术开发移动平台、微信、APP等前端页面，各类交互的实现；</p>\n<p>2、持续的优化前端体验和页面响应速度，并保证兼容性和执行效率；</p>\n<p>3、根据产品需求，分析并给出最优的页面前端结构解决方案；</p>\n<p>4、协助后台及客户端开发人员完成功能开发和调试；</p>\n<p>5、移动端主流浏览器的适配、移动端界面自适应研发。</p>\n</div>\n\"\"\"\nret = re.sub(\'</?[a-zA-Z0-9]+>\',\"\",html)\nprint(ret)\n```\n#### split：\n使用正则表达式来分割字符串。\n```python\ntext = \"hello world ni hao\"\nret = re.split(\'\\W\',text)\nprint(ret)\n>> [\"hello\",\"world\",\"ni\",\"hao\"]\n```\n#### compile：\n对于一些经常要用到的正则表达式，可以使用`compile`进行编译，后期再使用的时候可以直接拿过来用，执行效率会更快。而且`compile`还可以指定`flag=re.VERBOSE`，在写正则表达式的时候可以做好注释。示例代码如下：\n```python\ntext = \"the number is 20.50\"\nr = re.compile(r\"\"\"\n                \\d+ # 小数点前面的数字\n                \\.? # 小数点\n                \\d* # 小数点后面的数字\n                \"\"\",re.VERBOSE)\nret = re.search(r,text)\nprint(ret.group())\n```\n','原创','','','','','',2,1455457901559312386,1,0,0,'2022-01-07 21:56:02','2022-01-08 17:34:14'),(1479453248040501250,'【Vue】VueJs项目总结','最火的前端框架Vue，再做项目时VueCli是十分好用的，本篇文章总结Vue项目的常用知识点','https://ae04.alicdn.com/kf/Hcfb05afecc454ab8846d2c775ff9e542V.png','## Vue-cli脚手架\n### 查看Vue版本和vue-cli版本\n1、直接到项目package.json中查看\n![image.png](https://ae04.alicdn.com/kf/Hf7bc67ada907472e9e8bf89d73abd224U.png)\n2、通过命令查看\n```shell\n#查看脚手架版本\n>>>vue --version\n@vue/cli 4.5.12\n\n#查看Vue版本（cmd命令行进入项目中）\n>>>npm list vue\nmy-music-admin@0.1.0 D:\\CodeLearning\\JavaLearning\\JavaProjects\\JavaWeb\\springboot\\my-music-springboot-vue\\my-music-admin\n+-- @vue/cli-plugin-babel@4.5.13\n| `-- @vue/babel-preset-app@4.5.13\n|   `-- vue@2.6.14 deduped\n+-- element-ui@2.15.5\n| `-- vue@2.6.14 deduped\n+-- vbest-ui@0.2.9\n| `-- vue@2.6.14 deduped\n+-- vue-aplayer@1.6.1\n| `-- vue@2.6.14 deduped\n+-- vue-particles@1.0.9\n| `-- vue@2.6.14 deduped\n+-- vue@2.6.14\n`-- vuex@3.6.2\n  `-- vue@2.6.14 deduped\n\n```\n### package.json\n```json\n{\n  \"name\": \"neteasecloud_music\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\"\n  },\n  \"dependencies\": {\n    \"animate.css\": \"^4.1.1\",			//css动画\n    \"axios\": \"^0.21.1\",			\n    \"better-scroll\": \"^2.4.1\",\n    \"core-js\": \"^3.6.5\",\n    \"element-ui\": \"^2.15.3\",\n    \"less-loader\": \"^6.0.0\",			//less样式\n    \"vbest-ui\": \"^0.2.9\",\n    \"vue\": \"^2.6.11\",\n    \"vue-router\": \"^3.5.2\",\n    \"vuex\": \"^3.6.2\"\n  },\n  \"devDependencies\": {\n    \"@vue/cli-plugin-babel\": \"~4.5.0\",\n    \"@vue/cli-plugin-eslint\": \"~4.5.0\",\n    \"@vue/cli-service\": \"~4.5.0\",\n    \"babel-eslint\": \"^10.1.0\",\n    \"eslint\": \"^6.7.2\",\n    \"eslint-plugin-vue\": \"^6.2.2\",\n    \"less\": \"^4.1.1\",\n    \"postcss-pxtorem\": \"^6.0.0\",\n    \"vue-lazyload\": \"^1.3.3\",\n    \"vue-template-compiler\": \"^2.6.11\"\n  },\n  \"eslintConfig\": {\n    \"root\": true,\n    \"env\": {\n      \"node\": true\n    },\n    \"extends\": [\n      \"plugin:vue/essential\",\n      \"eslint:recommended\"\n    ],\n    \"parserOptions\": {\n      \"parser\": \"babel-eslint\"\n    },\n    \"rules\": {}\n  },\n  \"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\",\n    \"not dead\"\n  ]\n}\n```\n### 理解devDependencies和dependencies\n\n- devDependencies    用于本地环境开发时\n- dependencies    用户发布环境\n\ndevDependencies是只会在开发环境下依赖的模块，生产环境不会被打入包内。\n通过NODE_ENV=developement或NODE_ENV=production指定开发还是生产环境。\n而dependencies依赖的包不仅开发环境能使用，生产环境也能使用。\nnpm install xxx --save \n安装的xxx库会放在dependencies中，开发和生产环境都会用到，比如axios包\nnpm install xxx --save-dev\n只是开发环境中用到，比如 eslint包（代码书写规范）\n### 安装&使用第三方库\n#### 1、element-ui\n[https://element.eleme.io/#/zh-CN/component/quickstart](https://element.eleme.io/#/zh-CN/component/quickstart)\n```shell\nnpm i element-ui -S\n\n#完整写法\nnpm install element-ui --save\n\n\n#完整引入（main.js）\nimport Vue from \'vue\';\nimport App from \'./App.vue\';\n\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';\nVue.use(ElementUI);\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n});\n```\n#### 2、axios\n[http://www.axios-js.com/zh-cn/docs/#%E5%AE%89%E8%A3%85](http://www.axios-js.com/zh-cn/docs/#%E5%AE%89%E8%A3%85)\n```shell\nnpm install axios\n\n#在js文件中引入使用\nimport axios from \'axios\'\n\n// 发送 POST 请求\naxios({\n  method: \'post\',\n  url: \'/user/12345\',\n  data: {\n    firstName: \'Fred\',\n    lastName: \'Flintstone\'\n  }\n});\n```\n#### 3、vbest-ui\n[https://fudaosheng.gitee.io/vbest-ui/components/](https://fudaosheng.gitee.io/vbest-ui/components/)\n```shell\nnpm install vbest-ui --save\n\n#main.js中全局注册\nimport VbestUi from \'vbest-ui\'\nimport \'vbest-ui/dist/vbest-ui.css\'\nVue.use(VbestUi)\n```\n#### 4、less\n**注意：**Vue2.6.x版本要使用低版本的less  less-loader，less版本高会报错\n[https://www.cnblogs.com/qdwds/p/11516181.html](https://www.cnblogs.com/qdwds/p/11516181.html)\n```shell\nnpm install less-loader@6.0.0 --save\n\nnpm install less@4.1.1 --save-dev\n\n#main.js中全局注册\nimport less from \'less\'\nVue.use(less);\n```\n#### 5、animate.css\n[https://animate.style/#usage](https://animate.style/#usage)\n​\n\n```shell\nnpm install animate.css --save\n\n#main.js中全局注册\nimport animated from \'animate.css\'\nVue.use(animated)\n```\n#### 6、qs\n```shell\nnpm install qs --save\n\n#在组件中引入使用\nimport qs from \'qs\'\nVue.prototype.$qs = qs;\n\n#qs.parse()是将URL解析成对象的形式\n#qs.stringify()是将对象 序列化成URL的形式，以&进行拼接\n\nlet data = this.$qs.stringify({\n    \"username\":this.username,\n    \"password\":this.password\n});\n## username=renping&password=123456\n```\n**qs.stringify、qs.parse、JSON.stringify的使用和区别？**\n**qs**可通过**npm install qs**命令进行安装\n**qs.stringify()**将**对象 序列化成URL的形式，以&进行拼接**：\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1640785304926-65a8060b-6953-4ff9-907b-911edbc94ebe.png)\n**qs.parse()将URL解析成对象的形式：**\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1640785342013-e5070eef-a183-4200-8ac4-b4146f137406.png)\n**JSON.stringify**同**qs.stringify()**对比，功能虽然是都是序列化，但是具体看用途。\nqs.parse和qs.stringify是用来处理url的，JSON.parse和JSON.stringify是处理json对象的，虽然有些场景下类似，但是用途不一样。\n**注意：**qs.stringify(url) 序列化对象时默认会进行编码\n可以设置不编码  encode:false    \n```javascript\n//1、可以设置不编码encode:false    \n\nlet obj={ a:[\'b\',\'c\',\'d\'] }\nconsole.log(qs.stringify(obj, {encode:false}))；//结果为 a[0]=b&a[1]=c&a[2]=d\n\n//2、对数组进行串化的时候，默认会提供显示索引，可以通过设置indices:false\n\nlet obj={a:[\'b\',\'c\',\'d\']};qs.stringify(obj,{indices:false});//结果为：\'a=b&a=c&a=d\'\n\n//3、可以通过设置arrayFormat指定数组的输出格式\n\nlet obj={{a ：[\' b \'，\' c \']};\n\nqs.stringify(obj,{arrayFormat:\'indices\'});//结果为：\'a[0]=b&a[1]=c\'\nqs.stringify(obj,{arrayFormat:\'brackets\'});//结果为：\'a[]=b&a[]=c\'\nqs.stringify(obj,{arrayFormat:\'comma\'});//结果为：\'a=b,c\'\n\n//4、属性为undefined的将直接被忽略\n\nlet obj={a :null ,b:undefined};qs.stringify(obj);//结果为：\'a=\'\n\n//5、分隔符也可以自定义，设置delimiter:\"自定义的符号\"\n\nlet obj={a:\'b\',c:\'d\'};\nqs.stringify(obj,{delimiter:\'!\'});	//结果为：\'a=b!c=d\'\n\n```\n#### 7、moment\nmoment.js是一款JavaScript 日期处理类库  [http://momentjs.cn/](http://momentjs.cn/)\n```shell\nnpm install moment --save\n\n#在main.js文件里引用moment\nimport Moment from \'moment\'\n\n#1、定义全局时间戳过滤器\nVue.filter(\'formatDate\', function(value) {\n  return Moment(value).format(\'YYYY-MM-DD HH:mm:ss\')\n})\n\n#2、或者挂载到Vue全局对象上，在组件中使用\nVue.prototype.$moment = Moment;\n\n#在组件中使用\nthis.$moment().format(\"YYYY-MM-DD 00:00:00\")\n```\n#### 8、vue-aplayer\n[https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md](https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md)\n```shell\nnpm install vue-aplayer --save\n\n#在组件中使用\nimport VueAplayer from \'vue-aplayer\'\n\n<aplayer autoplay :music=\"musicInfo\"/>\n\ndata(){\n	return{\n  	musicInfo:{\n      title: \'secret base~君がくれたもの~\',\n      artist: \'Silent Siren\',\n      src: \'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.mp3\',\n      pic: \'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg\'\n  	}	\n  }\n}\n```\n#### 9、vue-lazyload\n图片加载中展示loading.gif，加载失败展示404.jpg\n不过，我们使用element-ui可以用<el-image>替代\n```shell\nnpm install vue-lazyload --save\n\nimport VueLazyLoad from \'vue-lazyload\'\nVue.use(VueLazyLoad, {\n    preLoad: 1.3,\n    error: require(\'@/assets/images/404.jpg\'),\n    loading: require(\'@/assets/images/loading.gif\'),\n    attempt: 3\n});\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1637761221222-ddabb3d3-9d71-4c7e-a9eb-9d6f6affc9b8.png)\n#### 10、vue-echarts\n[https://github.com/ecomfe/vue-echarts](https://github.com/ecomfe/vue-echarts)\n[https://gitee.com/mirrors/vue-echarts](https://gitee.com/mirrors/vue-echarts)\n```shell\nnpm install echarts vue-echarts --save\n\n#To make vue-echarts work for Vue 2, you need to have @vue/composition-api installed:\n\nnpm install @vue/composition-api --save-dev\n```\n注册：\n```javascript\nimport Vue from \'vue\'\nimport ECharts from \'vue-echarts\'\nimport { use } from \'echarts/core\'\n\n// import ECharts modules manually to reduce bundle size\nimport {\n  CanvasRenderer\n} from \'echarts/renderers\'\nimport {\n  BarChart\n} from \'echarts/charts\'\nimport {\n  GridComponent,\n  TooltipComponent\n} from \'echarts/components\'\n\nuse([\n  CanvasRenderer,\n  BarChart,\n  GridComponent,\n  TooltipComponent\n]);\n\n// register globally (or you can do it locally)\nVue.component(\'v-chart\', ECharts)\n\nnew Vue(...)\n```\n简单demo\n```vue\n<template>\n	<v-chart class=\"chart\" :option=\"option\" />\n</template>\n\n<script>\n  import { use } from \"echarts/core\";\n  import { CanvasRenderer } from \"echarts/renderers\";\n  import { PieChart } from \"echarts/charts\";\n  import {\n    TitleComponent,\n    TooltipComponent,\n    LegendComponent\n  } from \"echarts/components\";\n  import VChart, { THEME_KEY } from \"vue-echarts\";\n\n  use([\n    CanvasRenderer,\n    PieChart,\n    TitleComponent,\n    TooltipComponent,\n    LegendComponent\n  ]);\n\n  export default {\n    name: \"HelloWorld\",\n    components: {\n      VChart\n    },\n    provide: {\n      [THEME_KEY]: \"dark\"\n    },\n    data() {\n      return {\n        option: {\n          title: {\n            text: \"Traffic Sources\",\n            left: \"center\"\n          },\n          tooltip: {\n            trigger: \"item\",\n            formatter: \"{a} <br/>{b} : {c} ({d}%)\"\n          },\n          legend: {\n            orient: \"vertical\",\n            left: \"left\",\n            data: [\n              \"Direct\",\n              \"Email\",\n              \"Ad Networks\",\n              \"Video Ads\",\n              \"Search Engines\"\n            ]\n          },\n          series: [\n            {\n              name: \"Traffic Sources\",\n              type: \"pie\",\n              radius: \"55%\",\n              center: [\"50%\", \"60%\"],\n              data: [\n                { value: 335, name: \"Direct\" },\n                { value: 310, name: \"Email\" },\n                { value: 234, name: \"Ad Networks\" },\n                { value: 135, name: \"Video Ads\" },\n                { value: 1548, name: \"Search Engines\" }\n              ],\n              emphasis: {\n                itemStyle: {\n                  shadowBlur: 10,\n                  shadowOffsetX: 0,\n                  shadowColor: \"rgba(0, 0, 0, 0.5)\"\n                }\n              }\n            }\n          ]\n        }\n      };\n    }\n  };\n</script>\n\n<style scoped>\n  .chart {\n    height: 400px;\n  }\n</style>\n```\n#### 11、hover.css\n官网：[https://ianlunn.github.io/Hover/](https://ianlunn.github.io/Hover/)\n[https://github.com/IanLunn/Hover#downloadinstall](https://github.com/IanLunn/Hover#downloadinstall)\n**比如要做这种效果：**\n![aHR0cHM6Ly9hZGdlci1wcm9qZWN0Lm9zcy1jbi1oYW5nemhvdS5hbGl5dW5jcy5jb20vMTIuZ2lm.gif](https://cdn.nlark.com/yuque/0/2021/gif/1559629/1638970530226-ea934e42-e4b1-47a5-aaf7-ecb9c65e4a8a.gif)\n![aHR0cHM6Ly9hZGdlci1wcm9qZWN0Lm9zcy1jbi1oYW5nemhvdS5hbGl5dW5jcy5jb20vMTMuZ2lm.gif](https://cdn.nlark.com/yuque/0/2021/gif/1559629/1638970644368-689634f3-0436-4300-898a-d05792d663e1.gif)\n**安装&使用：**\n```shell\n#vue-cli安装\nnpm install hover.css --save\n\n#link引入\n<link href=\"css/hover-min.css\" rel=\"stylesheet\">\n\n#在main.js中使用\nimport hover from \"hover.css\"\nVue.use(hover);\n\n#具体使用  直接在class加上属性hvr-pulse-shrink即可\n<div @click=\"collectSong(scope.row)\" class=\"my-marginLeft10 hvr-pulse-shrink\"></div>\n```\n**可以在官网打开控制台直接调试**\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1638970657925-ab6fbbee-ebeb-4ad6-8c97-eec2cdf6425a.png)\n### 配置vue.config.js\n```javascript\nmodule.exports = {\n    /*configureWebpack: {\n        resolve: {\n            alias: {\n                \'assets\': \'@/assets\',\n                \'common\': \'@/common\',\n                \'components\': \'@/components\',\n                \'network\': \'@/network\',\n                \'views\': \'@/views\',\n            }\n        }\n    },*/\n    devServer: {\n        port: 8001,\n      	host:\"localhost\",\n        open: true,		//自动打开浏览器\n        proxy: {\n            \'/api\': {\n                target: \'http://localhost:8000/\',\n                changeOrigin: true,     // 允许跨域\n                ws: true,\n                pathRewrite: {\n                    \'^/api\': \'\'\n                }\n            }\n        }\n    }\n};\n\n```\n### request.js请求\n```javascript\nimport axios from \'axios\'\n\nconst request = (config) => {\n    const instance = axios.create({\n        baseURL: \'/api\',\n        timeout: 8000,\n        withCredentials:true,       //可以跨域\n    });\n		//配置请求头携带token\n    instance.interceptors.request.use(config => {\n        let token = window.localStorage.getItem(\'token\');\n        if(!(token == \"\" || token == null)){\n            config.headers.common[\'token\'] = token;\n        }\n\n        return config\n    }, err => {\n        return err\n    });\n\n    instance.interceptors.response.use(response => {\n        return response.data\n    }, err => {\n        if (err && err.response) {\n            switch (err.response.status) {\n                case 400:\n                    err.message = \'请求错误\';\n                    break;\n                case 401:\n                    err.message = \'未授权的访问\';\n                    break\n            }\n        }\n        return err\n    });\n\n    return instance(config);\n};\n\nexport default request;\n\n\nexport const $postKeyValueRequest=(url,params)=>{\n    return request({\n        method: \'post\',\n        url: `${base}${url}`,       //特别注意这里是``引用变量的方式,而不是\'\'\n        data: params,       //直接这样以json的形式传给服务器，这是不支持的,所有还需要定义下面的transformRequest\n        transformRequest: [function (data){\n            let ret = \'\';\n            for(let i in data){\n                //往ret上面追加变量\n                ret+=encodeURIComponent(i) + \'=\' + encodeURIComponent(data[i]) + \'&\'\n            }\n            // console.log(ret);\n            return ret;\n        }],\n        //定义header\n        headers:{\n            \'Content-Type\':\'application/x-www-form-urlencoded \'\n        }\n    })\n\n};\n\nexport const $getRequest=(url, params)=>{\n    return request({\n        method: \'get\',\n        url: `${base}${url}`,\n        data: params\n    })\n};\n\nexport const $postRequest=(url, params)=>{\n    return request({\n        method: \'post\',\n        url: `${base}${url}`,\n        data: params\n    })\n};\n\nexport const $putRequest=(url, params)=>{\n    return request({\n        method: \'put\',\n        url: `${base}${url}`,\n        data: params\n    })\n};\n\nexport const $deleteRequest=(url, params)=>{\n    return request({\n        method: \'delete\',\n        url: `${base}${url}`,\n        data: params\n    })\n};\n```\n也可以把$getRequest  $postRequest 挂载带Vue全局作用域上，可以在所有组件中使用\nmain.js\n```javascript\nimport {$getRequest,$postRequest} from \"@/network/request.js\"\nVue.prototype.$getRequest = $getRequest;\nVue.prototype.$postRequest = $postRequest;\n```\n### 混入(mixin)与全局混入\n[https://www.cnblogs.com/wangyihong/p/11540092.html](https://www.cnblogs.com/wangyihong/p/11540092.html)\n','原创','','','','','',6,1479452807638581249,1,0,0,'2022-01-07 22:01:55','2022-01-08 17:33:08'),(1479743679928328193,'【Java】Shiro安全框架之JWT','重点掌握认证和授权','https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liqingbo.cn%2Fdocs%2Fjwt%2Fimages%2F201911290927461000.jpg','\n[https://www.jianshu.com/p/e88d3f8151db](https://www.jianshu.com/p/e88d3f8151db)\n## 一、概述\n### 什么是JWT？\nJSON Web Token(JWT)是⼀个开放标准(RFC?7519)，它定义了⼀种紧凑的、⾃包含的⽅式，⽤于作为JSON对象在各⽅之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n### 什么时候应该⽤JWT？\n**Authorization?(授权)：**\n这是使⽤JWT的最常⻅场景。⼀旦⽤⼾登录，后续每个请求都将包含JWT，允许⽤⼾访问该令牌允许的路由、服务和资源。单点登录是现在⼴泛使⽤的JWT的⼀个特性，因为它的开销很⼩，并且可以轻松地跨域使⽤。\n**​**\n\n**Information?Exchange?(信息交换)：**\n对于安全的在各⽅之间传输信息⽽⾔，JSON?Web?Tokens⽆疑是⼀种很好的⽅式。因为JWT可以被签名，例如，⽤公钥/私钥对，你可以确定发送⼈就是它们所说的那个⼈。另外，由于签名是使⽤头和有效负载计算的，您还可以验证内容没有被篡改。\n### 认证流程\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629558620459-6b5b7f1e-a543-4006-bbcd-043c7cf8fdf4.png)\n\n- ⾸先，前端通过Web表单将⾃⼰的⽤⼾名和密码发送到后端的接⼝。这⼀过程⼀般是⼀个HTTP POST请求。建议的⽅式是通过SSL加密的传输(https协议)?，从⽽避免敏感信息被嗅探。\n\n\n\n- 后端核对⽤⼾名和密码成功后，将⽤⼾的id等其他信息作为JWT?Payload?(负载)，将其与头部分别进⾏Base64编码拼接后签名，形成⼀个JWT(Token)。形成的JWT就是⼀个形同 xxx.yyy.zzz 的字符串。token:head.payload.signature\n\n\n\n- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。\n\n\n\n- 前端在每次请求时将JWT放⼊HTTP?Header中的Authorization位。(解决XSS和XSRF问题)\n\n\n\n- 后端检查是否存在，如存在验证JWT的有效性\n\n\n\n   - 检查签名是否正确；\n   - 检查Token是否过期；\n   - 检查Token的接收⽅是否是⾃⼰(可选)；\n- 验证通过后后端使⽤JWT中包含的⽤⼾信息进⾏其他逻辑操作，返回相应结果\n### JWT优势在哪?\n\n- 简洁(Compact):?可以通过URL，POST参数或者在HTTP header发送，数据量⼩，传输速度快\n- ⾃包含(Self-contained):负载中包含了所有⽤⼾所需要的信息，避免了多次查询数据库\n- 因为Token是以JSON加密的形式保存在客⼾端的，所以JWT是跨语⾔的，原则上任何web形式都⽀持\n- 不需要在服务端保存会话信息，特别适⽤于分布式微服务\n### JWT具体包含信息\n#### header\n标头通常由两部分组成：令牌的类型(即JWT) 和所使⽤的签名算法，例如HMAC、SHA256或RSA。\n它会使⽤Base64编码组成JWT结构的第⼀部分\n注意：Base64是⼀种编码方式，它是可以被翻译回原来的样⼦来的。它并不是⼀种加密过程\n未使用Base64编码前的样式：\n```java\n{\n    \"alg\":\"HS256\",\n    \"typ\":\"JWT\"\n}\n```\n#### Payload\n令牌的第⼆部分是有效负载，其中包含声明。声明是有关实体(通常是⽤⼾)和其他数据的声明。同样\n的，它会使⽤Base64?编码组成JWT结构的第⼆部分\n```json\n{\n  \"sub\" : \"HS256\"\n  \"name\" : \"yjiewei\"\n  \"admin\" : \"true\"\n}\n```\n#### Signature\nheader和payload都是结果Base64编码过的，中间⽤.隔开，第三部分就是前⾯两部分合起来做签名，密钥绝对⾃⼰保管好，签名值同样做Base64编码拼接在JWT后⾯。（签名并编码）\n```java\nHMACSHA256 (base64Ur1Encode(header) + \".\" + base64Ur1Encode(payload) , secret);\n```\n## 二、SpringBoot整合JWT\n### 2.1 引入maven依赖\n```xml\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.2.5.RELEASE</version>\n  <relativePath/> <!-- lookup parent from repository -->\n</parent>\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n  </dependency>\n\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n    <version>8.0.25</version>\n  </dependency>\n  <dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.2</version>\n  </dependency>\n\n  <dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>java-jwt</artifactId>\n    <version>3.18.1</version>\n  </dependency>\n</dependencies>\n```\n### 2.2 封装工具类\n#### 2.2.1 封装JWT工具类JWTUtils\n```java\npublic class JWTUtils {\n    private static String  SECRET  = \"xiong@#$%123456\";		//一定要保密\n\n    public static String getToken(Map<String,Object> map){\n        JWTCreator.Builder builder = JWT.create();\n\n        //payload\n        map.forEach((k,v)->{\n            builder.withClaim(k, (String) v);\n        });\n\n        Calendar instance = Calendar.getInstance();\n        instance.add(Calendar.DATE,7);       //过期时间\n\n        builder.withExpiresAt(instance.getTime());\n        String token = builder.sign(Algorithm.HMAC256(SECRET));\n\n        return token;\n    }\n\n    /*验证token*/\n    public static DecodedJWT verify(String token){\n        Verification require = JWT.require(Algorithm.HMAC256(SECRET));\n        DecodedJWT verify = require.build().verify(token);      //没有报错就是验证成功\n        return verify;\n    }\n}\n```\n#### 2.2.2 封装RespBean返回对象\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class RespBean {\n    private Integer status;\n    private String msg;\n    private Object result;\n\n\n    public static RespBean build(){\n        return new RespBean();\n    }\n\n    public static RespBean ok(String msg){\n        return new RespBean(200,msg,null);\n    }\n\n    public static RespBean ok(String msg, Object obj){\n        return new RespBean(200,msg,obj);\n    }\n\n    public static RespBean error(String msg){\n        return new RespBean(500,msg,null);\n    }\n\n    public static RespBean error(String msg, Object obj){\n        return new RespBean(500,msg,obj);\n    }\n}\n```\n### 2.3 Controller层\n```java\n@Slf4j\n@RestController\npublic class UserController {\n    @Autowired\n    private TUserService tUserService;\n\n    //需要表单post传入username password\n    @PostMapping(\"/user/login\")\n    public RespBean toLogin(TUser tUser){\n        RespBean build = RespBean.build();\n        System.out.println(tUser);      //自动将传入的username password 封装成TUser\n\n        try {\n            //根据TUser 从数据库中查找\n            TUser tUserDB = tUserService.queryByUsernamePassword(tUser);\n            log.info(\"查找到用户[{}]\",tUserDB);\n            HashMap<String, Object> payload = new HashMap<>();\n            payload.put(\"uid\",tUserDB.getId().toString());\n            payload.put(\"username\",tUserDB.getUsername());\n            String token = JWTUtils.getToken(payload);\n\n            build.setStatus(200);\n            build.setMsg(token);\n        }catch (Exception e){\n            build.setStatus(500);\n            build.setResult(e.getMessage());\n        }\n\n        return build;\n    }\n\n    //测试-没有将token放到请求头中\n    @GetMapping(\"/test\")\n    public RespBean test(String token){\n        RespBean build = RespBean.build();\n\n        DecodedJWT verify = JWTUtils.verify(token);\n        String username = verify.getClaim(\"username\").asString();\n        String uid = verify.getClaim(\"uid\").asString();\n        log.warn(\"用户username={}\",username);\n        log.warn(\"用户id={}\",uid);\n\n        return build;\n    }\n\n    @GetMapping(\"/admin\")\n    public RespBean testAdmin(HttpServletRequest request){\n        RespBean build = RespBean.build();\n\n        String token = request.getHeader(\"token\");\n        //获取验证后解码的的token对象\n        DecodedJWT verify = JWTUtils.verify(token);\n        String un = verify.getClaim(\"username\").asString();\n        String uid = verify.getClaim(\"uid\").asString();\n        log.warn(\"用户username={}\",un);\n        log.warn(\"用户id={}\",uid);\n\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"username\",un);\n        map.put(\"uid\",uid);\n\n        build.setStatus(200);\n        build.setResult(map);\n\n        return build;\n    }\n}\n```\n### 2.4 Service层\n```java\n@Service\npublic class TUserServiceImpl implements TUserService {\n    @Autowired\n    private TUserMapper tUserMapper;\n\n\n    @Override\n    public TUser queryByUsernamePassword(TUser tUser) {\n        return tUserMapper.queryTUserByUsernamePassword(tUser);\n    }\n}\n```\n### 2.5 Mapper层\n```java\n<mapper namespace=\"com.xjt.mapper.TUserMapper\">\n    <select id=\"queryTUserByUsernamePassword\" resultType=\"com.xjt.entity.TUser\">\n        select  * from t_user where username=#{username} and password=#{password}\n    </select>\n</mapper>\n```\n### 2.6 拦截器\n#### 2.6.1 自定义JWTInterceptor拦截器\n自定义JWTInterceptor拦截器要实现HandlerInterceptor接口，可以重写3个方法，一般重写 preHandle比较多，返回true时继续执行\n```java\npublic class JWTInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        RespBean build = RespBean.build();\n\n        String token = request.getHeader(\"token\");\n        try{\n            JWTUtils.verify(token);\n            return true;\n        }catch (SignatureVerificationException e){\n            e.printStackTrace();\n            build.setMsg(\"无效签名\");\n        }catch (AlgorithmMismatchException e){\n            e.printStackTrace();\n            build.setMsg(\"token算法不匹配\");\n        }catch (TokenExpiredException e){\n            e.printStackTrace();\n            build.setMsg(\"token过期了\");\n        }catch (Exception e){\n            e.printStackTrace();\n            build.setMsg(e.getMessage());\n        }\n        build.setStatus(500);\n        String json = new ObjectMapper().writeValueAsString(build);\n        response.setContentType(\"application/json;charset=utf-8\");\n        response.getWriter().println(json);\n\n        return false;\n    }\n}\n```\n#### 2.6.2 配置拦截器\n```java\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new JWTInterceptor())\n                .addPathPatterns(\"/**\")     //所有请求都要token验证\n                .excludePathPatterns(\"/user/**\");       //以 /user 开头的访问放行\n    }\n}\n```\n**补充：拦截器知识**\n参考：[https://blog.csdn.net/levae1024/article/details/83512292](https://blog.csdn.net/levae1024/article/details/83512292)\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629814282955-ce7233d7-905f-40ef-b0c1-cfc973498d20.png)\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629814630046-e8cd3bab-1ac9-4a9d-886d-b8b38a16bf4a.png)\n两个拦截器时：\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629814680909-eb4187e2-98c7-4511-b245-9588fc46e1c0.png)\n在Springboot中 config/InterceptorConfig.java中配置多个拦截器：\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629815063042-a7bd088b-fb19-46b5-ab1c-eea46d30a3c2.png)\n### 2.7 测试\n#### 访问/user/login\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629815440347-5523a3b7-1783-4158-a157-49a31e1f995c.png)\n#### 访问/admin\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1629815320000-6b063ae2-3128-4b99-a022-484cd652e733.png)\n','原创','','','','','',0,1455457539423105025,NULL,0,0,'2022-01-08 17:16:00','2022-01-08 17:16:00'),(1479744913028538370,'【Java】Mybatis-Plus最好用的框架---操作数据库','MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！','https://ae01.alicdn.com/kf/Hb5bbf55d371c4ee3a1c337c4858693a0e.png','## 一、介绍\n> MyBatisPlus概述需要的基础：MyBatis、Spring、SpringMVC、SpringBoot\n> 为什么要学习它呢？MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！\n\nMyBatis 本来就是简化 JDBC 操作的！官网：[https://mp.baomidou.com/](https://mp.baomidou.com/) \n![image.png](https://ae01.alicdn.com/kf/Hb5bbf55d371c4ee3a1c337c4858693a0e.png)\n参考：[https://mp.weixin.qq.com/s/fnoRa3zNcTp_3wFC3UENXw](https://mp.weixin.qq.com/s/fnoRa3zNcTp_3wFC3UENXw)\n### 特性\n[https://mp.baomidou.com/guide/#%E7%89%B9%E6%80%A7](https://mp.baomidou.com/guide/#%E7%89%B9%E6%80%A7)\n> **无侵入**：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n> **损耗小**：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper\n> **强大的 CRUD 操作**：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更**有强大的条件构造器**，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！\n> **支持 Lambda 形式调用**：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\n> **支持主键自动生成**：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题\n> **支持 ActiveRecord 模式**：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\n> 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）\n> **内置代码生成器**：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支	  持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码）\n> **内置分页插件**：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询\n> **分页插件支持多种数据库**：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库\n> **内置性能分析插件**：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n> **内置全局拦截插件**：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n### 快速入门\n地址：[https://mp.baomidou.com/guide/quick-start.html#](https://mp.baomidou.com/guide/quick-start.html#)初始化工程\n> 使用第三方组件的一般学习过程：\n> 1、导入对应的依赖\n> 2、研究依赖如何配置\n> 3、代码如何编写\n> 4、提高扩展技术能力！\n\n1、创建数据库mybatis_plus\n2、创建user表\n```sql\nDROP TABLE IF EXISTS user;\nCREATE TABLE user\n(\n    id BIGINT(20) NOT NULL COMMENT \'主键ID\',\n    name VARCHAR(30) NULL DEFAULT NULL COMMENT \'姓名\',\n    age INT(11) NULL DEFAULT NULL COMMENT \'年龄\',\n    email VARCHAR(50) NULL DEFAULT NULL COMMENT \'邮箱\',\n    PRIMARY KEY (id)\n);\nINSERT INTO user (id, name, age, email) VALUES\n(1, \'Jone\', 18, \'test1@baomidou.com\'),\n(2, \'Jack\', 20, \'test2@baomidou.com\'),\n(3, \'Tom\', 28, \'test3@baomidou.com\'),\n(4, \'Sandy\', 21, \'test4@baomidou.com\'),\n(5, \'Billie\', 24, \'test5@baomidou.com\');\n-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified\n```\n3、编写springboot项目，初始化项目！使用SpringBoot选择web初始化！\n4、导入依赖\n\n\n```xml\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n  <version>5.1.32</version>\n</dependency>\n<!-- lombok -->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n\n<!-- mybatis-plus 是自己开发，并非官方的！ -->\n<!--注意：mybatis和mybatis-plus不能一起导入-->\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-boot-starter</artifactId>\n  <version>3.2.0</version>\n</dependency>\n<!--mybatis-plus 代码生成器依赖-->\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-generator</artifactId>\n  <version>3.2.0</version>\n</dependency>\n<dependency>\n  <groupId>org.apache.velocity</groupId>\n  <artifactId>velocity-engine-core</artifactId>\n  <version>2.3</version>\n</dependency>\n```\n说明：\n我们使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus！版本的差异！\n5、连接数据库！这一步和 mybatis 相同！\n```shell\n# mysql 5  驱动不同 com.mysql.jdbc.Driver\n\n# mysql 8  驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置  \nserverTimezone=GMT%2B8\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n6、传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller\n7、使用了mybatis-plus 之后\nUserMapper.java\n```java\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.xjt.domain.User;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface UserMapper extends BaseMapper<User> {\n}\n```\nUser.java\n```java\n@Data\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\nMybatisPlusApplicationTests.java\n```java\n@SpringBootTest\nclass MybatisPlusApplicationTests {\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void testSelect() {\n        // 参数是一个 Wrapper ，条件构造器，这里我们先不用条件 查询全部用户\n        List<User> userList = userMapper.selectList(null);\n        userList.forEach(System.out::println);\n    }\n\n    @Test\n    public void testSelectById() {\n        //查询id=1的用户\n        User user = userMapper.selectById(1L);\n        System.out.println(user);\n    }\n\n    @Test\n    public void testSelectBatchIds() {\n        //查询id=1,2,3的用户\n        List<User> users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));\n        users.forEach(System.out::println);\n    }\n\n}\n```\n注意：我们需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(\"com.xjt.mapper\")\n思考问题？\n1、SQL谁帮我们写的 ? MyBatis-Plus 都写好了\n2、方法哪里来的？ MyBatis-Plus 都写好了\n![image.png](https://ae05.alicdn.com/kf/Hfae5a1953a914534899feade38b0e2e15.png)\n## 二、核心功能\n### 1、配置日志\n我们所有的sql查询现在是不可见的，我们希望知道看到它是怎么执行的，所以我们必须要看日志！\n```shell\n# 配置日志\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n```\n配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上 MyBatis-Plus！\n![](https://ae01.alicdn.com/kf/H6d388c2eb2ed4942bb05d2a22b90f713U.png)\n### 2、主键生成策略\n![image.png](https://ae04.alicdn.com/kf/Hd9298f15f43340b085670447cf6fedb3Y.png\n)\n数据库插入的id的默认值为：全局的唯一id\n默认 ID_WORKER     全局唯一id\n分布式系统唯一id生成方案：[https://www.cnblogs.com/haoxinyue/p/5208136.html](https://www.cnblogs.com/haoxinyue/p/5208136.html)\n**雪花算法：**\n> snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！\n\n**主键自增需要的配置：**\n1、实体类字段上 @TableId(type = IdType.AUTO)\n2、数据库字段一定要是自增\n![](https://ae05.alicdn.com/kf/H92f07cf330d047ea83fc6b47edda0c8cx.png)\nIdType是一个枚举 有如下类型：（一般使用雪花算法 ID_WORKER）\n```java\npublic enum IdType {\n    AUTO(0), 		// 数据库id自增\n    NONE(1), 		// 未设置主键\n    INPUT(2), 		// 手动输入\n    ID_WORKER(3), 	// 默认的全局唯一id\n    UUID(4), 		// 全局唯一id uuid字符串\n    ID_WORKER_STR(5); //ID_WORKER 字符串表示法\n}\n```\n更新操作\n```java\n// 测试更新\n@Test\npublic void testUpdate(){\n    User user = new User();\n    // 通过条件自动拼接动态sql\n    user.setId(6L);\n    user.setName(\"关注公众号：狂神说\");\n    user.setAge(18);\n    // 注意：updateById 但是参数是一个 对象！\n    int i = userMapper.updateById(user);\n    System.out.println(i);\n}\n```\n![](https://ae04.alicdn.com/kf/Hd9298f15f43340b085670447cf6fedb3Y.png)\n所有的sql都是自动帮你动态配置的！\n### 3、自动填充\n[https://mp.baomidou.com/guide/auto-fill-metainfo.html](https://mp.baomidou.com/guide/auto-fill-metainfo.html)\n创建时间createTime、修改时间updateTime！这些个操作一遍都是自动化完成的，我们不希望手动更新！\n\n\n阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！\n\n\n**方式一：数据库级别**（工作中一般不允许你修改数据库，所以这种方法用的少）\n1、在表中新增字段 create_time, update_time\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619360595958-9830b7c4-4877-4551-af5e-d72178cc36bd.png)\n设置默认值，update_time设置自动更新\n2、再次测试插入方法，我们需要先把实体类同步！\n```java\nprivate Date createTime;	//驼峰对应数据库表中的下划线	\nprivate Date updateTime;		\n```\n3、再次更新查看结果即可\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619360648152-121c3537-01ec-4abf-b2f2-2a704bb9293f.png)\n**方式二：代码级别**\n1、删除数据库的默认值、更新操作！\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619360688014-62de2a83-e9e6-4b4d-9160-813b199d8ea1.png)\n2、实体类字段属性上需要增加注解\n```java\n// 字段添加填充内容\n@TableField(fill = FieldFill.INSERT)\nprivate Date createTime;\n@TableField(fill = FieldFill.INSERT_UPDATE)\nprivate Date updateTime;\n```\n3、编写处理器来处理这个注解即可！\nMyMetaObjectHandler\n```java\npackage com.kuang.handler;\nimport com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.springframework.stereotype.Component;\nimport java.util.Date;\n\n@Slf4j\n@Component // 一定不要忘记把处理器加到IOC容器中！\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    // 插入时的填充策略\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        log.info(\"start insert fill.....\");\n        // setFieldValByName(String fieldName, Object fieldVal, MetaObject \nmetaObject\n        this.setFieldValByName(\"createTime\",new Date(),metaObject);\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n    // 更新时的填充策略\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        log.info(\"start update fill.....\");\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n}\n```\n4、测试插入\n5、测试更新、观察时间即可！\n### 4、乐观锁\n在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！\n**乐观锁 : **\n故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试\n**悲观锁：**\n故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！\n\n\n我们这里主要讲解 乐观锁机制！\n乐观锁实现方式：\n> - 取出记录时，获取当前 version\n> - 更新时，带上这个version\n> - 执行更新时， set version = newVersion where version = oldVersion\n> - 如果version不对，就更新失败\n\n```java\n//乐观锁：1、先查询，获得版本号 version = 1\n//-- A线程\nupdate user set name = \"kuangshen\", version = version + 1 \nwhere id = 2 and version = 1\n//-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！\nupdate user set name = \"kuangshen\", version = version + 1 \nwhere id = 2 and version = 1\n```\n**测试一下MP的乐观锁插件**\n1、给数据库中增加version字段！\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619360939310-235b549f-0da7-4e81-b177-089993cb85a5.png)\n2、我们实体类加对应的字段\n```java\n@Version //乐观锁Version注解\nprivate Integer version;\n```\n3、注册组件\n```java\n@EnableTransactionManagement		//开启事务\n@Configuration // 配置类\npublic class MyBatisPlusConfig {\n    // 注册乐观锁插件（旧方法）\n    @Bean\n    public OptimisticLockerInterceptor optimisticLockerInterceptor() {\n        return new OptimisticLockerInterceptor();\n    }\n}\n```\n4、测试一下！\n```java\n@Test\npublic void testOptimisticLocker(){\n    // 1、查询用户信息\n    User user = userMapper.selectById(1L);\n    // 2、修改用户信息\n    user.setName(\"kuangshen\");\n    user.setEmail(\"24736743@qq.com\");\n    // 3、执行更新操作\n    userMapper.updateById(user);\n}\n// 测试乐观锁失败！多线程下\n@Test\npublic void testOptimisticLocker2(){\n    // 线程 1\n    User user = userMapper.selectById(1L);\n    user.setName(\"kuangshen111\");\n    user.setEmail(\"24736743@qq.com\");\n    // 模拟另外一个线程执行了插队操作\n    User user2 = userMapper.selectById(1L);\n    user2.setName(\"kuangshen222\");\n    user2.setEmail(\"24736743@qq.com\");\n    userMapper.updateById(user2);\n    // 自旋锁来多次尝试提交！\n    userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！\n}\n```\n// 测试乐观锁成功！\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619361020560-26444870-6fe7-46c2-aa8b-ba67d955ea7c.png)\n### 5、分页查询\n分页在网站使用的十分广泛，常见的解决方法如下：\n1、原始的数据库查询 limit 进行分页；\n2、pageHelper 第三方插件；\n3、MybatisPlus 内置的分页插件；\n**如何使用？**\n1、配置拦截器组件即可\n```java\n@EnableTransactionManagement		//开启事务\n@Configuration // 配置类\npublic class MyBatisPlusConfig {\n    // 分页插件\n    @Bean\n    public PaginationInterceptor paginationInterceptor() {\n        return  new PaginationInterceptor();\n    }\n}\n```\n2、直接使用Page对象即可！\n```java\n// 测试分页查询\n@Test\npublic void testPage(){\n    //  参数一：当前页 2\n    //  参数二：页面大小 5\n    Page<User> page = new Page<>(2,5);\n    userMapper.selectPage(page,null);\n    page.getRecords().forEach(System.out::println);\n    System.out.println(page.getTotal());\n}\n```\n### 6、逻辑删除\n1、物理删除\n//根据 id 删除数据库记录\n```java\n@Test\npublic void testDeleteById(){\n    userMapper.deleteById(1240620674645544965L);\n}\n// 通过id批量删除\n@Test\npublic void testDeleteBatchId(){\n   \n userMapper.deleteBatchIds(Arrays.asList(1240620674645544961L,124062067464554496\n2L));\n}\n// 通过map删除\n@Test\npublic void testDeleteMap(){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"name\",\"狂神说Java\");\n    userMapper.deleteByMap(map);\n    }\n```\n2、逻辑删除 ：数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 => deleted = 1\n管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！\n测试一下：\n1、在数据表中增加一个 deleted 字段\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619361286033-6a06e3ee-b59f-47af-ae0d-e68f9166f17c.png)\n2、实体类中增加属性\n```java\n@TableLogic //逻辑删除\nprivate Integer deleted;\n```\n3、配置！\n```java\n// 配置逻辑删除组件！\n@Bean\npublic ISqlInjector sqlInjector() {\n    return new LogicSqlInjector();\n}\n```\n# application.properties配置逻辑删除\n```xml\nmybatis-plus.global-config.db-config.logic-delete-value=1\nmybatis-plus.global-config.db-config.logic-not-delete-value=0\n```\n4、测试一下删除！\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619361372590-85bd8ff9-f9d6-4bae-9a93-00445104da40.png)\n以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高你的工作和写项目的效率！\n\n\n### 7、性能分析插件\n我们在平时的开发中，会遇到一些慢sql。测试！ druid,\n作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间\nMP也提供性能分析插件，如果超过这个时间就停止运行！\n1、导入插件\n```java\n//SQL执行效率插件\n@Bean\n@Profile({\"dev\",\"test\"})// 设置 dev test 环境开启，保证我们的效率\npublic PerformanceInterceptor performanceInterceptor() {\n    PerformanceInterceptor performanceInterceptor = new \nPerformanceInterceptor();\n    // ms设置sql执行的最大时间，如果超过了则不执行\n    performanceInterceptor.setMaxTime(100); \n    performanceInterceptor.setFormat(true); // 是否格式化代码\n    return performanceInterceptor;\n}\n```\n记住，要在SpringBoot中配置环境为dev或者 test 环境！\n2、测试使用！\n```java\n@Test\nvoid contextLoads() {\n    // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null\n    // 查询全部用户\n    List<User> users = userMapper.selectList(null);\n    users.forEach(System.out::println);\n}\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619361469014-e26b1a9d-7ce4-4ea3-97fb-c34cc267ca2f.png)\n使用性能分析插件，可以帮助我们提高效率！\n### 8、条件构造器\n十分重要：queryWrapper\n我们写一些复杂的sql就可以使用它来替代！\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619361582121-1b753fbe-1bc2-45e3-a786-facc145669ff.png)\n1、测试一，记住查看输出的SQL进行分析\n```java\n@Test\nvoid contextLoads() {\n    // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper\n        .isNotNull(\"name\")\n        .isNotNull(\"email\")\n        .ge(\"age\",12);\n    userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习的map对比一下\n}\n```\n2、测试二，记住查看输出的SQL进行分析\n```java\n@Test\nvoid test2(){\n    // 查询名字狂神说\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.eq(\"name\",\"狂神说\");\n    User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List \n或者 Map\n    System.out.println(user);\n}\n```\n3、测试三，记住查看输出的SQL进行分析\n```java\n@Test\nvoid test3(){\n    // 查询年龄在 20 ~ 30 岁之间的用户\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.between(\"age\",20,30); // 区间\n    Integer count = userMapper.selectCount(wrapper);// 查询结果数\n    System.out.println(count);\n}\n```\n4、测试四，记住查看输出的SQL进行分析\n```java\n// 模糊查询\n@Test\nvoid test4(){\n    // 查询年龄在 20 ~ 30 岁之间的用户\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    // 左和右  t%\n    wrapper\n            .notLike(\"name\",\"e\")\n            .likeRight(\"email\",\"t\");//指的是%在左还是右\n    List<Map<String, Object>> maps = userMapper.selectMaps(wrapper);\n    maps.forEach(System.out::println);\n}\n```\n5、测试五（）\n```java\n// 模糊查询\n@Test\nvoid test5(){\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    // id 在子查询中查出来\n    wrapper.inSql(\"id\",\"select id from user where id<3\");\n    List<Object> objects = userMapper.selectObjs(wrapper);\n    objects.forEach(System.out::println);\n}\n```\n6、测试六\n```java\n@Test\nvoid test6(){\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    // 通过id进行排序\n    wrapper.orderByAsc(\"id\");\n    List<User> users = userMapper.selectList(wrapper);\n    users.forEach(System.out::println);\n}\n```\n### 9、代码自动生成\ndao、pojo、service、controller都可以通过代码自动编写！\nAutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。\n导入jar包\n```xml\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-boot-starter</artifactId>\n  <version>3.2.0</version>\n</dependency>\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-generator</artifactId>\n  <version>3.2.0</version>\n</dependency>\n<dependency>\n  <groupId>org.apache.velocity</groupId>\n  <artifactId>velocity-engine-core</artifactId>\n  <version>2.3</version>\n</dependency>\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger-common</artifactId>\n  <version>2.9.2</version>\n</dependency>\n```\napplication.yaml\n```yaml\n#数据库连接\nspring:\n  #设置开发环境\n  profiles:\n    active: dev\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n#配置日志\nmybatis-plus:\n  #整合mybatis\n  type-aliases-package: com.huang.blog.entity\n  mapper-locations: classpath:com/huang/blog/mapper/xml/*.xml\n\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n  #配置逻辑删除\n  global-config:\n    db-config:\n      logic-delete-field: deleted  #全局逻辑删除字段值\n      logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n      logic-not-delete-value: 0  # 逻辑未删除值(默认为 0)\n```\n测试：\n```java\npackage com.xjt;\n\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.annotation.FieldFill;\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\nimport com.baomidou.mybatisplus.generator.config.po.TableFill;\nimport com.baomidou.mybatisplus.generator.config.rules.DateType;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\n\nimport java.util.ArrayList;\n\npublic class AutoCodeGenerate {\n    public static void main(String[] args) {\n        // 需要构建一个 代码自动生成器 对象\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 配置策略\n        // 1、全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(\"user.dir\");\n        gc.setOutputDir(projectPath+\"/src/main/java\");\n        gc.setAuthor(\"xiongjt\");\n        gc.setOpen(false);\n        gc.setFileOverride(false);      // 是否覆盖\n        gc.setServiceName(\"%sService\");     // 去Service的I前缀\n        gc.setIdType(IdType.ID_WORKER);\n        gc.setDateType(DateType.ONLY_DATE);\n        gc.setSwagger2(true);\n        mpg.setGlobalConfig(gc);\n\n        //2、设置数据源\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/mybatis_db1\");\n        dsc.setDriverName(\"com.mysql.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"root\");\n        dsc.setDbType(DbType.MYSQL);\n        mpg.setDataSource(dsc);\n\n        //3、包的配置\n        PackageConfig pc = new PackageConfig();\n        //只需要改实体类名字 和包名 还有 数据库配置即可\n        //pc.setModuleName(\"blog\");\n        pc.setParent(\"com.xjt\");\n        pc.setEntity(\"entity\");\n        pc.setMapper(\"mapper\");\n        pc.setService(\"service\");\n        pc.setController(\"controller\");\n        mpg.setPackageInfo(pc);\n\n        //4、策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setInclude(\"user\");\n\n        // 设置要映射的表名\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        strategy.setEntityLombokModel(true);\n        // 自动lombok；\n        strategy.setLogicDeleteFieldName(\"deleted\");\n        // 自动填充配置\n        TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT);\n        TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE);\n        ArrayList<TableFill> tableFills = new ArrayList<>();\n        tableFills.add(gmtCreate); tableFills.add(gmtModified);\n        strategy.setTableFillList(tableFills);\n        // 乐观锁\n        strategy.setVersionFieldName(\"version\");\n        //restful风格\n        strategy.setRestControllerStyle(true);\n        strategy.setControllerMappingHyphenStyle(true);     // localhost:8080/hello_id_2\n        mpg.setStrategy(strategy);\n\n        mpg.execute(); //执行\n    }\n}\n```\n参考：[狂神代码](https://gitee.com/kuangstudy/openclass?_from=gitee_search)\n\n','原创','','','','','',1,1455457723817291777,NULL,0,0,'2022-01-08 17:20:54','2022-01-12 20:25:31'),(1479746765459677185,'【JavaScript】面试题1','总结了一些JavaScript面试题，希望面试的时候能被问到','https://ae04.alicdn.com/kf/H6e7034a82b384beda7e0216bb1da1c67V.png','## JavaScript必备知识\n```\ndocument.write(\"abc\");		//向DOM树直接写入文本\n行注释  ctrl+/\n块注释   ctrl+shift+/\n浏览器Console打印面板中黑色是字符，蓝色是数值或者布尔值\n断点是用来做大量代码排错功能\nconsole.log是用来少部分代码纠错\n```\n### 浏览器弹窗\n```js\nalert(\"tanchukuang\");		//浏览器默认警告框\nmsg = confirm(\"是否学过H5？\");   	//同步等待，1,确定/取消框\nconsole.log(msg);     // 是->true/否->false\nname = prompt(\"请输入你的姓名：\");  	//弹出输入框\nconsole.log(name);    //返回输入内容\n```\n### 变量命名规则\n\n- 变量名必须要有含义，除非在使用循环等内容需要用到无意义的递进变量时，其他时候变量必须有意义\n- 变量不能使用中文定义，变量名使用驼峰式命名方法,不能使用关键词和保留字\n- 临时变量或者参数定义时尽量以下划线开头 ，`_width,_height`\n- 不能使用保留字或关键字\n\n**程序员通用的几种命名方式：**\n\n- 驼峰式命名(推荐)\n\n首字母小写，每个单词大写   如`goodsNewPrice`\n\n- 匈牙利命名\n\n开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写，如 `var Sname = \"xiong\";`\n\n- 常量名规定\n\n必须使用全大写，单词中间使用下划线连接,BUTTON_CLICK_VALUE\n### 垃圾回收机制\n## 数据类型\n### 强制转换\n```js\nvar n=35;\nconsole.log(n.toString());    //默认是10进制\nconsole.log(n.toString(2));     //100011\nconsole.log(n.toString(36));  \n//总结：toString(r) r只能介于2-36之间，即可以将任意数值转化为2-36进制\nconsole.log(parseFloat(\"3.145\"));       //将字符转换为小数，3.145\nconsole.log(parseInt(\"3.145\"));     //将字符转换为整数，3\nconsole.log(parseFloat(\"3.14a\"));	//3.14\nconsole.log(Number(\"3.14a\"));		//NaN\n```\n### 隐式转换\n**加号运算符**\n```js\n\"a\"+10\n>>\"a10\"\n\"1\"+10\n>>\"110\"\n\"1\"+true\n>>\"1true\"\n1+true\n>>2\ntrue+NaN\n>>NaN\n\"1\"+NaN\n>>\"1NaN\"\n```\n**减号运算符**\n```js\nvar c1 = \"10a\";\nvar c2 = 5;\nvar c3 = \"\";\nvar c4 = true;\nvar c5 = \"50\";\nvar c6 = null;\nvar c7 = undefined;\nvar c8 = NaN;\nconsole.log(c1 - c2);//NaN\nconsole.log(c2 - c3);//5\nconsole.log(c2 - c4);//4\nconsole.log(c5 / c3);//Infinity\nconsole.log(c5 - c6);//50\nconsole.log(c5 - c7);//NaN\nconsole.log(c5 - c8);//NaN\n```\n`- * / %`   运算中会将值全部隐式转换为数值，再进行运算\n**递增运算符**\n```js\nvar a1 = \"10\";\na1++;\nconsole.log(a1, typeof (a1));//11,使用一元运算符,将会把所有内容转换为数值运算,不使用字符运算\na1++;   //12\nconsole.log(a1, typeof (a1));   //12  \"number\"\n++a1;\nconsole.log(a1, typeof (a1));   //13	\"number\"\n```\n看一道烧脑的题目：\n```js\nvar k=0;\nconsole.log(k++ + ++k +k +k++);		//0+2+2+2\nconsole.log(k);		//3\n```\n### 三元运算符\n语法：\n```js\nvar ret = 条件 ? 值1 : 值2;   //如果条件为true,返回值1,如果条件为false,返回值2\nvar x=100;\nvar sum=x>500 ? 500 : 400;		//sum==400\n```\n三元运算符与 || 运算符的妙用\n```js\n//判断obj是否是真,如果不是真,就设置为一个空对象\nvar x = obj || {};    //等价于下面的三元运算符\n//var x = obj ? obj : {};\n```\n## 循环&函数\n### switch循环\n```js\nvar str=prompt(\"请输入ABCDE中任意一个\");\nvar sum=0;\nswitch (str){\n    case \"A\":\n        sum+=1;\n        // 穿越\n    case \"B\":\n        sum+=2;\n        break;			//当输入A时，到这里才停止，sum==3\n    case \"C\":\n        sum+=3;\n        break;\n    case \"D\":\n        sum+=4;\n        break;\n    case \"E\":\n        sum+=5;\n        break;\n    default:\n        sum=0;		//当输入的不是ABCDE时 执行default\n}\nconsole.log(sum);\n```\n### while循环\n```js\n<button id=\"bn0\">1</button>\n<button id=\"bn1\">2</button>\n<button id=\"bn2\">3</button>\n<button id=\"bn3\">4</button>\n<script>\nvar i=0;\nwhile (i<=7){\n    var bn=document.getElementById(\"bn\"+i);\n    bn.onclick=function () {\n        console.log(i);		//8\n    };\n    /*  注意：onclick点击是异步事件\n        * 循环语句是瞬间全部执行完成的,在循环过程中所发生的事情都是瞬间的\n        * 但是如果在循环写点击或者其他的异步方法时,这些操作一定是在循环完成后才开始的,\n        因此,这里的i将不会是每个bn调用时的i值,而是循环完成最后的结果值\n        * */\n    i++;\n}\n</script>\n```\n### do-while循环\n```js\n/*\n  *  do{}while(); 循环,先执行do的内容块,然后才去判断条件\n  *  如果条件满足时继续循环,如果不满足就不再循环了\n  * \n  *  while()循环是先判断条件才去执行语句块的\n  * */\nvar i=98;\ndo{\n    console.log(i);		//98 99 \n    i++;\n}while (i<100)\n```\n### for循环\n```js\n/*\n  * for (表达式1;表达式2;表达式3){循环体}\n  * 表达式1一共运行了1次,循环之前运行\n  \n  * 表达式2是一个或者多个条件,不满足一个就跳出循环,循环多少次就执行多少次,在运行循环之前先判断条件\n  \n  * 表达式3（可以有多个）,循环多少次就执行多少次(先执行循环体中内容，再执行表达式3)\n  * */\nvar sum = 0;\nfor(var i=0;i<=3;i++,console.log(\"aa\")){\n    sum += i;		//sum+0+1+2+3\n    console.log(\"bb\")\n}\nconsole.log(sum);		//6\n```\n### 异常处理\n**语法错误或逻辑错误**\n```js\ntry {\n    var num=1/0;\n    console.log(num);       //Infinity\n}catch(exception){\n    console.log(exception.message);\n}\n```\n**自定义抛出错误**\n```js\ntry{\n    var num=1/0;\n    if(num==Infinity){\n        throw new Error(\"Error大写，用new初始化-->除数不能为0\");\n    }\n}\ncatch(exception){\n    console.log(\'错误信息是：\',exception.message);\n}\n```\n## 函数\n### 函数定义\n**普通函数(又叫具名函数)**\n```js\n//函数定义\nfunction 函数名(参数名1...){\n	语句块\n}\n//函数调用\n函数名();\n```\n**函数提升**（将整个函数的定义提升到作用域最前面）\n```js\nfoo(); //1\n \nvar foo;\n \nfunction foo () {\n    console.log(1);\n}\n \nfoo = function () {\n    console.log(2);\n}\nfoo();	//2\n```\n实际上函数提升后的情形如下：\n```js\nfunction foo () {\n    console.log(1);\n}\nfoo(); //1\n \nvar foo;\nfoo = function () {\n    console.log(2);\n}\nfoo();	//2\n```\n注意：js是解释性语言，代码从上而下执行，只有函数具有块级作用域概念，判断语句 循环语句都没有块级作用域的概念\n```js\nconsole.log(a)\nif (a) {\n    var a = 1;\n    console.log(a)\n}\nfunction a() {\n    console.log(this);\n}\nconsole.log(a);\na();\n```\n函数提升之后：\n```js\nfunction a() {\n    console.log(this);\n}\nconsole.log(a)		//打印a函数结构\nvar a;\nif (a) {\n    a = 1;		//将a函数覆盖了\n    console.log(a)\n}\nconsole.log(a);		//1\na();			//a变成了1，不是函数，这一步报错\n```\n**补充：变量提升**\n将变量定义提升到作用域最前面，变量赋值/运算等不变\n```js\nfunction test () {\n    console.log(a);  //undefined\n    var a = 123; \n};\ntest();\n```\n提升之后：\n```js\nfunction test () {\n    var a;\n    console.log(a);\n    a = 123;\n}\ntest();\n```\n**匿名函数**\n```js\n//函数定义\nvar fn1=function(参数名1...){\n    语句块\n}\n//函数调用\nfn1();\n```\n注意辨析：\n```js\nfn1();  //fn1 不能执行\nfn2();  //fn2可以执行,fn2 函数提升\nvar fn1 = function () {\n    console.log(\"aaa\");\n};\nfunction fn2() {\n    console.log(\"bbb\");\n}\n```\n闭包函数中变量提升\n```js\nvar name = \'World!\';\n(function () {\n    if (typeof name === \'undefined\') {\n        var name = \'Jack\';  //变量提升\n        console.log(name)\n    } else {\n        console.log(name)\n    }\n})()\n```\n### 函数参数\n#### Arguments传参\nArguments可以传递多个不同类型的参数（不定参数）\n```js\nfunction howManyArgs() {\n    console.log(arguments.length);  //参数个数\n    console.log(arguments);\n    console.log(arguments[0]);\n    let arr = Array.from(arguments);    //将类数组对象(Arguments) 转为数组对象\n    console.log(arr);\n}\nhowManyArgs(\"xiong\", 45); //2\nhowManyArgs(); //0\nhowManyArgs({name:\'xiong\',age:18}); //1\nhowManyArgs(\'beijing\',2019,[11,22,33],{name:\'xiong\',age:18}); //字符串 数字 数组 对象\n```\n第一次调用`howManyArgs(\"xiong\", 45);`打印结果：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338234-c35825cc-3dd1-4f55-8911-c625fa7b695b.png#height=245&id=ArlQP&originHeight=245&originWidth=267&originalType=binary&ratio=1&status=done&style=none&width=267)\n### 参数类型\n#### 判断参数类型\njs是弱类型语言，参数类型,因为不能固定,因此,如果写给别人用的代码时,一定需要判断输入参数的类型\n初始化:在ES5中函数的参数不能设置初始化值(如果执行函数的时候没有输入该参数,\n希望它有一个默认的初始值),也需要进行设置,ES6中是有初始化参数的,因此ES6中可以直接使用\n定义函数中的参数叫做形参，设置函数中的参数值,参数值就是实参\n```js\nfunction fn1(a, b, type) {\n    if (type !== \"+\" && type !== \"-\" && type !== \"*\" && type !== \"/\") {\n        type = \"+\";\n    }\n    if (isNaN(a)) a = 0;\n    if (isNaN(b)) b = 0;\n    var sum = 0;\n    switch (type) {\n        case \"+\":\n            sum = a + b;\n            break;\n        case \"-\":\n            sum = a - b;\n            break;\n        case \"*\":\n            sum = a * b;\n            break;\n        case \"/\":\n            sum = a / b;\n            break;\n        default:\n    }\n    console.log(sum);\n}\nfn1(3, 5, \"+\");\nfn1(10, 5, \"-\");\nfn1(20, 10);\n```\n#### 参数传入对象\n```js\nfunction fn2(o) {\n    o.a = 10;\n}\nvar obj = {c: 1};\nvar obj1 = {d: 1};\nfn2(obj);       //传入的是对象obj的栈中的地址，函数执行时修改了栈地址指向的堆中的数据。\n// 函数执行完之后销毁，但是对象obj栈的地址在函数外定义的，函数执行之后再次调用地址 还是指向堆中内容\nfn2(obj1);\nconsole.log(obj, obj1);\nfunction fn3(s) {\n    s += 10;\n}\nvar sum = 10;\nfn3(sum);       //sum存储在栈之中，函数执行完之后清空栈的s\nconsole.log(sum);   //10\n```\n#### 参数传入函数名\n```js\nfunction fn5(o, fn) {\n    o.a += 1;\n    fn(o);\n  }\n  function fn6(_o) {\n    _o.a += 10;\n  }\n  function fn7(_o) {\n    _o.b = 20;\n  }\n  var obj4 = {a: 1};\n  fn5(obj4, fn6);   //obj4={a:12}\n  console.log(obj4);\n  fn5(obj4, fn7);   //obj4={a:13,b:20}\n  console.log(obj4);\n```\n#### 函数执行自己-递归\n```js\nvar sum1 = 0;\nvar i = 0;\nfunction fn8() {\n    if (i === 100) {\n        return;//跳出函数外\n    }\n    sum1 += i;\n    i++;\n    fn8();\n}\nfn8();\nconsole.log(sum1);\n```\n案例：\n```js\n<button id=\"bn\">点击</button>\n<script>\n    function print(n,m) {\n    document.write(n+\"*\"+m+\"=\"+n*m+\" \");\n}\nfunction printa(n,m) {\n    document.write(n+\"+\"+m+\"=\"+(n+m)+\" \");\n}\nfunction printStart(n,m) {\n    for(var i=n;i<m;i++){\n        document.write(\"*\")\n    }\n}\nfunction printRow(row) {\n    for(var i=1;i<=row;i++){\n        print(i,row);\n    }\n    document.write(\"<br>\");\n}\nfunction createMultiplicationTable() {\n    for(var i=1;i<10;i++){\n        printRow(i);\n    }\n}\ncreateMultiplicationTable();\nvar bn=document.getElementById(\"bn\");\nvar bool=false;\nbn.addEventListener(\"click\",clickHandler);\nfunction clickHandler(e) {\n    bool=!bool;\n    if(bool){\n        document.body.style.backgroundColor=\"red\";\n    }else{\n        document.body.style.backgroundColor=\"white\";\n    }\n}\n</script>\n```\n输入行数列数创建一个表格\n```js\n<script>\nvar row=Number(prompt(\"请输入行数\"));\nvar col=Number(prompt(\"请输入列数\"));\nif(!isNaN(row) && !isNaN(col)){\n    var str=\"<table>\";\n    for(var j=0;j<row;j++){\n        str+=\"<tr>\";\n        for(var i=0;i<col;i++){\n            str+=\"<td></td>\";\n        }\n        str+=\"</tr>\";\n    }\n    str+=\"</table>\";\n}\ndocument.write(str);\n</script>\n```\n### 函数返回return\n#### 区别return、break、continue\n```shell\nreturn   ,只能使用在函数中,直接跳出函数,不执行return以后的语句\nbreak    ,只能使用在循环或者switch中,跳出当前循环,不执行break以后语句,并且不再进入\ncontinue ,只能使用在循环中,跳出本次循环,当前不再继续执行continue后面的语句,但是继续下一次循环\n```\n如果函数没有使用return或者直接使用return 后面没有值，这时候实际是返回一个undefined\n```js\nfunction fn1(){}\nvar ret = fn1();\nundefined\n```\n#### return的返回类型\nreturn只能返回一个值，但是其类型可以多样\n\n- 返回变量\n- 返回对象\n\n案例1：单例模式\n```js\nvar box;\nfunction createBox(_a, _b) {\n    if (!box) {\n        box = {};\n    }\n    box.a = _a;\n    box.b = _b;\n    return box;\n}\n```\n案例2：返回参数传入的对象\n```js\nfunction setObjProper(obj) {\n    obj=obj || {};  //宽模式\n    obj.n=3;\n    return obj;\n}\nvar obj=setObjProper({});\nvar obj1=setObjProper();\nvar obj2={a:5};\nconsole.log(obj2===setObjProper(obj2));     //true\nconsole.log(obj2);     //{a:5,n:3}\nconsole.log(obj,obj1);  //{n:3} {n:3}\n```\n对象内容是存储在堆中，地址引用存储在栈中，函数setObjProper(obj2)修改的是同一份obj2对象\n\n- 返回函数自身（递归）\n```js\nvar i=0;\nvar sum=0;\nfunction getSum() {\n    i++;\n    sum+=i;\n    if(i>=100){\n        return sum;//最后一次返回给前一个函数\n    }\n    return  getSum();\n}\nconsole.log(getSum());\n```\n案例1：获取`<body></body>`中所有含有id属性的标签，将id属性作为key，标签对象作为value添加到对象dic中\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338303-33a1ca19-c6ad-419b-859c-91b240cbd492.png#height=570&id=XFffp&originHeight=570&originWidth=340&originalType=binary&ratio=1&status=done&style=none&width=340)\n```js\nvar dic={};\nconsole.log(getElemId(document.body));\nfunction getElemId(elem) {\n    if(elem.id){\n        dic[elem.id]=elem;\n    }\n    for(var i=0;i<elem.children.length;i++){\n        getElemId(elem.children[i]);\n    }\n    return dic;\n}\n```\n\n- 返回回调函数结果\n```js\nfunction fn2(fn) {\n    var obj={};\n    return fn(obj);\n}\n```\n\n- 函数中返回一个函数（又叫闭包）\n```js\nfunction fn5() {\n    return function () {\n        console.log(\"aaa\");\n    }\n}\nfn5()();\n```\n综合案例：\n1.求随机的十六进制颜色或rgba(255,123,63,0.3);颜色\n```js\n//rgba(255,123,63,0.3);\nfunction getRandomColor() {\n    var r=parseInt(Math.random()*256).toString();\n    var g=parseInt(Math.random()*256).toString();\n    var b=parseInt(Math.random()*256).toString();\n    return \"rgba(\"+r+\",\"+g+\",\"+b+\",\"+Math.random().toFixed(2)+\")\";\n    \n//#ff12c4\nfunction getRandomColor() {\n    var color=\"#\";\n    for(var i=0;i<3;i++){\n        var str=parseInt(Math.random()*256);\n        if(str<16){\n            str=\"0\"+str.toString(16);\n        }else{\n            str=str.toString(16);\n        }\n        color+=str;\n    }\n    return color;\n```\n### JS内置函数\n#### `setInterval(func,millisec);`\n每隔多长时间（毫秒）执行一次函数func\n`var id= setInterval(每次执行函数,多少毫秒执行一次)`\n返回一个id,这个id的作用可以是clearInterval清除该id,这样就停止了这个定时器\n示例：\n```js\nvar div0=document.getElementById(\"div0\");\nvar left=0;\nvar bool=true;\nsetInterval(animation,16);  //animation函数每隔16ms执行一次\ndiv0.addEventListener(\"click\",clickHandler);\nfunction clickHandler(e) {\n    bool=!bool;\n}\nfunction animation() {\n    if(!bool) return;\n    left+=2;\n    div0.style.left=left+\"px\";\n}\n```\n#### setTimeout()\n用于在指定的毫秒数后调用函数或计算表达式，即延迟执行\n语法：\n```js\nsetTimeout(code/function, milliseconds, param1, param2, ...)\n参数						描述\ncode/function		 必需。要调用一个代码串，也可以是一个函数。\nmilliseconds		 可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。\nparam1, param2, ...	 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。\n```\n示例：\n```js\nsetTimeout(alertFunc, 3000);		//3s后执行alertFunc()\n \nfunction alertFunc() {\n    alert(\"Hello!\");\n}\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338382-24ec8e00-3cd7-422f-9055-8154874f6fea.png#height=196&id=NfYT3&originHeight=196&originWidth=465&originalType=binary&ratio=1&status=done&style=none&width=465)\n## 数组\n### 数组创建\n\n1. 字面量创建\n```js\nvar arr=[1,2,3,4,5];    //字面量创建\nvar arr2=[1,false,\"a\",{a:1,b:2}];     //这种不同类型的数据存储会造成数组操作时的效率降低\n```\n\n2. 对象构造函数创建\n```js\nvar arr1=new Object([1,2,3,4]); //对象构造函数创建\nconsole.log(typeof arr);     //object\nconsole.log(Array.isArray(arr));  //true，判断arr是否是数组 返回bool\n```\n\n3. 构造函数创建\n```js\nvar arr2=new Array();     //构造函数创建;arr2是 object类型\nvar arr2=new Array(1,2,3,4);  //构造函数创建，也可以直接赋值（但不建议直接这样赋值）;\n/*\n*   构造函数创建数组时,第一个参数\n*   如果第一个参数是数值类型并且构造函数中只有这一个参数,这个参数就是设置数组的长度,\n这个长度不能是小数或者负数,否则会报错\n*   如果参数有2个或2个以上,那么第1个元素就不是数组的长度了,而是数组的第0个元素；\n如果第1参数不是数值类型,且仅有1个,也是作为数组的第0个元素\n* */\nvar arr2=new Array(4);    //4是数组长度，这个性质其实没啥用\n//设置之后可以往里面加入的元素不止4个 arr2[5]=1;\narr2[4]=1;\nconsole.log(arr2);	//[empty × 4,1]\n```\n#### 数组参数\n\n- 固定参数\n- 不定参数arguments\n```js\n//求数组中最大值\nfunction max() {\n    console.log(arguments);     //arguments 就是max() 传入的参数\n    var arr = Array.from(arguments);        //将传入的参数 转化为一个数组\n    return arr.reduce(function (p1, p2) {\n        //p1=arr[0]  p2=arr[1] ...\n        return p1 > p2 ? p1 : p2;\n	});\n}\nconsole.log(max(1, 2, 3, 5, 7, 9, 1, 2, 5));  //Arguments(9) 9\nconsole.log(max(3, 6, 8, 20, 10));  //Arguments(5) 20\n```\n### 数组属性和方法\n数组方法：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338450-c51c57aa-098d-40ff-9412-a1db4cbdd5eb.png#height=769&id=Mlo0c&originHeight=769&originWidth=489&originalType=binary&ratio=1&status=done&style=none&width=489)\n#### 数组长度\n`arr.length`\n#### 数组转为字符串\n`arr.toString()`\n```js\n//纯数组\nvar arr=[1,2,3,4,5];\nvar str2=arr.toString();     \nconsole.log(str2);		//\"1,2,3,4,5\"\n//数组中嵌套对象\nvar arr1 = [1,2,[11,\"guangdong\",22],{name:\"xiong\"}];\nvar str1=arr1.toString();     \nconsole.log(str1);		//	1,2,11,guangdong,22,[object Object]\n```\n所以将含有对象的数组或对象转为字符串时，最好使用JSON序列化\n```js\nvar obj={a:1,b:2,c:3};\nvar str=JSON.stringify(obj);\n// 将JSON字符串反序列化回对象\nvar obj1=JSON.parse(str);\nobj.a=20;\nconsole.log(obj);//{a: 40, b: 2, c: 3}\nconsole.log(obj1);//{a: 1, b: 2, c: 3}\n```\n#### `in`方法\n判断数组中索引是否存在，也可以判断对象的某个key是否存在\n```js\nconsole.log(\"b\" in obj);\nvar arr11=[1,2,3,4,5];\n// 数组中是否有该下标（索引）,不是值\nconsole.log(5 in arr11);   //false，索引5不存在\nconsole.log(3 in arr11);   //true，索引3不存在\n```\n#### push() pop() shift() unshift()\npush([val])  向数组尾部添加一个元素，如果为空返回数组长度\npop()  删除数组尾部一个元素，返回该值\nshift()  删除数组头部一个元素，返回该值\nunshift([val])  向数组头部添加一个元素，如果为空返回数组长度\n```js\nvar arr = [-2, -1, 0, 1, 2, 3, 4, 5];\nvar len = arr.push();  //返回数组的长度8\nconsole.log(len,arr); //8 [-2, -1, 0, 1, 2, 3, 4, 5]\nlen = arr.push(6);   //9  [-2, -1, 0, 1, 2, 3, 4, 5,6];\nconsole.log(len,arr);\nvar len1 = arr.push(6, 7, 8);  //12 [-2, -1, 0, 1, 2, 3, 4, 5,6,7,8];\nconsole.log(len1,arr);\nvar len2 = arr.push([6, 7, 8]);  //13 [-2,-1,0,1,2,3,4,5,6,6,7,8,[6,7,8]];\nconsole.log(len2,arr);\n// 数组首端入栈\n//        var len=arr.unshift();  //返回arr的长度 等价于 arr.length\n//        var len=arr.unshift(0); //在数组开头添加一个元素0\n//        var len=arr.unshift(-2,-1,0);\n/*\n  *  向头部添加元素效率低，减少使用unshift\n  * */\n//        console.log(len,arr);\n//        删除数组尾部的元素\n//        var t=arr.pop();  //返回被删除的元素\n//        console.log(t);\n/*\n  //复制数组arr的值 到arr1中\n  var arr1=[];\n  var t;\n  while (t=arr.pop()){\n      arr1.push(t);\n  }\n  console.log(arr1,arr);*/\n//删除数组的头部元素\n//        var t=arr.shift();//返回被删除的元素\n```\n示例1：\n随机生成一个五位以内的数（4位 3位 2位 1位），然后输出该数共有多少位，每位分别是什么\n```js\nvar arr1=[];\nvar bool=false;\nfor(var i=0;i<4;i++){\n    var s=parseInt(Math.random()*10);   //随机生成0-9\n    if(s===0 && !bool) continue;    //第一位不能是0（第一次循环时判断）\n    arr1.push(s);\n    bool=true;\n}\nvar num=Number(arr1.join(\"\"));\nconsole.log(arr1,arr1.length,num)	//[7, 8, 2, 5] 4 7825\n```\n#### join()  concat()\n**join()**  将数组以某种方式连接成字符串\n**concat()**  将两个数组连接起来，如果传入的是数组对象，会将数组对象拆开之后连接到原数组（注意区分push()）\n```js\nvar arr = [1, 2, 3, 4];\n    console.log(arr.join());    //arr.toString()相同，以逗号分隔的字符串\n    console.log(arr.join(\"#\"));   //设置一个符号,用这个符号链接数组的每个元素,形成新字符串\n    console.log(arr.join(\"\"));    //元素紧密相连，中间没有分割\nvar arr1 = arr.concat();    //没有参数时,是复制数组，原数组arr不变 返回新的数组\narr[0] = 10;		//arr1与arr指向同一个堆地址\nvar arr1 = arr.concat(5, 6); //将arr数组链接,5,6两个元素,形成新数组,原数组不变\nconsole.log(arr1, arr);		//[10, 2, 3, 4, 5, 6]  [10, 2, 3, 4]\nvar arr1 = arr.concat([5, 6, 7]); //将数组[5,6,7]拆开之后与arr数组合并形成新数组\nconsole.log(arr1, arr);		//[10, 2, 3, 4, 5, 6, 7]  [10, 2, 3, 4]\nvar arr1 = arr.concat([11, 22], [33, 44], [55, 66, 77]); //可以连接多个\nconsole.log(arr1, arr);	//[10, 2, 3, 4, 11, 22, 33, 44, 55, 66, 77] [10, 2, 3, 4]\n```\n#### slice()  splice()\n`arr.splice()`  数组插入/删除/替换元素, 并且返回被修改元素组合的新数组，原数组arr改变\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar newArr = arr.splice();	//创建一个新的空数组返回  newArr=[]\nvar arr1 = arr.splice(3);	//从下标是3开始删除到尾部  [4,5]\nvar arr1 = arr.splice(0);	//将arr的所有元素导入到arr1中.清空arr\nvar arr1 = arr.splice(0, 2);	//从arr数组的下标0开始删除2位元素 [1,2]\nvar arr1 = arr.splice(0, 0, -1);//在第0位插入一个-1;  arr1=[]  arr=[-1,...]\nvar arr1 = arr.splice(-1, 0, -1);//在第-1位(倒数第1位)插入一个-1;\nvar arr1 = arr.splice(arr.length, 0, -1);//在尾部插入一个-1\nvar arr1 = arr.splice(1, 2, -1, -2);//从第1位开始替换两个元素为-1,-2\nconsole.log(arr1, arr);\n```\n示例：\n数组去重（相较于Set() 集合方法，不改变数组顺序）\n```js\nvar arr1 = [1, 3, 5, 2, 1, 4, 3, 1, 2, 5, 3, 1, 2, 1];\nfor (var i = 0; i < arr1.length; i++) {\n    for (var j = i + 1; j < arr1.length; j++) {\n        if (arr1[i] === arr1[j]) {\n            arr1.splice(j, 1);\n        }\n    }\n}\nconsole.log(arr1)\n```\n`arr.slice();`数组截取元素,返回被截取的新元素,原数组不改变\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2=arr.slice();//复制arr的所有元素给arr2,没有引用关系\nvar arr2=arr.slice(0);//复制arr的所有元素给arr2,没有引用关系\nvar arr2=arr.slice(3);//将数组从下标3开始到结尾截取形成新数组\nvar arr2=arr.slice(-2);//将数组从倒数第2位开始到结尾截取形成新数组\nvar arr2=arr.slice(3,4);//将数组从下标3开始到下标4截取形成新数组\nvar arr2=arr.slice(-2,4);//将数组从倒数第2位开始到下标4截取形成新数组\nvar arr2=arr.slice(-2,-1);//将数组从倒数第2位开始到倒数第1位截取形成新数组\nconsole.log(arr2,arr);\n```\n#### indexOf()  lastIndexOf()\n`arr.indexOf(item,start)`  在数组中查找元素,第二个参数设置开始查找的起始位置，返回查找到元素的下标,如果没有找到返回-1\n```js\nvar arr=[1,2,3,4,5,6,2,9,10,2];\nconsole.log(arr.indexOf(2));  		//从下标0开始向后查找2\nconsole.log(arr.indexOf(2,2)); 		//从下标2开始向后查找2\n//找到arr中所有的2\nvar index=-1;\nwhile (arr.indexOf(2,index+1)>-1){\n    index=arr.indexOf(2,index+1);\n    console.log(index);\n}\n```\n`array.lastIndexOf(item,start)`\nitem    必需。规定需检索的字符串值。\nstart  可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。\n如省略该参数，则将从字符串的最后一个字符处开始检索\n```js\narr.lastIndexOf(2);  //从后向前搜索,查找到元素的下标返回\n```\n#### reverse()  sort()\nreverse() 倒序，改变原数组\n```js\nvar arr = [2, 3, 5, 7, 9, 1, 4, 6, 8, 10];\nvar arr1 = arr.reverse();    //\nconsole.log(arr, arr === arr1);  //true,arr1和arr是引用关系\n```\nsort()  排序，排序数组中的元素,原数组发生改变,返回的新数组和原数组是引用关系\n```JS\nvar arr1 = arr.sort();\nconsole.log(arr,arr1===arr);    //[1, 10, 2, 3, 4, 5, 6, 7, 8, 9] true  按ASCII码进行排序\n```\n#### Array.isArray()\n判断一个对象是否是数组\n#### Array.from()\nES6的方法 将类数组对象转化为数组\n```js\nArray.prototype.slice.call(div);      //(ES5)\nArray.from(div);  //将类数组转换为数组(ES6)\nvar items = document.getElementsByTagName(\"div\");\nvar item_list = Array.from(items);\nitem_list.forEach((item,index,arr)=>{\n    console.log(item.className);\n})\n```\n### 深拷贝和浅拷贝\n```js\n//对象的第一级属性不关联，第二级以上属性都指向相同堆地址\nvar objs={\n    a:1,\n    b:{\n        a:1,\n        b:{\n            a:1,\n            b:{\n                a:1\n            }\n        }\n    }\n};\nvar obj2={};\nfor(var prop in objs){\n    obj2[prop]=objs[prop];\n}\nobjs.b.a=10;\nobjs.a = 22;\nconsole.log(objs);    //  {a:22,b:{a:10,b:{a:1,b:{a:1}}}}\nconsole.log(obj2);    //{a:1,b:{a:10,b:{a:1,b:{a:1}}}}\n```\n那么怎么完成深拷贝呢？有两种方法提供\n#### 递归\n#### 利用JSON转换实现深复制\n```js\nvar obj3=JSON.parse(JSON.stringify(objs));\nobjs.b.b.a=10;\nconsole.log(objs,obj3);\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338524-3e51e06c-034d-41f2-8bc6-34dffecba255.png#height=170&id=qz7Tq&originHeight=170&originWidth=369&originalType=binary&ratio=1&status=done&style=none&width=369)\n## 字符串\n### String类型\n```js\nvar str1 = \"abc\";\nconsole.log(str1[1]); //b\nstr1[0] = \"d\";    //字符串可以通过[索引值]获取这个位置字符,但是不能设置这个位置的字符\nconsole.log(str1);  //abc\n//字符串的length不可修改,只能获取。\nconsole.log(str1.length); //3\nstr1.length=2;    \nconsole.log(str1 === \"abc\");        //true\nvar arr = [1,2,3,4,5,6];\narr.length = 3;\nconsole.log(arr === [1, 2, 3]);     //false\n//反转字符串\nfunction stringReverse(str) {\n    var str1 = \"\";\n    for (var i = str.length - 1; i >= 0; i--) {\n        str1 += str[i];\n    }\n    return str1;\n}\n```\n### 字符串属性和方法\n#### indexOf()\n语法：\n```js\nstringObject.indexOf(searchvalue,fromindex)\n参数：\n    searchvalue	必需。规定需检索的字符(串)值。\n    fromindex	可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 \n    stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。\n```\n示例：//查找某个字符在字符串中出现次数\n```js\nvar num=0;\nvar index=-1;\nwhile (str.indexOf(\"a\",index+1)>-1){       //规定在字符串中开始检索的位置\n    index=str.indexOf(\"a\",index+1);\n    num++;\n}\nconsole.log(num);\n```\n提示：\n\n- indexOf() 方法对大小写敏感！\n- 如果要检索的字符串值没有出现，则该方法返回 -1。\n\n练习：\n```js\nvar data = [\n        {id: 1001, icon: \"img/1.psd\", name: \"计算机\", num: 1, price: 10},\n        {id: 1002, icon: \"img/2.gif\", name: \"手机\", num: 1, price: 20},\n        {id: 1003, icon: \"img/3.jpg\", name: \"电脑\", num: 1, price: 30},\n        {id: 1004, icon: \"img/4.png\", name: \"显示器\", num: 1, price: 40},\n        {id: 1005, icon: \"img/5.jpg\", name: \"飞行器\", num: 1, price: 50},\n        {id: 1006, icon: \"img/6.gif\", name: \"计时器\", num: 1, price: 60},\n        {id: 1007, icon: \"img/7.png\", name: \"笔记本\", num: 1, price: 70},\n        {id: 1008, icon: \"img/8.png\", name: \"草稿本\", num: 1, price: 80},\n        {id: 1009, icon: \"img/9.gif\", name: \"公示牌\", num: 1, price: 90},\n        {id: 1010, icon: \"img/10.png\", name: \"手机线\", num: 1, price: 100}\n    ];\n//查找name中含有 ‘本’ 字的\nvar arr=data.filter(function (t) {\n    return t.name.indexOf(\"本\")>-1;\n});\n// name中含有 ‘机’ 且‘机’ 是最后一个字符\nvar arr = data.filter(function (t) {\n    return t.name.indexOf(\"机\") === t.name.length - 1;\n});\nconsole.log(arr);\n// str.lastIndexOf(); 从后向前查找\nconsole.log(data[0].name.lastIndexOf(\"机\")); 	//2\n```\n#### search()\n```js\n//str.search(\"a\")  查找字符串\nvar str = \"abcadea\";\nconsole.log(str.search(\"a\"));   //search用于正则表达式查找,找到第一个就返回索引\nconsole.log(str.search(\"m\"));   //没找到返回-1\n```\n#### replace()\n语法：\n```js\nstringObject.replace(regexp/substr,replacement)\n参数				描述\nregexp/substr	必需。规定子字符串或要替换的模式的 RegExp 对象。\n				如果该值是一个字符串它作为要检索的直接量文本模式，而不是首先被转换为RegExp对象。\nreplacement		必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n```\n示例：\n```js\n//replace替换字符,可以将字符替换后返回一个替换后的新字符,原字符不变\n// 目前我们只能替换一次,如果要替换所有,就需要写循环\n// replace多用于正则表达式中的替换\nvar str = \"abcadea\";\nvar str1 = str.replace(\"a\", \"h\");	\nconsole.log(str1,str);	//hbcadea abcadea\n//与正则表达式搭配使用\nvar str2 = str.replace(/a/g, \"$\");\n```\n大小写转换：\n```js\nconsole.log(str.toLowerCase()); //转换小写\nconsole.log(str.toUpperCase()); //转换大写\n```\n#### split()\n```js\n// split根据分割符将字符串分割为数组,和数组中方法join相对,是join的逆方法\n//生成新的数组，原字符串不变\nvar str=\"a,b,c,d,e\";\nvar arr=str.split(\",\");\nconsole.log(arr);   //[\"a\", \"b\", \"c\", \"d\", \"e\"]\nvar str=\"abcde\";\nvar arr=str.split(\"\");		//split()默认的以空格为分隔符\nconsole.log(arr);     //[\"a\", \"b\", \"c\", \"d\", \"e\"]\n```\n练习1：字符串倒序\n```js\n//注意：str.reverse()  字符串没有倒序方法\n//数组arr.reverse()\nvar str=\"abcde\";\nstr=str.split(\"\").reverse().join(\"\");//倒序字符\nconsole.log(str);   //\"edcba\"\n```\n练习2：url查询字符串键值对组成对象\n```js\nvar url=\"http://www.163.com/index.html?ab=3&name=xie&passwd=12345\";\nfunction getObject(url) {\n    var obj={};\n    var str=url.split(\"?\")[1];	//取出？后的查询字符串 ab=3&name=xie&passwd=12345\n    var arr=str.split(\"&\");	//[\"ab=3\",\"name=xie\",\"passwd=12345\"]\n    for(var i=0;i<arr.length;i++){\n        var str1=arr[i].split(\"=\");\n        var prop=arr1[0];\n        var value=arr1[1];\n        obj[prop]=value;\n    }\n    return obj;\n}\n```\n练习3：\n```js\n// split和join，slice和splice分别是什么？\n//split将字符串按照某个分隔符分割为数组\nvar str1=\"name=xiong&age=27&addr=henan\"\nstr1.split(\"&\")   //[\"name=xiong\", \"age=27\", \"addr=henan\"]\nstr1    //\"name=xiong&age=27&addr=henan\"\n//join 将数组以某个符号连接为字符串（默认是逗号）\n[\"name=xiong\", \"age=27\", \"addr=henan\"].join(\"&\")\n\"name=xiong&age=27&addr=henan\"\n[\"name=xiong\", \"age=27\", \"addr=henan\"].join()\n\"name=xiong,age=27,addr=henan\"\narr.slice(startIndex,endIndex)   str.slice(startIndex,endIndex)\n//slice 不改变原来的arr或str\narr.splice(index,len,newVal1,newVal2,...)\n```\n#### slice()  sbustr()  substring()\n与数组中的str.slice(start,end)完全相同，用于截取字符串中某段内容，源字符串不变，返回新的字符串\n若未指定end 则截取到字符串结尾\n示例：获取随机RGB(255,0,0)颜色\n```js\nfunction getRandomColor() {\n    var col = \"rgb(\";\n    for (var i = 0; i < 3; i++) {\n        col += Math.floor(Math.random() * 256) + \",\";\n    }\n    //rgb(255,230,120,\n    col = col.slice(0, -1); //原字符串不变\n    col += \")\";\n    console.log(col);\n    return col;\n}\n```\nstr.substr(开始位置,要截取字符串的长度)\n```js\nconsole.log(str.substr(0,3));\n//str.substring(开始位置x,截取的结束位置y)   原字符串不变\n//和slice不同在与,负数不是代表从后向前数,而是位置x的前面(当后面数小于前面数可以理解为倒着截取)\nvar str = \"abcde\";\nconsole.log(str.substring(1, 3)); //bc\nconsole.log(str.substring(3, -1)); //abc，从第3个字符串开始向前截取\nconsole.log(str.substring(4, 2));    //cd,可以开始位置大于结束位置,这就是逆向截取\n//总结：substr()不好用，推荐slice()\n```\n#### Date()对象\n```js\nvar date=new Date(); //2\nconsole.log(date);\nconsole.log(date.getTime());  //1582632714701\nconsole.log(date.getFullYear());\nconsole.log(date.getMonth());//月份显示是从0开始计算,1就是2月\nconsole.log(date.getDate());	//几号\nconsole.log(date.getDay());	//星期几  0-6 0是星期日\nconsole.log(date.getHours());//小时\nconsole.log(date.getMinutes());//分\nconsole.log(date.getSeconds());//秒\nconsole.log(date.getMilliseconds());//毫秒\n//set方法\ndate.setFullYear(2020);\ndate.setMonth(12);  //如果设置12大于了11,就会进1年,当前为1月,2021年1月\nconsole.log(date);\n```\n练习1：写一个sleep()函数\n```js\nfunction mySleep(t) {\n    var now = (new Date()).getTime();\n    while(((new Date()).getTime()-now)<t){\n        continue;\n    }\n}\n```\n## 遍历\n### 遍历对象\n`for in 语句,遍历对象`\n```js\nvar obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: function () {\n    console.log(\"aa\");\n  }\n};\nfor (var prop in obj) {\n	console.log(prop, obj[prop]);        //prop 属性名  obj[prop] 属性值\n}\n```\n### 遍历数组\n#### for遍历\n```js\nvar aList = [1,2,3];\nfor(var i=0;i<aList.length;i++){\n    console.log(aList[i]);\n}\n```\n#### forEach遍历\n```js\nvar array = [\'a\', \'b\', \'c\'];\narray.forEach(function(element) {\n  console.log(element);\n});\narr.forEach(function (value, index) {\n	console.log(index, value);\n});\n```\n补充：forEach 在对 item 进行修改的时候，如果 item 是原始类型的值，item 对应的 的内存地址实际并没有变化，如果 item 是 引用类型的值，item 对应多的内存地址也没有变化，但是对应的值，已经重写了\n```js\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = [{a: 1}, {a: 2}, {a: 3}];\narr1.forEach(item => {\n    item = item * item;\n});\narr2.forEach(item => {\n    item.a = item.a * item.a;\n});\nconsole.log(arr1); // [1,2,3,4]\nconsole.log(arr2); // [{a:1},{a:4},{a:9}]\n```\nforEach和map的区别：\n\n- forEach遍历当前数组,没有返回值,不会返回新数组\n- map遍历当前数组,并且将当前数组中的元素返回给新数组,不使用return时,新数组的长度与原数组相同,但是返回对象的每个元素都是undefined;\n```js\nvar arr = [1, 2, 4, 6, 7, 8, 5, 9];\nvar arr1 = arr.map(function (t) {\nreturn ++t;\n});\nconsole.log(arr, arr1);\narr.forEach((item, i, arr) => {\narr[i] = item+1;\n})\nconsole.log(arr);       //[2, 3, 5, 7, 8, 9, 6, 10]\n```\n#### for of (ES6)\n允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构\n不允许遍历 对象\n```js\nvar arr = [\'nick\',\'freddy\',\'mike\',\'james\'];\nfor(var item of arr){	\n    console.log(item);\n}\n```\n#### Array map()方法\n`var ret = arr.map()`可以返回一个新数组\n**map() 和 forEach() 的区别**\n\n1. forEach遍历当前数组,没有返回值,不会返回新数组\n1. map遍历当前数组,并且将当前数组中的元素返回给新数组,\n1. 不使用return时,新数组的长度与原数组相同,但是返回对象的每个元素都是undefined;\n\n示例：\n```js\nvar arr = [1, 2, 4, 6, 7, 8, 5, 9];\nvar newArr = arr.map(function (item) {\n    console.log(item);     //1 2 4 6 7 8 5 9\n});\n//遍历两个数组\nvar numbers = [1, 2, 3];\nvar letters = [\"a\", \"b\", \"c\"];\nvar newList = letters.map(function (currentValue, index, arr){\n    var item = {\n        name:currentValue,\n        value:numbers[index]\n    }\n    return item;\n})\nconsole.log(newList, numbers, letters);\n```\n示例2：\n```js\n//修改产品数量为随机数,求出每个产品的总价\nvar data = [\n    {id: 1001, icon: \"img/1.png\", name: \"餐饮0\", num: 1, price: 10},\n    {id: 1002, icon: \"img/2.png\", name: \"餐饮1\", num: 1, price: 20},\n    {id: 1003, icon: \"img/3.png\", name: \"餐饮2\", num: 1, price: 30},\n    {id: 1004, icon: \"img/4.png\", name: \"餐饮3\", num: 1, price: 40},\n    {id: 1005, icon: \"img/5.png\", name: \"餐饮4\", num: 1, price: 50},\n    {id: 1006, icon: \"img/6.png\", name: \"餐饮5\", num: 1, price: 60},\n    {id: 1007, icon: \"img/7.png\", name: \"餐饮6\", num: 1, price: 70},\n    {id: 1008, icon: \"img/8.png\", name: \"餐饮7\", num: 1, price: 80},\n    {id: 1009, icon: \"img/9.png\", name: \"餐饮8\", num: 1, price: 90},\n    {id: 1010, icon: \"img/10.png\", name: \"餐饮9\", num: 1, price: 100}\n];\ndata.forEach(function (item) {\n    item.num = parseInt(Math.random() * 9 + 1); //1-9 所有整数\n    item.sum = item.num * item.price;\n});\nconsole.log(data);\nvar newData = data.map(function (item) {\n    item.num = parseInt(Math.random() * 9 + 1); //1-9 所有整数\n    item.sum = item.num * item.price;\n    return item;\n});\nconsole.log(newData);\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338589-14f78e1f-ff47-4bb3-908d-f23024b8dbc7.png#height=430&id=kvEkw&originHeight=430&originWidth=500&originalType=binary&ratio=1&status=done&style=none&width=500)\n#### Array filter()方法\n对数组每一项进行判断，满足过滤条件的留下保存到新数组，原数组不变\n```js\nlet arr = [1,2,3];\nlet tt = arr.filter(function(i){\n    return i>1;\n});\nconsole.log(tt);    //[2,3]\nconsole.log(arr);   //[1,2,3]\n```\n#### Array reduce()方法\n累计操作，一般用于数组求和、求阶乘运算。就是前一次遍历的结果，作为后一次遍历的输入\n语法：\n```\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n如果没有initValue值:\n开始的时候，total初始值是arr[0],currentValue就是arr[1],currentIndex是从1开始\n如果有initValue值:\n开始的时候，total初始值是initialValue,currentValue就是arr[0],currentIndex是从0开始\n```\n示例1：\n```js\nvar arr = [1, 2, 4, 6, 7, 8, 5, 9];\nvar s = arr.reduce(function (sum, item, index) {\nconsole.log(sum, item, index);\nreturn sum + item;\n});\nconsole.log(s);   //1+2+4+6+7+8+5+9=42\n```\n打印：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338665-70d67473-ef62-453d-948a-439d27e8225f.png#height=165&id=qIJ1g&originHeight=165&originWidth=81&originalType=binary&ratio=1&status=done&style=none&width=81)\n示例2：\n```js\nvar arr = [1, 2, 4, 6, 7, 8, 5, 9];\n// arr是实例.动态方法\nvar s = arr.reduce(function (sum, item, index) {\n    console.log(sum, item, index);\n    return sum + item;\n}, -10); //设置初始值,index就从0开始，sum开始就是-10\nconsole.log(s);		//-10+1+2+4+6+7+8+5+9=32\n```\n打印：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338730-28479bf9-3608-402d-8018-c8dce385f60e.png#height=181&id=zlCa6&originHeight=181&originWidth=104&originalType=binary&ratio=1&status=done&style=none&width=104)\n#### Array some()方法\nsome() 方法用于检测数组中是否存在元素满足指定条件（函数提供）。只要有一个元素满足则返回true，并不再\n继续往下判断,不改变原数组。\n```js\nlet arr = [1,2,3];\nlet tt = arr.some(function(i){\n    return i>1;\n})\n// 检测数组中元素是否有大于1的值\nconsole.log(tt);// true\n```\n#### Array every()方法\nevery() 方法用于检测数组中是否所有元素都符合指定条件，返回 boolen。\n```js\nlet arr = [1,2,3];\nlet tt = arr.every(function(i){\n return i>1;\n})\nconsole.log(tt);// false\n```\n#### jQuery的$.each()方法\n既可以遍历数组，也可以遍历对象。在遍历对象时可以很容易获取对象属性名。\n```js\n//遍历对象\nvar obj={key1:\'a\',key2:\'b\',key3:\'c\'};\n$.each(obj,function(key,value){  			\n    //遍历键值对\n    console.log(key+\'````\'+value);\n})\n//遍历数组\nvar arr1=[\'aa\',\'bb\',\'cc\',\'dd\'];\n$.each(arr1,function(index,value){ \n    //两个参数，第一个参数表示遍历的数组的下标，第二个参数表示下标对应的值\n    console.log(index+\'```````\'+value);\n}\n```\n当然`$.each()`处理DOM元素也是非常方便的\n```js\n<input name=\"aaa\" type=\"hidden\" value=\"111\" />\n<input name=\"bbb\" type=\"hidden\" value=\"222\" />\n<input name=\"ccc\" type=\"hidden\" value=\"333\" />\n<input name=\"ddd\" type=\"hidden\" value=\"444\"/>\n    \n$.each($(\'input:hidden\'),function(index,item){\n	...\n})\n```\n`$.each()`遍历的另一种写法：\n```js\n$(\"input:hidden\").each(function(i,val){  //第一个参数表示索引，第二个参数表示当前元素\n    console.log(i);\n    console.log(val.name);\n    console.log(val.value);       \n});\n```\n# HTML\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTAyMjEwNTcxMjItMzUyOTk2ODM3LnBuZw?x-oss-process=image/format,png#height=485&id=OFmWW&originHeight=485&originWidth=1149&originalType=binary&ratio=1&status=done&style=none&width=1149)\n# 面试题\n## 前端基础\n### 网站发展的几个阶段\n1.后端路由阶段\n> 早期的网站开发整个HTML页面是由服务器端来渲染的，服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.\n> 但是, 一个网站, 这么多页面服务器如何处理呢?\n> 一个页面有自己对应的网址, 也就是URL.\n> URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.\n> Controller进行各种处理, 最终生成渲染好的HTML或者数据, 返回给前端。这就完成了一个IO操作.\n> 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端.\n> 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO(Search Engine Optimization)的优化.\n> 后端路由的缺点:\n> 一种情况是整个页面的模块由后端人员来编写和维护的.\n> 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.\n> 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.\n\n2.前端路由阶段\n> 前后端分离阶段：\n> 随着Ajax的出现, 有了前后端分离的开发模式.\n> 后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中.\n> 这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.\n> 并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.\n> 目前很多的网站依然采用这种模式开发。\n> 前端路由的核心是什么呢？\n> 改变URL，但是页面不进行整体的刷新。使用ajax请求数据 然后局部渲染到页面\n\n3.单页面富应用阶段\n> Single Page Appication\n> 其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由\n> 也就是前端来维护一套路由规则.\n> - HTML5的history模式：pushState\n> \nhistory接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.\n> history.pushState()    ---堆栈模式\n> ![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338799-56ee5d3e-488c-4b82-9ec9-4fdb6a870de1.png#height=325&id=ktO91&originHeight=325&originWidth=531&originalType=binary&ratio=1&status=done&style=none&width=531)\n> - HTML5的history模式：replaceState\n> \n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338876-2d640ec0-84bd-4eec-b378-bb658f53c4f5.png#height=345&id=DYz1A&originHeight=345&originWidth=553&originalType=binary&ratio=1&status=done&style=none&width=553)\n> - HTML5的history模式：go\n> \n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721338955-0ef43a37-b3a5-4726-a424-7b09a9c18a6d.png#height=348&id=xpGYy&originHeight=348&originWidth=658&originalType=binary&ratio=1&status=done&style=none&width=658)\n\n### websocket\n[https://www.ruanyifeng.com/blog/2017/05/websocket.html](https:_www.ruanyifeng.com_blog_2017_05_websocket)\n为什么需要 WebSocket？\n> 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n> 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。\n> 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n> 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用[\"轮询\"](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。\n> 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种。\n> 其他特点包括：\n> （1）建立在 TCP 协议之上，服务器端的实现比较容易。\n> （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n> （3）数据格式比较轻量，性能开销小，通信高效。\n> （4）可以发送文本，也可以发送二进制数据。\n> （5）没有同源限制，客户端可以与任意服务器通信。\n> （6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。\n\n### CSS布局display、position、float详解\n[https://www.jianshu.com/p/914b76bae7b5](https://www.jianshu.com/p/914b76bae7b5)\n### BFC(Block Format Context)\nBlock Format Context块级格式化上下文\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339033-9eafbf4f-8112-4053-9860-792a623a7721.png#height=374&id=jnZIW&originHeight=374&originWidth=569&originalType=binary&ratio=1&status=done&style=none&width=569)\nposition取值？\n> absolute\n> fixed\n> static\n> relative\n\n四种形成BFC最好的办法？\n	方法④\n### 性能优化\n#### 浏览器缓存策略\n[https://juejin.cn/post/6844903593275817998](https://juejin.cn/post/6844903593275817998)\n强缓存\n	Cache-Control：主要用于控制网页缓存\n> public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n> private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n> no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n> no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n> max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n\n	Expires：过期时间\n协商缓存\n### 从浏览器输入URL到页面展示过程发生了什么？\n[https://juejin.cn/post/6844904114506170381](https://juejin.cn/post/6844904114506170381)\n\n- 解析输入URL\n- 请求过程\n   - DNS解析\n   - 建立TCP连接\n- 开始渲染\n   - 根据Content-Type 进行解析\n   - 构建DOM树\n   - 构建CSSOM树\n   - 加载JavaScript\n   - 生成Render树\n   - 布局layer：计算元素坐标 尺寸\n   - 光栅化 opacity gpu  、显示\n### 跨域解决方案\n同源策略：[http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html](http:_www.ruanyifeng.com_blog_2016_04_same-origin-policy)\n[https://segmentfault.com/a/1190000011145364](https://segmentfault.com/a/1190000011145364)\n1、 通过jsonp跨域 ：dataType：jsonp    jsonpCallback：myCallback\njsonp缺点：只能实现get一种请求。\n2、 document.domain + iframe跨域\n> 此方案仅限主域相同，子域不同的跨域应用场景。\n> [http://www.domain.com/a.html](http:_www.domain.com_a)\n> [http://child.domain.com/b.html](http:_child.domain.com_b)\n\n3、 location.hash + iframe\n4、 window.name + iframe跨域\n5、 postMessage跨域\n> postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n> a.） 页面和其打开的新窗口的数据传递\n> b.） 多窗口之间消息传递\n> c.） 页面与嵌套的iframe消息传递\n> d.） 上面三个场景的跨域数据传递\n> 用法：postMessage(data,origin)方法接受两个参数\n> data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\n> origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n> [http://www.domain1.com/a.html](http:_www.domain1.com_a)\n> [http://www.domain2.com/b.html](http:_www.domain2.com_b)\n\n6、 跨域资源共享（CORS）\n> 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。\n> 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。\n> 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。\n\n7、 nginx代理跨域\n8、 nodejs中间件代理跨域\n9、 WebSocket协议跨域\n### 区分Cookie, Session，localStorage, sessionStorage\n参考：\n[https://www.cnblogs.com/pengc/p/8714475.html](https://www.cnblogs.com/pengc/p/8714475.html)\n[https://juejin.cn/post/6844903587764502536](https://juejin.cn/post/6844903587764502536)\n#### 比较localStorage和sessionStorage\n**两者的共同点在于：**\n1、存储大小均为5M左右\n2、都有同源策略限制\n3、仅在客户端中保存，不参与和服务器的通信\n**两者的不同点在于：**\n> 1、`生命周期` —— 数据可以存储多少时间\n> - localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。\n> - sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。\n> \n2、`作用域` —— 谁拥有数据的访问权\n> - localStorage: 在同一个浏览器内，`同源文档`之间共享 localStorage 数据，可以互相读取、覆盖。\n> - sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。\n> \n为了更好的理解`sessionStorage`,我们来看个例子：\n> 例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的`iframe`元素的话，这两个`iframe`的 sessionStorage 是可以互通的。\n\n```js\n//sessionStorage用法相同\nlocalStorage.setItem(\"name\",1);   // 以\"x\"为名字存储一个数值\nlocalStorage.getItem(\"name\");     // 获取数值\nlocalStorage.key(i);              // 获取第i对的名字\nlocalStorage.removeItem(\"name\");  // 获取该对的值\nlocalStorage.clear();             // 全部删除\n```\n#### Cookie\n##### 基本概念\nCookie是小甜饼的意思，主要有以下特点：\n1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右\n2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作\nCookie承担的较少了\n3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效\n4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n5、原生API不如storage友好，需要自己封装函数\n##### 用法(API)\n服务端向客户端发送的cookie(HTTP头,不带参数)：\n`Set-Cookie: <cookie-name>=<cookie-value>` (name可选)\n服务端向客户端发送的cookie(HTTP头，带参数)：\n`Set-Cookie: <cookie-name>=<cookie-value>;(可选参数1);(可选参数2)`\n客户端设置cookie：\n```js\ndocument.cookie = \"<cookie-name>=<cookie-value>;(可选参数1);(可选参数2)\"\n```\n可选参数：\n> `Expires=<date>`：cookie的最长有效时间，若不设置则cookie生命期与会话期相同\n> `Max-Age=<non-zero-digit>`：cookie生成后失效的秒数\n> `Domain=<domain-value>`：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。\n> `Path=<path-value>`：指定一个URL，例如指定path=/docs，则”/docs”、”/docs/Web/“、”/docs/Web/Http”均满足匹配条件\n> `Secure`：必须在请求使用SSL或HTTPS协议的时候cookie才回被发送到服务器\n> `HttpOnly`：客户端无法更改Cookie，客户端设置cookie时不能使用这个参数，一般是服务器端使用\n\n示例：\n```js\nSet-Cookie: sessionid=aes7a8; HttpOnly; Path=/\ndocument.cookie = \"KMKNKK=1234;Sercure\"\n```\n#### Session\n##### 基本概念\nSession是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟\n踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。\n在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是\nSession ID变了，服务器端可能还是存着你上次的SessionID及其Session信息，只是他们是无主状态，也许一段\n时间后会被删除。\n大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户\n端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器\n**与Cookie的关系与区别：**\n> 1、`Session`是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，`Cookie`是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。\n> 2、`Cookie`的`安全性`一般，他人可通过分析存放在本地的`Cookie`并进行`Cookie`欺骗。在安全性第一的前提下，选择`Session`更优。重要交互信息比如权限等就要放在`Session`中，一般的信息记录放`Cookie`就好了。\n> 3、单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。\n> 4、当访问增多时，`Session`会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。\n> 5、`Session`的运行依赖`Session ID`，而`Session ID`是存在 Cookie 中的。也就是说，如果浏览器禁用了`Cookie`,`Session`也会失效（但是可以通过其它方式实现，比如在`url`中传递`Session ID`,即sid=xxxx）。\n\n### CSRF跨站请求伪造的防御手段\n> 1. 尽量使用POST，限制GET\n> \nGET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。\n> 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。\n> 2. 浏览器Cookie策略\n> \nIE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。\n> PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。\n> PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。\n> 3. 加验证码\n> \n验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。\n> 4. Referer Check\n> \nReferer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。\n> 但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。\n> 5. Anti CSRF Token\n> \n现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。\n> 例子：\n> 1. 用户访问某个表单页面。\n> 1. 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。\n> 1. 在页面表单附带上Token参数。\n> 1. 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。\n> \n这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。\n\n## JavaScript\n### defineProperty\n[https://segmentfault.com/a/1190000007434923](https://segmentfault.com/a/1190000007434923)\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTIxMDUyMDUyNTQtMjA2NTIwODIzNS5wbmc?x-oss-process=image/format,png#height=504&id=RuOME&originHeight=504&originWidth=422&originalType=binary&ratio=1&status=done&style=none&width=422)![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTIxMDUyMzk5MTgtMTcwOTY2MTkxNi5wbmc?x-oss-process=image/format,png#height=515&id=ywuAz&originHeight=515&originWidth=496&originalType=binary&ratio=1&status=done&style=none&width=496)\n> value：对应的值，默认为undefined。\n> writable：是否可以被重写。默认为false。用内部方法也不可被修改\n> enumeable：此属性是否可以被枚举到（注意这个说法，“被枚举到”，当你用for in或object.keys()的时候能不能被枚举出来）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。\n> configurable：是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTIxMDU4MzY1ODYtMjIyNjM5MzIzLnBuZw?x-oss-process=image/format,png#height=375&id=ZesxC&originHeight=375&originWidth=602&originalType=binary&ratio=1&status=done&style=none&width=602)\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTIxMDU5MDk0NTQtMTA2NDI3ODMxNC5wbmc?x-oss-process=image/format,png#height=762&id=mXnvh&originHeight=762&originWidth=802&originalType=binary&ratio=1&status=done&style=none&width=802)\n### js监听对象属性的改变\n#### vue3为什么要用proxy替代defineProperty?\n[https://juejin.cn/post/6884851623382745102](https://juejin.cn/post/6884851623382745102)\n1、在使用vue2的时候，我们经常会碰到一个问题，添加新的对象属性`obj.a = 1`会无法被vue2劫持，必须使用\nvue2提供的`$set`方法来进行更新，这个的原因想必大家也都清楚，因为defineProperty只能对当前对象的属\n性进行劫持，新增的属性无能为力\n2、`Object.defineProperty`在数组上面天然存在劣势\n### 相等运算符`==`和严格相等运算符`===`\n\n1. 严格相等运算符‘===’\n- 先比较两个值的类型，如不同，直接返回false\n- 同一类型的原始类型的值（Number、string、boolean），如果相同就返回true，否则返回false\n- 若是引用类型（比如，对象、数组），比较双方所指向的地址是否相等\n```js\n{} === {} // false\n[] === [] // false\n(function () {} === function () {}) // false\n```\n上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。\n原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数\n组、空函数的值，都存放在不同的内存地址，结果当然是false\n注意：NaN与任何值都不相等，包括自身。\nNaN === NaN  // false\n\n2. 严格不相等运算符\n```js\na !== b 等价于\n!(a === b)\n```\n\n3. 相等运算符\n- 若两个值类型相同，等价于严格相等\n- 若类型不同，对于**原始类型值之间的比较会先转换为数值类型**\n```js\n1 == true // true\n// 等同于 1 === Number(true)\n \n0 == false // true\n// 等同于 0 === Number(false)\n \n2 == true // false\n// 等同于 2 === Number(true)\n \n2 == false // false\n// 等同于 2 === Number(false)\n \n\'true\' == true // false\n// 等同于 Number(\'true\') === Number(true)\n// 等同于 NaN === 1\n \n\'\' == 0 // true\n// 等同于 Number(\'\') === 0\n// 等同于 0 === 0\n \n\'\' == false  // true\n// 等同于 Number(\'\') === Number(false)\n// 等同于 0 === 0\n \n\'1\' == true  // true\n// 等同于 Number(\'1\') === Number(true)\n// 等同于 1 === 1\n \n\'\\n  123  \\t\' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格\n```\n\n- 若类型不同，对于**原始类型和引用类型之间，会把引用类型转换为原始类型**\n```js\n// 对象与数值比较时，对象转为数值\n[1] == 1 // true\n// 等同于 Number([1]) == 1\n \n// 对象与字符串比较时，对象转为字符串\n[1] == \'1\' // true\n// 等同于 String([1]) == \'1\'\n[1, 2] == \'1,2\' // true\n// 等同于 String([1, 2]) == \'1,2\'\n \n// 对象与布尔值比较时，两边都转为数值\n[1] == true // true\n// 等同于 Number([1]) == Number(true)\n[2] == true // false\n// 等同于 Number([2]) == Number(true)\n原文链接：https://blog.csdn.net/swallowblank/article/details/90703030\n```\n### `==`和`===`以及Object.is的区别\n> `==`：等同，比较运算符，两边值类型不同的时候，先进行类型转换，再比较；\n> `===`：恒等，严格比较运算符，不做类型转换，类型不同就是不等；\n> Object.is()是ES6新增的用来比较两个值是否严格相等的方法，与===的行为基本一致。\n> 先说= = =，这个比较简单，只需要利用下面的规则来判断两个值是否恒等就行了：\n> - 如果类型不同，就不相等\n> - 如果两个都是数值，并且是同一个值，那么相等；\n> - 值得注意的是，如果两个值中至少一个是NaN，那么不相等（判断一个值是否是NaN，可以用isNaN()或Object.is()来判断）。\n> - 如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等。\n> - 如果两个值都是同样的Boolean值，那么相等。\n> - 如果两个值都引用同一个对象或函数，那么相等，即两个对象的物理地址也必须保持一致；否则不相等。\n> - 如果两个值都是null，或者都是undefined，那么相等。\n\n再说Object.is()，其行为与===基本一致，不过有两处不同：\n```js\n+0 === -0 //true\nNaN === NaN // false\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n```\n### 说一下类的创建和继承?\n[https://www.nowcoder.com/tutorial/96/7a253a443122467b8d022ca88d33ec62](https://www.nowcoder.com/tutorial/96/7a253a443122467b8d022ca88d33ec62)\n### BOM对象和DOM对象\nBOM-Browser Object Modal 浏览器对象模型，即window对象\nwindow 是客户端浏览器对象模型的基类，window 对象是客户端 [JavaScript](http://c.biancheng.net/js/) 的全局对象。一个 window 对象实\n际上就是一个独立的窗口，对于框架页面来说，浏览器窗口每个框架都包含一个 window 对象。\n参考：\n\n1. [JS window对象详解](http:_c.biancheng.net_view_5832)\n1. [JS navigator对象详解](http:_c.biancheng.net_view_5834)\n1. [JS location对象详解](http:_c.biancheng.net_view_5835)\n1. [JS history对象详解](http:_c.biancheng.net_view_5836)\n1. [JS screen对象详解](http:_c.biancheng.net_view_5838)\n1. [JS document对象详解](http:_c.biancheng.net_view_5840)\n1. [使用隐藏框架加载远程JS脚本（调用远程函数）](http:_c.biancheng.net_view_5841)\n1. [使用隐藏框架实现异步交互](http:_c.biancheng.net_view_5842)\n1. [使用浮动框架实现JS异步通信](http:_c.biancheng.net_view_5860)\n1. [JS实现无刷新图片预览](http:_c.biancheng.net_view_5873)\n1. [JS实现可回退的画板](http:_c.biancheng.net_view_5875)\n### window对象方法\n```js\n//窗口内部宽高,不含工具栏,地址栏等内容,包含滚动条\nconsole.log(window.innerWidth,window.innerHeight);  //1920 150\n//当前可视窗口(展示内容)宽高包含工具等.\nconsole.log(window.outerWidth,window.outerHeight);  //1920 1040\n//窗口当前的位置(浏览器左上角到电脑屏幕左上角),只能获取,不能设置\nconsole.log(window.screenLeft,window.screenTop);    //0 0\n//http://localhost:63342/%E8%8...9%E8%82%B2)/0301-...1BOM.html?_ijt=38pjfeiv477f2c1objt938vptt\nconsole.log(location.hash);     //获取地址栏中#后面内容    \nconsole.log(location.search);       //获取地址栏中?后面的内容（包括?）\nconsole.log(location.hostname);		//域名localhost\nconsole.log(location.pathname);	//目录/JavaScript%E5%85%A5%...0%81BOM.html\nconsole.log(location.port);	//端口号 63342\nconsole.log(location.protocol);	//协议 http:\n//相当于设备屏幕宽高\nconsole.log(screen.availWidth,screen.availHeight);  //不带屏幕下面的系统部件\nconsole.log(screen.width,screen.height);    //包含系统部件(包含工具栏)\nconsole.log(navigator.userAgent);   //Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36\nconsole.log(navigator.appName);     //Netscape\nconsole.log(navigator.appVersion);  //5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36\nconsole.log(navigator.platform);    //Win32\n```\n### onclick与addEventListener区别？\n1、onclick事件在同一时间只能指向唯一的事件处理器\n2、addEventListener给一个对象注册多个listener，如click blur change等等\n3、addEventListener对任何DOM都是有效的，而onclick仅限于HTML\n4、addEventListener可以控制listener的触发阶段（捕获/冒泡）。\n5、多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除\n6、通过addEventListener添加的事件必须通过相对应的为removeListener注销事件，但是如果像上面的用匿名函数的方式注册的事件，不能使用removeListener注销，因为没用对应事件的引用。\n所以注册事件如果需要取消，最好使用一个引用，即：\n6、IE9使用attachEvent和detachEvent\n[https://blog.csdn.net/viewyu12345/article/details/79171215](https://blog.csdn.net/viewyu12345/article/details/79171215)\n### 预编译-变量和函数提升\n题目：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339111-b5a48ca2-e4d7-4a04-ab37-6a769b28341c.png#height=413&id=dgTN5&originHeight=413&originWidth=284&originalType=binary&ratio=1&status=done&style=none&width=284)\n答案：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339185-41e2715f-f6ed-4b1b-8bf7-9ce1589beabd.png#height=402&id=Ywlgq&originHeight=402&originWidth=363&originalType=binary&ratio=1&status=done&style=none&width=363)\n### this指向\n完全理解this\n[https://blog.csdn.net/cjgeng88/article/details/79846670](https://blog.csdn.net/cjgeng88/article/details/79846670)\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339258-6803f1ac-bd36-4564-8468-5b0ec858a2f7.png#height=502&id=Iuhng&originHeight=502&originWidth=293&originalType=binary&ratio=1&status=done&style=none&width=293)\n```js\nfun()     //fun.call(window)		222\na.say()		//a.say.call(a)		111\nb.say(a.say)	//222		a.say作为一个func传入  执行fun() == fun.call(window)	\nb.say()		//b.say.call(b)		333\n```\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339331-7a434114-1141-4fae-97ac-bb49150059af.png#height=522&id=XNxQq&originHeight=522&originWidth=532&originalType=binary&ratio=1&status=done&style=none&width=532)\n#### 箭头函数this\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339408-8a0cac66-fbb6-4c6c-b780-72c83b1b231c.png#height=618&id=AqQNm&originHeight=618&originWidth=754&originalType=binary&ratio=1&status=done&style=none&width=754)\n```js\n//箭头函数this\nvar num = 222;\nvar obj = {\n    num:111,\n    say: () =>{\n        console.log(num);\n    }\n}\nobj.say()			//222\nvar obj2 = {\n    num:333,\n    getNum:function () {\n        num = 10;\n        var a = this.num;\n        console.log(a);		//333\n        var fn = () => 100+this.num;		//100+333\n        return fn();\n    }\n}\nconsole.log(obj2.getNum());		//433\n```\n### 冒泡/捕获\n#### 事件冒泡\n微软提出了名为**事件冒泡**(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。\n因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是\n**p -> div -> body -> html -> document**\n#### 事件捕获\n网景提出另一种事件流名为**事件捕获**(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\n上面的例子在事件捕获的概念下发生click事件的顺序应该是\n**document -> html -> body -> div -> p**\n**事件冒泡和事件捕获过程图：**\n![](https://user-gold-cdn.xitu.io/2019/4/16/16a2654b0dd928ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#height=357&id=b3we8&originHeight=357&originWidth=394&originalType=binary&ratio=1&status=done&style=none&width=394)\n1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段；\n```js\nelement.addEventListener(event, function, useCapture)\n//useCapture参数：\n//true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）\n//false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）\n```\n#### 事件代理\n我们想要在点击每个 li 标签时，输出li当中的颜色 。常规做法是遍历每个 li ,然后在每个 li 上绑定一个点击事件：\n这种做法在 li 较少的时候可以使用，但如果有一万个 li ，那就会导致性能降低\n这时就需要事件代理出场了，利用事件流的特性，我们只绑定一个事件处理函数也可以完成（少了遍历所有 li 节\n点的操作，性能上肯定更加优化）：\n```js\n<!--侦听外层容器ul 就可以达到对所有子容器的侦听-->\n<ul>\n	<li>北京</li>\n	<li>上海</li>\n	<li>广州</li>\n	<li>深圳</li>\n	<li>重庆</li>\n	<li>天津</li>\n</ul>\n<script>\n	var ul = document.getElementsByTagName(\'ul\')[0];\n	ul.addEventListener(\'click\', clickHandler);\n	function clickHandler(e) {\n        var e=e||window.event;		//兼容性的处理\n		if (e.target.constructor === HTMLUListElement) {\n			//点击的是ul\n			return;\n		} else if (e.target.constructor === HTMLLIElement) {\n			//点击的是li\n			e.target.bool = !e.target.bool;\n			if (e.target.bool) {\n				e.target.style.color = \"red\";\n			} else {\n				e.target.style.color = \"black\";\n			}\n		}\n	}\n</script>\n```\n#### 阻止事件冒泡\n**1. 给子级加 event.stopPropagation( )**\n```\n$(\"#div1\").mousedown(function(e){\n    var e=event||window.event;\n    event.stopPropagation();\n});\n```\n**2. 在事件处理函数中返回 false**\n```\n$(\"#div1\").mousedown(function(event){\n    var e=e||window.event;\n    return false;\n});\n```\n但是这两种方式是有区别的。`return false` 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。\n`event.stopPropagation()`则只阻止事件往上冒泡，不阻止事件本身。\n**3. event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；**\n![](https://user-gold-cdn.xitu.io/2019/5/7/16a8f8e3813c6b19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#height=902&id=Y9URG&originHeight=902&originWidth=1000&originalType=binary&ratio=1&status=done&style=none&width=1000)\n**阻止默认事件**\nform表单中submit的提交事件\n（1）event.preventDefault( )\n（2）return false\n### 深浅拷贝\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339504-12a15438-6520-4394-9d15-72f65ddb46c0.png#height=592&id=wlDfv&originHeight=592&originWidth=610&originalType=binary&ratio=1&status=done&style=none&width=610)\n浅拷贝示例：\n```js\nvar person = {\n    name:\"xiong\",\n    hobby:[\"学习\",[\'游戏\',\'电影\',\'旅游\']]\n}\nfunction shallowCopy(obj) {\n    var ret = {}\n    for(var o in obj){\n        if(obj.hasOwnProperty(o)){\n            ret[o] = obj[o]\n        }\n    }\n    return ret;\n}\nvar p2 = shallowCopy(person)\np2.name = \"zhang\"\np2.hobby[0] = \"英语\"\np2.hobby[1][0] = \"手游\"\nconsole.log(person);		\nconsole.log(p2);\n```\nperson.name是基本数据类型，浅拷贝时直接在堆内存中复制一份，p2.hobby是引用数据类型 浅拷贝时 指向同一个内存地址\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339615-cd6d0c9a-7340-452c-84c4-7d36d01101de.png#height=293&id=C1LKW&originHeight=293&originWidth=338&originalType=binary&ratio=1&status=done&style=none&width=338)\n有哪些拷贝方法呢？\n> //浅拷贝\n> Object.assign()\n\n```JS\nObject.assign(div.style,{\n    width:this.WIDTH+\"px\",\n    height:this.HEIGHT+\"px\",\n    border:\"1px solid #000000\",\n    margin:\"auto\",\n    fontSize:0\n});\n```\n> concat\n> clone\n> //深拷贝\n> $.extend()			//将一个或多个对象的内容合并到目标对象\n> 	_$_.extend( [deep ], target, object1 [, objectN ] )\n> 	$.extend()方法默认是浅拷贝\n> 	要想实现深拷贝，则需要设置布尔值，这样写：$.extend(true,obj,obj1)\n> JSON.parse(JSON.stringify(o))\n\n深拷贝示例：\n```js\nvar person = {\n    name:\"xiong\",\n    hobby:[\"学习\",[\'游戏\',\'电影\',\'旅游\']]\n}\nfunction deepCopy(obj) {\n    var cloneObj = new obj.constructor()		//对象是由什么构造的\n    // var cloneObj = {}			//明确传入的是对象，如果是[]则失效，用上面的方法完美解决\n    if(obj === null) return obj;\n    if(obj instanceof Date) return new Date(obj)\n    if(obj instanceof RegExp) return new RegExp(obj)\n    if(typeof obj !== \'object\') return obj;\n    //排除掉上述4种情况后 obj就一定是个非Date 非RegExp的对象或函数function\n    for(var o in obj){\n        if(obj.hasOwnProperty(o)){\n            cloneObj[o] = deepCopy(obj[o])\n        }\n    }\n    return cloneObj;\n}\n// var p2 = deepCopy(person)\nperson.birth = new Date()\nperson.aaa = new RegExp(/\\w+/)\nperson.bbb = function () {}\nvar p2 = JSON.parse(JSON.stringify(person))\np2.name = \"zhang\"\np2.hobby[0] = \"英语\"\np2.hobby[1][0] = \"手游\"\nconsole.log(person);\nconsole.log(p2);\n```\n> JSON.parse(JSON.stringify(person)) 也能完成对象的深拷贝，但是有一些弊端\n> 比如：对象中有Date、function、RegExp等 JSON.parse会无能为力了\n\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339682-1b6413ea-4853-4fb9-a602-f904920c9fc2.png#height=395&id=Ep8J7&originHeight=395&originWidth=536&originalType=binary&ratio=1&status=done&style=none&width=536)\n### 类的创建和继承\n[https://www.nowcoder.com/tutorial/96/7a253a443122467b8d022ca88d33ec62](https://www.nowcoder.com/tutorial/96/7a253a443122467b8d022ca88d33ec62)\n### instanceof\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)\n> A instanceof B\n> 含义：B.prototype 是否在A的原型链上\n> `**instanceof**` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上\n\n```js\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nconst auto = new Car(\'Honda\', \'Accord\', 1998);\nconsole.log(auto instanceof Car);\n// expected output: true\nconsole.log(auto instanceof Object);\n// expected output: true\n```\n### 防抖和节流\n#### 防抖debounce\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339752-53d06028-fb6b-4858-825f-6291903b6288.png#height=447&id=NrfP8&originHeight=447&originWidth=542&originalType=binary&ratio=1&status=done&style=none&width=542)\n闭包：函数里面return函数\n```js\nfunction debounce(callback,delay) {\n    let timer;\n    return function (arg) {\n        clearTimeout(timer)\n        timer = setTimeout(function () {\n            callback(arg)\n        },delay)\n    }\n}\nfunction fn(value) {\n    console.log(value);\n}\n//debounceFn 是debounce内部返回的函数对象，timer一直被保留在内存中\n//下一次触发事件时离上一次事件触发时间小于delay 先清除timer 然后重新启动定时器\n//如果间隔时间大于delay 执行callback\nlet debounceFn = debounce(fn,1000)\ndocument.getElementById(\"inputName\").addEventListener(\"keyup\",function (e) {\n    debounceFn(e.target.value)\n})\n```\n#### 节流throttle\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339843-73e18e7e-b5b5-4de2-895d-fd82bd48b7bb.png#height=154&id=QHUlT&originHeight=154&originWidth=466&originalType=binary&ratio=1&status=done&style=none&width=466)\n代码：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339916-c2ca1911-4849-4ead-8509-680730dc8ed5.png#height=424&id=uvt5G&originHeight=424&originWidth=534&originalType=binary&ratio=1&status=done&style=none&width=534)\n小结：\n> 防抖和节流都是防止频繁DOM操作对cpu资源的浪费，都是运用闭包来缓存变量\n\n#### 图片懒加载\n防抖和节流的应用比较多的就是图片懒加载\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721339998-92555de9-0577-448b-bfd6-b44c08bd8806.png#height=455&id=RToc5&originHeight=455&originWidth=444&originalType=binary&ratio=1&status=done&style=none&width=444)\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340071-45adfd0e-5024-4b00-8070-e3ff1a4fcc68.png#height=554&id=BTyXm&originHeight=554&originWidth=648&originalType=binary&ratio=1&status=done&style=none&width=648)\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340148-0b2eb7b9-b1ad-4148-841d-30a048f0129e.png#height=642&id=Xr4bq&originHeight=642&originWidth=648&originalType=binary&ratio=1&status=done&style=none&width=648)\n### JS作用域\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340229-632d315a-6f6d-46d5-baf2-a053194eb6ba.png#height=432&id=O5kMm&originHeight=432&originWidth=664&originalType=binary&ratio=1&status=done&style=none&width=664)\n#### 预编译理解\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340327-58a7052f-c175-4f46-a396-a5e2ef088e4d.png#height=185&id=CVHat&originHeight=185&originWidth=485&originalType=binary&ratio=1&status=done&style=none&width=485)\n练习一道题目：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340399-a6b30b4d-2141-477e-a8ae-9e404b65a8d8.png#height=561&id=afLxn&originHeight=561&originWidth=502&originalType=binary&ratio=1&status=done&style=none&width=502)\n#### 闭包实现单例模式\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340481-c31e60ff-5f2f-4e15-aded-4a9712ce4dc2.png#height=438&id=q9orO&originHeight=438&originWidth=488&originalType=binary&ratio=1&status=done&style=none&width=488)\n### 深入浅出apply、call、bind\n[https://www.cnblogs.com/coco1s/p/4833199.html](https:_www.cnblogs.com_coco1s_p_4833199)\nbind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向\n总结：\n\n- apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；\n- apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；\n- apply 、 call 、bind 三者都可以利用后续参数传参；\n- bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。\n### Js面试常见小问题\n#### Js语言特点\n单线程的非阻塞的脚本语言、解释性语言\n> javascript单线程的原因？\n> js离不开用户的操作，其单线程的设计与其用途相关，比如对一个dom操作如果两个线程一个改变样式 一个删除该DOM那么该以哪个线程为主呢...，因此其设计是同一时间做一件事情\n> 单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。\n> 而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。\n\n#### arguments对象是什么？\n> 类数组对象，有length属性 但是没有数组的一些方法concat slice map filter\n> 类数组对象转化为数组：\n> 	1）es6的 ... 展开运算符`...arguments`，原理是iterator\n> 	2）Array.prototype.slice.call(arguments)\n> 注意：箭头函数没有arguments对象\n\n#### 为什么在调用函数时 代码中的 b 会变成全局变量？\n```js\nfunction fn(){\n    let a = b = 1;\n    //相当于\n    let a = (b = 1)		//b没有定义 name会在全局定义一个var b\n}\n```\n#### var  let  const的区别是什么？\n#### js延迟加载的方式有哪些？\n[https://www.jianshu.com/p/a6762c3fd9fa](https://www.jianshu.com/p/a6762c3fd9fa)\n> js实现延迟加载的几种方法，js的延迟加载有助与提高页面的加载速度\n> JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。\n> 一般有以下几种方式：\n> [defer 属性](https://blog.csdn.net/meijory/article/details/76389762#1-defer-%E5%B1%9E%E6%80%A7)\n> [async 属性](https://blog.csdn.net/meijory/article/details/76389762#2-async-%E5%B1%9E%E6%80%A7)\n> [动态创建DOM方式](https://blog.csdn.net/meijory/article/details/76389762#3%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAdom%E6%96%B9%E5%BC%8F)\n> [使用jQuery的getScript方法](https://blog.csdn.net/meijory/article/details/76389762#4%E4%BD%BF%E7%94%A8jquery%E7%9A%84getscript%E6%96%B9%E6%B3%95)\n> [使用setTimeout延迟方法](https://blog.csdn.net/meijory/article/details/76389762#5%E4%BD%BF%E7%94%A8settimeout%E5%BB%B6%E8%BF%9F%E6%96%B9%E6%B3%95)\n> [让JS最后加载](https://blog.csdn.net/meijory/article/details/76389762#6%E8%AE%A9js%E6%9C%80%E5%90%8E%E5%8A%A0%E8%BD%BD)\n> //把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度\n\n```\n<script defer=\"defer\"></script>\n<script async></script>\n```\n#### 简单介绍V8引擎的垃圾回收机制\n#### 哪些操作会造成内存泄漏？\n\n- 闭包\n- 意外的全局变量\n- 被遗忘的定时器\n- 脱离DOM的引用\n\n比如通过getElementById 获取一个DOM元素 而后面这个DOM元素被删除了，内存中还保留了对该DOM的引用\n#### ECMAScript2015(ES6)有哪些新特性？\n\n- 块级作用域\n- 模板字符串\n- 箭头函数\n- 变量增强写法，对象赋值解构\n- promise\n- symbol\n- proxy\n- ... 展开运算符\n- 对象、数组、字符串的一些拓展功能\n#### Js模拟new操作符的实现\n#### Iterator是什么 有什么用？\n#### Generator函数是什么 有什么用？\n#### 说说对async/await的理解\n#### event-loop事件循环机制\n事件循环机制由三部分组成，**调用栈、微任务队列、消息队列**\n> 1、event-loop开始的时候 会从全局一行行的执行 遇到函数调用 会亚茹到调用栈中，被压入的函数被称为帧，当函数返回后会从调用栈中弹出\n> 2、js中的异步操作 比如`fetch setTimeout setInterval` 压入到调用栈中的时候，里面的消息会进入到消息队列中，消息队列会等到调用栈清空之后再执行\n> 3、promise async await的异步操作 会加入到微任务中，会在调用栈清空的时候立即执行，\n> 调用栈中加入的微任务会立即执行\n\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340559-4a690a23-c03a-466d-84bd-2176a23edcc7.png#height=377&id=j4hCL&originHeight=377&originWidth=831&originalType=binary&ratio=1&status=done&style=none&width=831)\n### 什么是高阶函数？\n[https://juejin.cn/post/6844903892124172301](https://juejin.cn/post/6844903892124172301)\n> 将函数作为参数 或者返回值是函数（函数式编程就是将函数作为另外一个函数的参数或者返回值）\n\n```\nfunction foo(params,callback) {\n	return callback(params);\n}\n```\n你或许听说过JavaScript将函数作为一等公民进行对待。这是因为在JavaScript或者其他语言里面，函数也是对象。\n在JavaScript中函数是一种特殊类型的对象。它们是`Function`对象\n`Array.prototype.map`, `Array.prototype.filter`和`Array.prototype.reduce`是JavaScript原生的高阶函数\n```js\n//map()函数会创建一个新的数组，数组里面的元素是传进来的函数(callback)调用原来数组相同位置的元素的返回值。\n//传给map()的回调函数callback接收三个参数：element,index,array\nconst arr1 = [1, 2, 3];\nconst arr2 = arr1.map(function(item) {\n  return item * 2;\n});\nconsole.log(arr2);\n//filter()函数创建一个新的数组，数组里面存储原数组里面可以通过传进来的callback测试的元素。\n//传给filter()的回调函数接收三个参数：element,index,array\nconst persons = [\n  { name: \'Peter\', age: 16 },\n  { name: \'Mark\', age: 18 },\n  { name: \'John\', age: 27 },\n  { name: \'Jane\', age: 14 },\n  { name: \'Tony\', age: 24},\n];\nconst fullAge = persons.filter(person => person.age >= 18);\nconsole.log(fullAge);\n/*reduce方法用被调用数组的元素依次作为参数调用传进来的callback然后产生一个返回值。reduce函数接收两个参数：1) reducer函数(callback), 2) 一个可选的参数intialValue作为初始值。\nreducer函数接收四个参数：accumulator, currentValue, currentIndex和sourceArray。\n如果有初始值initialValue，reducer第一次被调用的时候accumulator等于initialValue而且currentValue等于数组的第一个元素。\n如果没有初始值initialValue， reducer第一次被调用的时候accumulator等于数组里面的第一个元素，currentValue等于数组的第二个元素。*/\nconst arr = [5, 7, 1, 8, 4];\nconst sum = arr.reduce(function(accumulator, currentValue) {\n  return accumulator + currentValue;\n}, 10);		//10+5+7+1+8+4\nconsole.log(sum);\n```\n#### 自己实现一个高阶函数\n假设我们现在有一个字符串的数组，我们想把这个数组转换成一个整形的数组，这个数组里面的元素是原来数组对应位置的字符串的长度。\n```js\nconst strArray = [\'JavaScript\', \'Python\', \'PHP\', \'Java\', \'C\'];\nfunction mapForEach(arr, fn) {\n  const newArray = [];\n  for(let i = 0; i < arr.length; i++) {\n    newArray.push(\n      fn(arr[i])\n    );\n  }\n  return newArray;\n}\nconst lenArray = mapForEach(strArray, function(item) {\n  return item.length;\n});\n// 打印出 [ 10, 6, 3, 4, 1 ]\nconsole.log(lenArray);\n```\n#### 手写Array.prototype.map方法\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340639-4e3a52cb-ad5d-4f5a-ab26-7a9588542b5d.png#height=382&id=YvYTh&originHeight=382&originWidth=586&originalType=binary&ratio=1&status=done&style=none&width=586)\n### 9种前端常见的设计模式\n#### 单例模式\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340717-8c610ad1-343b-4f80-8aac-3f88ba8b6aa2.png#height=162&id=j0nxZ&originHeight=162&originWidth=666&originalType=binary&ratio=1&status=done&style=none&width=666)\n形成单例的核心是闭包，内存中保存result对象，再次创建时返回以前的，避免频繁的创建和销毁：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340813-c5772d6d-66ad-4ba3-b189-08668a1b6fb7.png#height=526&id=O56TX&originHeight=526&originWidth=515&originalType=binary&ratio=1&status=done&style=none&width=515)\nes6实现单例模式\n> es6出现以前 js其实是一门无类的语言\n> class类 可以看做是es5构造函数的语法糖，类定义的方法更像面向对象的写法，但是其方法任然是定义在prototype原型上\n> static修饰的方法 是类的静态方法 只能被类调用\n\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340900-c9207f62-95c7-4b94-a627-467bbc0cc693.png#height=477&id=HzHUY&originHeight=477&originWidth=688&originalType=binary&ratio=1&status=done&style=none&width=688)\n#### 策略模式\n### 数组扁平化处理\n就是将嵌套的多层数组 变为一维数组\n方式一：arr.flat(Infinite)\n```JS\nconst arr = [1,2,[3,4,[5,6]],7]\nvar res = arr.flat(Infinity)\n```\n方式二：JSON.Parse(\"[\"+ JSON.Stringfy() +\"]\")  正则去掉数组中“[ ]”\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721340976-851e7a20-c075-4155-9fac-2c5d4d2e8c3e.png#height=284&id=wOUx2&originHeight=284&originWidth=646&originalType=binary&ratio=1&status=done&style=none&width=646)\n方式三：递归（判断item是否是数组，如果是递归执行本函数，否则将元素加入新数组）\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341052-8a3b8956-2f6f-48de-a86f-748318909e8b.png#height=203&id=n1Wqt&originHeight=203&originWidth=633&originalType=binary&ratio=1&status=done&style=none&width=633)\n方式四：reduce+递归\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341122-7f3c8a34-61d9-4597-ba7b-fa9d101316be.png#height=154&id=ZIdwj&originHeight=154&originWidth=604&originalType=binary&ratio=1&status=done&style=none&width=604)\n### 微任务和宏任务\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MTAyMjE1NDQxNDYtMTQ4NDY2NDMxMC5wbmc?x-oss-process=image/format,png#height=463&id=X6Yit&originHeight=463&originWidth=587&originalType=binary&ratio=1&status=done&style=none&width=587)\n> 宏任务：script(整体代码), setTimeout, setInterval, setImmediate的回调是宏任务, I/O, UI rendering。\n> 微任务：Promises的回调是微任务（promise本身的函数是立刻执行）, Object.observe, MutationObserver\n> 代码执行顺序是先宏任务，再微任务，如果还有则需要开始新一轮循环宏任务、微任务。\n> 所以原代码执行顺序是：\n> 1.宏任务 script，先弹出D，new创建promise对象时的EF，然后弹出H\n> 2.微任务 promise，Promise对象执行完resolve()后.then的G\n> 3.宏任务 setTimeout的C\n> 即DEFHGC\n> 补充：\n> 1.准确的说是先执行宏任务，如果有回调就丢到宏任务队列。\n> 2.再执行微任务，如果有回调就丢到微任务队列。\n> 3.检查微任务队列，非空就执行。\n> 4.检查宏任务队列，非空就执行。\n> 5.渲染dom。\n> 6.再来一次。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTY2NDczLzIwMTkwNC85NjY0NzMtMjAxOTA0MjUyMDQzMzMwMDItMjE0MDgzNDc3Ny5wbmc?x-oss-process=image/format,png#height=533&id=pkq74&originHeight=533&originWidth=390&originalType=binary&ratio=1&status=done&style=none&width=390)\n1  -  2 - 3 - be - also - 4 - test。\n## ES6\n### promise\nasync + await  是 promise +then的语法糖\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341203-79bd8412-3c86-41e6-8042-1963ad4cf632.png#height=322&id=u93zn&originHeight=322&originWidth=355&originalType=binary&ratio=1&status=done&style=none&width=355)\nasync + await 的组合可以很好的避免回调地狱\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341276-641f8a5e-0861-40f6-97b4-4660d45d8217.png#height=490&id=v4dJJ&originHeight=490&originWidth=481&originalType=binary&ratio=1&status=done&style=none&width=481)\n## Vue\n### Runtime-Compiler和Runtime-only的区别？\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341362-1a494cef-9a84-41df-8fdf-561e25be7646.png#height=263&id=nMpBr&originHeight=263&originWidth=724&originalType=binary&ratio=1&status=done&style=none&width=724)\n\n- Runtime-only比Runtime-Compiler少了将template解析成ast(抽象语法树)的过程，因此要轻6kb左右\n- 表现上：\n> Runtime-Compiler的main.js中有template，即将template替换el挂载的内容，\n> Runtime-only没有template，直接将组件App 使用render的createElement(App)渲染成虚拟DOM\n\n- 工作中用的较多的是Runtime-only，性能更高 代码更少\n\n能直接创建元素 和组件\n创建标签元素：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341439-6932fdd3-bbe5-4923-87bd-851ef694e0bf.png#height=238&id=LPS2H&originHeight=238&originWidth=952&originalType=binary&ratio=1&status=done&style=none&width=952)\n创建组件：\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341508-0bfb0aa9-ab0a-477a-a17e-5d772a71a624.png#height=191&id=uNjOE&originHeight=191&originWidth=916&originalType=binary&ratio=1&status=done&style=none&width=916)\n那么`.vue`文件中的template由谁解析呢？\nwebpack的vue-template-compiler解析xxx.vue文件中的template，我们看看组件App被解析成什么了\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341579-ccc72088-d070-486e-b3b3-ec5b54c6f464.png#height=189&id=BQSUS&originHeight=189&originWidth=682&originalType=binary&ratio=1&status=done&style=none&width=682)\n### 计算属性\n![](https://cdn.nlark.com/yuque/0/2021/png/1559629/1617721341649-a8c3b578-2537-4b3b-8be2-c30a9b175fc1.png#height=528&id=SfKko&originHeight=528&originWidth=545&originalType=binary&ratio=1&status=done&style=none&width=545)\n### watch\n### Vue响应式原理\nBilibili视频参考：[https://www.bilibili.com/video/BV15741177Eh?p=229](https://www.bilibili.com/video/BV15741177Eh?p=229)\n文章参考：[https://zhuanlan.zhihu.com/p/88648401](https://zhuanlan.zhihu.com/p/88648401)\n[https://www.cnblogs.com/fundebug/p/responsive-vue.html](https:_www.cnblogs.com_fundebug_p_responsive-vue)\n什么是响应式原理？\n**在改变数据的时候，视图会跟着更新**\nVue React前端框架之所以能够流行开来，响应式原理做出了巨大贡献。数据模型仅仅是普通的 JavaScript 对象，而当你修改它们时，视图会进行更新。\n#### 侦测数据变化\n首先有个问题，在Javascript中，如何侦测一个对象的变化？\n其实有两种办法可以侦测到变化：使用`Object.defineProperty`和ES6的`Proxy`，这就是进行数据劫持或数据代理。\n1、**Object.defineProperty**()的方法里面的setter 与getter方法\n`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。里面有两个字段 set,getset都是取设置属性的值，而get就是获取属性的值。\n2、`Proxy` 是es6 的一个新特性。`**Proxy**`** 的代理是针对整个对象的，而不是对象的某个属性**，因此不同于 `Object.defineProperty` 的必须遍历对象每个属性，`Proxy` 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，还是需要递归的。此外`**Proxy**`**支持代理数组的变化。**\n#### 发布者订阅者模式\n```js\nlet obj1 = {\n    name:\"zhangsan\",\n    age:18,\n  }\n  Object.keys(obj1).forEach(key =>{\n    Object.defineProperty(obj1,key,{\n      set(newValue){\n        console.log(\"监听属性\" + key + \" 的改变\");\n        obj1[key] = newValue\n      },\n      get(){\n        return obj1[key]\n      }\n    })\n  })\n  //发布者订阅者模式\n  class Dep{\n    constructor() {\n      this.subs = [];\n    }\n    addSub(sub){\n      this.subs.push(sub);\n    }\n    notify(){\n      this.subs.forEach(item =>{\n        item.update();\n      })\n    }\n  }\n  //观察者\n  class Watcher{\n    constructor(name) {\n      this.name = name;\n    }\n    update(){\n      console.log(this.name + \"执行了update\");\n    }\n  }\n  const dep = new Dep();\n  let w1 = new Watcher(\"苹果\")\n  dep.addSub(w1)\n  let w2 = new Watcher(\"香蕉\")\n  dep.addSub(w2)\n  dep.notify()\n```\n','原创','','','','','',3,1479452728248795137,NULL,0,0,'2022-01-08 17:28:15','2022-01-08 20:38:29'),(1479747500322709506,'【Docker】Docker从入门到精通','跟着小狂神学习Docker','https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-a62710d971c47422f25eca254b2add8a_1440w.jpg','## Docker安装\n## Docker使用\n## Docker实例\n### Docker安装CentOS\n```shell\n#拉取指定版本的 CentOS 镜像，这里我们安装指定版本为例(centos7):\n$ docker pull centos:centos7\n\n#运行容器并且可以通过exec命令进入CentOS容器\n$ docker run -itd --name centos-test centos:centos7\n\n#安装成功,最后我们可以通过 docker ps 命令查看容器的运行信息：\n```\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1638372089337-00e983d1-36cd-4826-b0e3-e46532f7e0ae.png#clientId=u5445598e-7ba4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=64&id=ua2a7a75c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=127&originWidth=1881&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87403&status=done&style=none&taskId=uceac880c-2ea9-438c-a478-85d7b63b561&title=&width=940.5)\n### Docker安装Nginx\n```shell\n#用 docker search nginx 命令来查看可用版本：\n$ docker search nginx\n\n#拉取官方的最新版本的镜像：\n$ docker pull nginx:latest\n\n#使用以下命令来查看是否已安装了 nginx：\n$ docker images\n\n#安装完成后，我们可以使用以下命令来运行nginx容器：\n$ docker run --name nginx-test -p 8080:80 -d nginx\n\n	#参数说明：\n    --name 	nginx-test：容器名称。\n    -p 	8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。\n    -d 	nginx： 设置容器在在后台一直运行。\n\n#安装成功最后我们可以通过浏览器可以直接访问 8080 端口的nginx服务：\n```\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1638372323101-31b8b875-02dd-4ff7-8572-d450763548bb.png#clientId=u5445598e-7ba4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=153&id=u062840fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1096&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39003&status=done&style=stroke&taskId=ub6fbb46c-f600-480d-b672-4dde0aabb4a&title=&width=548)\n### Docker安装Tomcat\n```shell\n#在控制台使用 docker search tomcat 命令来查看可用版本：\n$ docker search tomcat\n\n#拉取官方的镜像：\n$ docker pull tomcat\n\n\n```\n### Docker安装MySQL\n参考：[https://www.runoob.com/docker/docker-install-mysql.html](https://www.runoob.com/docker/docker-install-mysql.html)\n[https://www.cnblogs.com/sablier/p/11605606.html](https://www.cnblogs.com/sablier/p/11605606.html)\n​\n\n可以去mysql官网查看版本，还可以用 docker search mysql 命令来查看可用版本：\n```shell\n[root@localhost ~]# docker search mysql\nNAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nmysql                             MySQL is a widely used, open-source relation…   11760     [OK]       \nmariadb                           MariaDB Server is a high performing open sou…   4483      [OK]       \nmysql/mysql-server                Optimized MySQL Server Docker images. Create…   879                  [OK]\ncentos/mysql-57-centos7           MySQL 5.7 SQL database server                   92                   \nmysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   89                   \ncenturylink/mysql                 Image containing mysql. Optimized to be link…   59                   [OK]\ndataback/mysql-backup             Back up mysql databases to... anywhere!         53                   \nprom/mysqld-exporter                                                              43                   [OK]\ndeitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                   [OK]\ntutum/mysql                       Base docker image to run a MySQL database se…   35                   \nlinuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   34                   \nschickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   31                   [OK]\nmysql/mysql-router                MySQL Router provides transparent routing be…   23                   \ncentos/mysql-56-centos7           MySQL 5.6 SQL database server                   21                   \narey/mysql-client                 Run a MySQL client from a docker container      19                   [OK]\nfradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   16                   [OK]\ngenschsa/mysql-employees          MySQL Employee Sample Database                  8                    [OK]\nyloeffler/mysql-backup            This image runs mysqldump to backup data usi…   7                    [OK]\nopenshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6                    \nansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                3                    [OK]\nidoall/mysql                      MySQL is a widely used, open-source relation…   3                    [OK]\ndevilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   3                    \njelastic/mysql                    An image of the MySQL database server mainta…   2                    \ncentos/mysql-80-centos7           MySQL 8.0 SQL database server                   2                    \nwiddpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   1                    [OK]\n```\n#### 拉取MySQL镜像\n```shell\n//拉取官方的最新版本的镜像\n$ docker pull mysql:latest\n\n//指定版本\ndocker pull mysql:5.7\n```\n#### 基本操作\n```shell\n//1、查看本地镜像\n[root@localhost ~]# docker images\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        latest    ea335eea17ab   2 weeks ago   141MB\nmysql        5.7       8b43c6af2ad0   2 weeks ago   448MB\nmysql        latest    b05128b000dd   2 weeks ago   516MB\n\n//2、运行 mysql 容器\ndocker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n```\n参数说明：\n\n- -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。\n- MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。\n\n\n\n通过 docker ps 命令查看是否安装成功：\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1638370105967-f9c07c08-8b81-4002-8164-a6cb410671de.png#clientId=u48349d0a-0d16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=51&id=u6a4ef84e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=102&originWidth=1314&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15484&status=done&style=none&taskId=ud72f96e0-c1ed-4d75-ab61-178cf20fb50&title=&width=657)\n进入docker本地容器内部连接mysql客户端\ndocker exec -it mysql bash \nmysql -uroot -p123456\n​\n\n#### 使用SQLYog远程连接时的问题\n我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问：\nhost: 127.0.0.1 \nport: 3306 \nuser: root \npassword: 123456\n如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：\n```shell\n# 开放端口：\n$ systemctl status firewalld\n$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent\n$ firewall-cmd  --reload\n\n# 关闭防火墙：\n$ sudo systemctl stop firewalld\n```\n需要进入docker本地客户端设置远程访问账号\n```shell\n$ sudo docker exec -it mysql bash\n$ mysql -uroot -p123456\nmysql> grant all privileges on *.* to root@\'%\' identified by \"password\";\nmysql> flush privileges;\n\n#原理\n# mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）\n\nmysql> use mysql;\nDatabase changed\n\nmysql> select host,user,password from user;\n+--------------+------+-------------------------------------------+\n| host                    | user      | password                                                                 |\n+--------------+------+-------------------------------------------+\n| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |\n| 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |\n+--------------+------+-------------------------------------------+\n2 rows in set (0.00 sec)\n\nmysql> grant all privileges  on *.* to root@\'%\' identified by \"password\";\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> flush privileges;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select host,user,password from user;\n+--------------+------+-------------------------------------------+\n| host                    | user      | password                                                                 |\n+--------------+------+-------------------------------------------+\n| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |\n| 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |\n| %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |\n+--------------+------+-------------------------------------------+\n3 rows in set (0.00 sec)\n```\n\n\n\n\n','原创','','','','','',3,1350003757823340545,NULL,0,0,'2022-01-08 17:31:11','2022-01-12 20:38:16'),(1482341517241712642,'【Vue】axios网络请求模块','ajax的出现促进了前后端分离的开发模式，Vue.js 官方推荐使用 axios 来完成 ajax 请求','https://ae01.alicdn.com/kf/Hf5957a943fdf4b77a5130ea1900f6bf2k.png','[Axios中文网](http://www.axios-js.com/zh-cn/docs/)\n![axios](https://ae01.alicdn.com/kf/Hf5957a943fdf4b77a5130ea1900f6bf2k.png)\n## 概述\n> ajax的出现促进了前后端分离的开发模式\n> Vue.js 官方推荐使用 axios 来完成 ajax 请求。\n> Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n常见的网络请求模块，以及优缺点对比\n**JSONP的原理和封装**\n\n- \nJSONP原理回顾\n- \nJSONP请求封装\n\n**axios的内容详解**\n\n- \n认识axios网络模块\n- \n发送基本请求\n- \naxios创建实例\n- \naxios拦截器的使用\n\n\n\n**选择什么网络模块?**\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619923683421-cf818d26-cfd8-47ca-b71b-0b8ee5133819.png#clientId=ue0e2b633-c31b-4&from=paste&height=330&id=u6ff817dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=1188&originalType=binary&size=489375&status=done&style=none&taskId=ua85f5f86-ea03-490e-b93e-225a9bbf7cd&width=736)\n### JSONP\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619923731130-44c18857-7323-4578-a3b7-1e51e8c480a1.png#clientId=ue0e2b633-c31b-4&from=paste&height=314&id=u26c52acc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=706&originalType=binary&size=359305&status=done&style=none&taskId=u881251c2-14bc-472a-a3c4-44801126389&width=408) ![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619923734365-837b9600-8599-45de-a8ca-60c24b32300b.png#clientId=ue0e2b633-c31b-4&from=paste&height=411&id=u6059e696&margin=%5Bobject%20Object%5D&name=image.png&originHeight=728&originWidth=591&originalType=binary&size=55449&status=done&style=none&taskId=u392e1dcf-0a7f-4305-9eac-ae50434ecd5&width=333.5)\n**JSONP封装**\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1619923866991-c5b4091d-fc73-4763-9a4e-fbc7b260cb91.png#clientId=ue0e2b633-c31b-4&from=paste&height=568&id=uc5d3fd81&margin=%5Bobject%20Object%5D&name=image.png&originHeight=713&originWidth=630&originalType=binary&size=186122&status=done&style=none&taskId=u2efb08be-78f1-4ec6-97d0-0a44e8399e2&width=502)\n## Axios基本用法\n**Axios特性**\n\n- 从浏览器中创建[XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n- 从 node.js 创建[http](http://nodejs.org/api/http.html)请求\n- 支持[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御[XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)\n### 安装\n使用 npm:\n```powershell\nnpm install axios\n```\n使用 bower:\n```shell\nbower install axios\n```\n使用 cdn:\n```html\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n### 案例\n```javascript\n/*执行GET请求*/\n// 为给定 ID 的 user 创建请求\naxios.get(\'/user?ID=12345\')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// 上面的请求也可以这样做\naxios.get(\'/user\', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n/*执行 POST 请求*/\naxios.post(\'/user\', {\n    firstName: \'Fred\',\n    lastName: \'Flintstone\'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n//执行多个并发请求\nfunction getUserAccount() {\n  return axios.get(\'/user/12345\');\n}\n\nfunction getUserPermissions() {\n  return axios.get(\'/user/12345/permissions\');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // 两个请求现在都执行完成\n  }));\n```\n## axios API\n1、可以通过向axios传递相关配置来创建请求 `axios(config)`\n```javascript\n// 发送 POST 请求\naxios({\n  method: \'post\',\n  url: \'/user/12345\',\n  data: {\n    firstName: \'Fred\',\n    lastName: \'Flintstone\'\n  }\n});\n\n// 获取远端图片\naxios({\n  method:\'get\',\n  url:\'http://bit.ly/2mTM3nY\',\n  responseType:\'stream\'\n})\n  .then(function(response) {\n  response.data.pipe(fs.createWriteStream(\'ada_lovelace.jpg\'))\n});\n```\n2、config使用默认值，直接传入url\n```javascript\n// 发送 GET 请求（默认的方法）\naxios(\'/user/12345\');\n```\n### 请求方法的别名\n为方便起见，为所有支持的请求方法提供了别名\n##### axios.request(config)\n##### axios.get(url[, config])\n##### axios.delete(url[, config])\n##### axios.head(url[, config])\n##### axios.options(url[, config])\n##### axios.post(url[, data[, config]])\n##### axios.put(url[, data[, config]])\n##### axios.patch(url[, data[, config]])\n###### 注意:\n在使用别名方法时，url、method、data这些属性都不必在配置中指定。\n### 并发\n处理并发请求的助手函数\n##### axios.all(iterable)\n##### axios.spread(callback)\n## 创建实例\n可以使用自定义配置新建一个 axios 实例  `axios.create([config])`\n```javascript\nconst instance = axios.create({\n  baseURL: \'https://some-domain.com/api/\',\n  timeout: 1000,\n  headers: {\'X-Custom-Header\': \'foobar\'}\n});\n```\n### 实例方法\n以下是可用的实例方法，指定的配置将与实例的配置合并。\n##### axios#request(config)\n##### axios#get(url[, config])\n##### axios#delete(url[, config])\n##### axios#head(url[, config])\n##### axios#options(url[, config])\n##### axios#post(url[, data[, config]])\n##### axios#put(url[, data[, config]])\n##### axios#patch(url[, data[, config]])\n### 请求配置\n这些是创建请求时可以用的配置选项。只有url是必需的。如果没有指定method，请求将默认使用get方法。\n重点关注：\n\n- url\n- method\n- baseURL\n- headers\n- params（get请求传参）\n- data（post请求发送data）\n- timeout（请求超时时间）\n- responseType（表示服务器响应的数据类型）\n```json\n{\n  // `url` 是用于请求的服务器 URL\n  url: \'/user\',\n\n  // `method` 是创建请求时使用的方法\n  method: \'get\', // default\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: \'https://some-domain.com/api/\',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 \'PUT\', \'POST\' 和 \'PATCH\' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data, headers) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {\'X-Requested-With\': \'XMLHttpRequest\'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: \'brackets\'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 \'PUT\', \'POST\', 和 \'PATCH\'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: \'Fred\'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: \'janedoe\',\n    password: \'s00pers3cret\'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，可以是 \'arraybuffer\', \'blob\', \'document\', \'json\', \'text\', \'stream\'\n  responseType: \'json\', // default\n\n  // `responseEncoding` indicates encoding to use for decoding responses\n  // Note: Ignored for `responseType` of \'stream\' or client-side requests\n  responseEncoding: \'utf8\', // default\n\n  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: \'XSRF-TOKEN\', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: \'X-XSRF-TOKEN\', // default\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // default\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. \'/var/run/docker.sock\' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // \'proxy\' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: \'127.0.0.1\',\n    port: 9000,\n    auth: {\n      username: \'mikeymike\',\n      password: \'rapunz3l\'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n### 响应结构\n某个请求的响应包含以下信息\n```json\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: \'OK\',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n   // `config` 是为请求提供的配置信息\n  config: {},\n // \'request\'\n  // `request` is the request that generated this response\n  // It is the last ClientRequest instance in node.js (in redirects)\n  // and an XMLHttpRequest instance the browser\n  request: {}\n}\n```\n使用then时，你将接收下面这样的响应 :\n```javascript\naxios.get(\'/user/12345\')\n  .then(function(response) {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  });\n```\n在使用catch时，或传递[rejection callback](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)作为then的第二个参数时，响应可以通过error对象可被使用，正如在[错误处理](https://www.kancloud.cn/yunye/axios/234845#handling-errors)这一节所讲。\n### 配置默认值\n你可以指定将被用在各个请求的配置默认值\n#### 全局的 axios 默认值\n```javascript\naxios.defaults.baseURL = \'https://api.example.com\';\naxios.defaults.headers.common[\'Authorization\'] = AUTH_TOKEN;\naxios.defaults.headers.post[\'Content-Type\'] = \'application/x-www-form-urlencoded\';\n```\n#### 自定义实例默认值\n```javascript\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: \'https://api.example.com\'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common[\'Authorization\'] = AUTH_TOKEN;\n```\n#### 配置的优先顺序\n配置会以一个优先顺序进行合并。这个顺序是：在lib/defaults.js找到的库的默认值，然后是实例的defaults属性，最后是请求的config参数。后者将优先于前者。这里是一个例子：\n```javascript\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get(\'/longRequest\', {\n  timeout: 5000\n});\n```\n## 拦截器\n在请求或响应被then或catch处理前拦截它们。\n```javascript\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n```\n如果你想在稍后移除拦截器，可以这样：\n```javascript\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n可以为自定义 axios 实例添加拦截器\n```javascript\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n','原创','','','','','',0,1479452807638581249,NULL,0,0,'2022-01-15 21:18:52','2022-01-15 21:18:52'),(1482344609567834113,'【Vue】实现一个audio组件','HTML <audio> 元素用于在文档中嵌入音频内容，本组件教你构建一个自己的Vue-audio组件','https://ae01.alicdn.com/kf/H1b12b6ea1bf34118b5c8dee1c0cbf525F.png','参考：\n[https://segmentfault.com/a/1190000012453975](https://segmentfault.com/a/1190000012453975)\n### audio音频标签用法\n[https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio)\n​\n\n### 效果\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1620834824171-ba91c045-c1a2-40f0-9bbb-7bd3c023b2dc.png#clientId=u05aa88a1-71a8-4&from=paste&height=177&id=u1790a585&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=858&originalType=binary&size=13253&status=done&style=none&taskId=ub2ceab64-d8e9-4ebe-add0-54092273376&width=504)\n### 源码\n```vue\n<template>\n  <div class=\"di main-wrap\" v-loading=\"audio.waiting\">\n    <!-- 这里设置了ref属性后，在vue组件中，就可以用this.$refs.audio来访问该dom元素 -->\n    <audio ref=\"audio\" class=\"dn\"\n           :src=\"theUrl\"\n           :preload=\"audio.preload\"\n           controls=\"controls\"\n           @play=\"onPlay\"\n           @error=\"onError\"\n           @waiting=\"onWaiting\"\n           @pause=\"onPause\"\n           @timeupdate=\"onTimeupdate\"\n           @loadedmetadata=\"onLoadedmetadata\"\n    ></audio>\n    <div>\n      <el-button type=\"success\" @click=\"startPlayOrPause\">{{audio.playing | transPlayPause}}</el-button>\n      <el-button v-show=\"!controlList.noSpeed\" type=\"info\" @click=\"changeSpeed\">{{audio.speed | transSpeed}}</el-button>\n\n      <el-tag type=\"info\">{{ audio.currentTime | formatSecond}}</el-tag>\n\n      <el-slider v-show=\"!controlList.noProcess\"\n                 v-model=\"sliderTime\"\n                 :format-tooltip=\"formatProcessToolTip\"\n                 @change=\"changeCurrentTime\"\n                 class=\"slider\"></el-slider>\n\n      <el-tag type=\"info\">{{ audio.maxTime | formatSecond }}</el-tag>\n\n      <el-button v-show=\"!controlList.noMuted\"\n                 type=\"info\"\n                 @click=\"startMutedOrNot\">{{audio.muted | transMutedOrNot}}\n      </el-button>\n\n      <el-slider v-show=\"!controlList.noVolume\" v-model=\"volume\" :format-tooltip=\"formatVolumeToolTip\" vertical height=\"200px\"\n                 @change=\"changeVolume\" class=\"slider\"></el-slider>\n\n      <a :href=\"theUrl\" v-show=\"!controlList.noDownload\" target=\"_blank\" class=\"download\" download>下载</a>\n    </div>\n  </div>\n</template>\n\n<script>\n  function realFormatSecond(second) {\n    var secondType = typeof second\n\n    if (secondType === \'number\' || secondType === \'string\') {\n      second = parseInt(second)\n\n      var hours = Math.floor(second / 3600)\n      second = second - hours * 3600\n      var mimute = Math.floor(second / 60)\n      second = second - mimute * 60\n\n      return hours + \':\' + (\'0\' + mimute).slice(-2) + \':\' + (\'0\' + second).slice(-2)\n    } else {\n      return \'0:00:00\'\n    }\n  }\n\n  export default {\n    name: \'VueAudioMaster\',\n    props: {\n      theUrl: {\n        type: String,\n        default() {\n          return \"\"\n        }\n      },\n      theSpeeds: {\n        type: Array,\n        default() {\n          return [1, 1.5, 2]\n        }\n      },\n      theControlList: {\n        type: String,\n        default: \'\'\n      }\n    },\n\n    data() {\n      return {\n        audio: {\n          currentTime: 0,\n          maxTime: 0,\n          playing: false,\n          muted: false,   //静音\n          speed: 1,\n          waiting: true,\n          preload: \'auto\'\n        },\n\n        sliderTime: 0,\n        volume: 100,\n        speeds: this.theSpeeds,\n\n        controlList: {\n          // 不显示下载\n          noDownload: false,\n          // 不显示静音\n          noMuted: false,\n          // 不显示音量条\n          noVolume: false,\n          // 不显示进度条\n          noProcess: false,\n          // 只能播放一个\n          onlyOnePlaying: false,\n          // 不要快进按钮\n          noSpeed: false\n        }\n      }\n    },\n    methods: {\n      setControlList() {\n        let controlList = this.theControlList.split(\' \')\n        controlList.forEach((item) => {\n          if (this.controlList[item] !== undefined) {\n            this.controlList[item] = true\n          }\n        })\n      },\n      changeSpeed() {\n        let index = this.speeds.indexOf(this.audio.speed) + 1\n        this.audio.speed = this.speeds[index % this.speeds.length]\n        this.$refs.audio.playbackRate = this.audio.speed\n      },\n      startMutedOrNot() {\n        this.$refs.audio.muted = !this.$refs.audio.muted\n        this.audio.muted = this.$refs.audio.muted\n      },\n      // 音量条toolTip\n      formatVolumeToolTip(index) {\n        return \'音量条: \' + index\n      },\n      // 进度条toolTip\n      formatProcessToolTip(index = 0) {\n        index = parseInt(this.audio.maxTime / 100 * index)\n        return \'进度条: \' + realFormatSecond(index)\n      },\n      // 音量改变\n      changeVolume(index = 0) {\n        this.$refs.audio.volume = index / 100\n        this.volume = index\n      },\n      // 播放跳转\n      changeCurrentTime(index) {\n        this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime)\n      },\n      startPlayOrPause() {\n        return this.audio.playing ? this.pausePlay() : this.startPlay()\n      },\n      // 开始播放\n      startPlay() {\n        this.$refs.audio.play()\n      },\n      // 暂停\n      pausePlay() {\n        this.$refs.audio.pause()\n      },\n      // 当音频暂停\n      onPause() {\n        this.audio.playing = false\n      },\n      // 当发生错误, 就出现loading状态\n      onError() {\n        this.audio.waiting = true\n      },\n      // 当音频开始等待\n      onWaiting(res) {\n        console.log(res)\n      },\n      // 当音频开始播放\n      onPlay(res) {\n        console.log(res)\n        this.audio.playing = true\n        this.audio.loading = false\n\n        if (!this.controlList.onlyOnePlaying) {\n          return\n        }\n\n        let target = res.target\n\n        let audios = document.getElementsByTagName(\'audio\');\n\n        [...audios].forEach((item) => {\n          if (item !== target) {\n            item.pause()\n          }\n        })\n      },\n      // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间\n      onTimeupdate(res) {\n        // console.log(\'timeupdate\')\n        // console.log(res)\n        this.audio.currentTime = res.target.currentTime\n        this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100)\n      },\n      // 当加载语音流元数据完成后，会触发该事件的回调函数\n      // 语音元数据主要是语音的长度之类的数据\n      onLoadedmetadata(res) {\n        console.log(\'loadedmetadata\')\n        console.log(res)\n        this.audio.waiting = false\n        this.audio.maxTime = parseInt(res.target.duration)\n      }\n    },\n    filters: {\n      formatSecond(second = 0) {\n        return realFormatSecond(second)\n      },\n      transPlayPause(value) {\n        return value ? \'暂停\' : \'播放\'\n      },\n      transMutedOrNot(value) {\n        return value ? \'放音\' : \'静音\'\n      },\n      transSpeed(value) {\n        return \'快进: x\' + value\n      }\n    },\n    created() {\n      this.setControlList()\n    }\n  }\n\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n  .main-wrap {\n    padding: 10px 15px;\n  }\n\n  .slider {\n    display: inline-block;\n    width: 100px;\n    position: relative;\n    top: 14px;\n    margin-left: 15px;\n  }\n\n  .di {\n    display: inline-block;\n  }\n\n  .download {\n    color: #409EFF;\n    margin-left: 15px;\n  }\n\n  .dn {\n    display: none;\n  }\n\n</style>\n```\n### 目标效果\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1620915459161-87cd2a0f-191d-43bb-8c67-5cec4fd92ad2.png#clientId=u705620a1-ac4e-4&from=paste&height=31&id=ue80d53d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=54&originWidth=1329&originalType=binary&size=66638&status=done&style=none&taskId=u1e650e62-ffee-4c47-954c-b59940cb8b6&width=751)\n### 实现的效果\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/1559629/1621091239458-a21b75bb-f996-402d-9217-8c399ac3262a.png#clientId=u114448d1-5fb2-4&from=paste&height=46&id=u5e42e2f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=1091&originalType=binary&size=9741&status=done&style=none&taskId=u3f0d81a7-2fdc-4856-906a-3dbb2a29c5f&width=607.5)\n```vue\n<template>\n  <div class=\"audio-view main-wrap\" v-loading=\"audio.waiting\">\n\n      <!-- 这里设置了ref属性后，在vue组件中，就可以用this.$refs.audio来访问该dom元素 -->\n      <audio ref=\"audio\" class=\"dn\"\n             :src=\"theUrl\"\n             :preload=\"audio.preload\"\n             @play=\"onPlay\"\n             @error=\"onError\"\n             @waiting=\"onWaiting\"\n             @pause=\"onPause\"\n             @ended=\"onEnded\"\n             @timeupdate=\"onTimeupdate\"\n             @loadedmetadata=\"onLoadedmetadata\"></audio>\n      <div class=\"audio-control-container\">\n        <div class=\"item audio-play-btn\">\n          <!--上一首-->\n          <el-button type=\"success\"\n                     circle\n                     @click=\"prevClick\"\n                     style=\"font-size: 16px\"\n                     size=\"mini\"\n                     icon=\"el-icon-arrow-left\">\n          </el-button>\n\n          <!--播放-->\n          <el-button type=\"success\"\n                     circle\n                     v-if=\"audio.playing\"\n                     icon=\"el-icon-video-pause\"\n                     style=\"font-size: 16px\"\n                     size=\"small\"\n                     @click=\"startPlayOrPause\"></el-button>\n          <el-button type=\"success\"\n                     circle\n                     v-else\n                     style=\"font-size: 16px\"\n                     size=\"small\"\n                     icon=\"el-icon-video-play\"\n                     @click=\"startPlayOrPause\"></el-button>\n\n          <!--下一首-->\n          <el-button type=\"primary\"\n                     style=\"font-size: 16px\"\n                     size=\"mini\"\n                     icon=\"el-icon-arrow-right\"\n                     circle\n                     @click=\"nextClick\"></el-button>\n        </div>\n\n        <div class=\"item slider-container\">\n          <!--播放滑动条-->\n          <el-slider v-show=\"!controlList.noProcess\"\n                     v-model=\"sliderTime\"\n                     @change=\"changeCurrentTime\"\n                     class=\"play-slider\"></el-slider>\n        </div>\n\n        <div class=\"item audio-time\">\n          <!--当前播放时刻-->\n          <el-link :underline=\"false\" type=\"info\">{{ audio.currentTime | formatSecond}}/</el-link>\n\n          <!--总时长-->\n          <el-link :underline=\"false\" type=\"info\">{{ audio.maxTime | formatSecond }}</el-link>\n        </div>\n\n        <div class=\"item audio-muted\">\n          <!--静音-->\n          <span v-if=\"!audio.muted\" @click=\"startMutedOrNot\">\n          <i class=\"el-icon-microphone\" style=\"font-size: 24px\"></i>\n        </span>\n          <span v-else @click=\"startMutedOrNot\">\n          <i class=\"el-icon-turn-off-microphone\" style=\"font-size: 24px\"></i>\n        </span>\n        </div>\n\n        <!--音量-->\n        <div class=\"item volumn-container\">\n          <el-slider\n            v-show=\"controlList.noVolume\"\n            v-model=\"volume\"\n            vertical height=\"100px\"\n            @change=\"changeVolume\"\n            show-tooltip=\"false\"\n            class=\"volume-slider\">\n          </el-slider>\n\n          <i class=\"el-icon-mic\" @click=\"isShowVolume\" style=\"font-size: 22px\"></i>\n        </div>\n\n\n        <div class=\"item audio-play-speed\">\n          <!--播放速度 x1 x1.5 x2-->\n          <el-button v-show=\"!controlList.noSpeed\"\n                     type=\"default\"\n                     @click=\"changeSpeed\"\n                     style=\"font-size: 12px;padding: 5px\"\n                     size=\"mini\"\n                     icon=\"el-icon-d-arrow-right\">{{audio.speed | transSpeed}}\n          </el-button>\n        </div>\n\n        <div class=\"item audio-download\">\n          <!--下载-->\n          <el-link :href=\"theUrl\"\n                   v-show=\"!controlList.noDownload\"\n                   class=\"download\"\n                   :download=\"theUrl\">\n            <i class=\"el-icon-download\" style=\"font-size: 22px;color: white;\"></i>\n          </el-link>\n        </div>\n      </div>\n  </div>\n</template>\n\n<script>\n  function realFormatSecond(second) {\n    var secondType = typeof second\n\n    if (secondType === \'number\' || secondType === \'string\') {\n      second = parseInt(second)\n\n      var hours = Math.floor(second / 3600)\n      second = second - hours * 3600\n      var mimute = Math.floor(second / 60)\n      second = second - mimute * 60\n\n      return hours + \':\' + (\'0\' + mimute).slice(-2) + \':\' + (\'0\' + second).slice(-2)\n    } else {\n      return \'0:00:00\'\n    }\n  }\n\n  export default {\n    name: \'VueAudioMaster\',\n    props: {\n      theUrl: {\n        type: String,\n        default() {\n          return \"\"\n        }\n      },\n      theSpeeds: {\n        type: Array,\n        default() {\n          return [1, 1.5, 2]\n        }\n      },\n      theControlList: {\n        type: String,\n        default: \'\'\n      }\n    },\n\n    data() {\n      return {\n        audio: {\n          currentTime: 0,\n          maxTime: 0,\n          playing: false, //播放/暂停\n          muted: false,   //静音\n          speed: 1,\n          waiting: true,\n          preload: \'auto\'\n        },\n\n        sliderTime: 0,\n        volume: 100,\n        speeds: this.theSpeeds,\n\n        controlList: {\n          // 不显示下载\n          noDownload: false,\n          // 不显示静音\n          noMuted: false,\n          // 不显示音量条\n          noVolume: false,\n          // 不显示进度条\n          noProcess: false,\n          // 只能播放一个\n          onlyOnePlaying: false,\n          // 不要快进按钮\n          noSpeed: false\n        }\n      }\n    },\n    methods: {\n      setControlList() {\n        let controlList = this.theControlList.split(\' \')\n        controlList.forEach((item) => {\n          if (this.controlList[item] !== undefined) {\n            this.controlList[item] = true\n          }\n        })\n      },\n      changeSpeed() {\n        let index = this.speeds.indexOf(this.audio.speed) + 1\n        this.audio.speed = this.speeds[index % this.speeds.length]\n        this.$refs.audio.playbackRate = this.audio.speed\n      },\n      startMutedOrNot() {\n        this.$refs.audio.muted = !this.$refs.audio.muted\n        this.audio.muted = this.$refs.audio.muted\n      },\n      //显示音量条\n      isShowVolume(){\n        this.controlList.noVolume = !this.controlList.noVolume\n      },\n      // 音量改变\n      changeVolume(index = 0) {\n        this.$refs.audio.volume = index / 100\n        this.volume = index\n        this.controlList.noVolume = false\n      },\n      // 播放跳转\n      changeCurrentTime(index) {\n        this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime)\n      },\n      startPlayOrPause() {\n        return this.audio.playing ? this.pausePlay() : this.startPlay()\n      },\n      // 开始播放\n      startPlay() {\n        this.$refs.audio.play()\n      },\n      // 暂停\n      pausePlay() {\n        this.$refs.audio.pause()\n      },\n      // 当音频暂停\n      onPause() {\n        console.log(\"onPause\");\n        this.audio.playing = false\n      },\n      // 当发生错误, 就出现loading状态\n      onError() {\n        this.audio.waiting = true\n      },\n      // 当音频开始等待\n      onWaiting(res) {\n        console.log(res)\n      },\n      // 当音频开始播放\n      onPlay(res) {\n        console.log(res)    //Event事件对象 res.target == audio 当前的audio对象\n        this.audio.playing = true\n        this.audio.loading = false\n\n        // if (!this.controlList.onlyOnePlaying) {\n        //   return\n        // }\n        //\n        // let target = res.target\n        //\n        // let audios = document.getElementsByTagName(\'audio\');\n        //\n        // [...audios].forEach((item) => {\n        //   if (item !== target) {\n        //     item.pause()\n        //   }\n        // })\n      },\n      onEnded(res) {\n        console.log(\"结束了...\");\n        this.pausePlay()\n        this.$emit(\"loop_next\")\n      },\n      // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间\n      onTimeupdate(res) {\n        // console.log(\'timeupdate\')\n        // console.log(res)\n        this.audio.currentTime = res.target.currentTime\n        this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100)\n      },\n      // 当加载语音流元数据完成后，会触发该事件的回调函数\n      // 语音元数据主要是语音的长度之类的数据\n      onLoadedmetadata(res) {\n        console.log(\'loadedmetadata\')\n        console.log(res)\n        this.audio.waiting = false\n        this.audio.maxTime = parseInt(res.target.duration)\n      },\n\n      /*上一首 下一首 事件抛发给父组件*/\n      prevClick() {\n        this.onPause()\n        this.$emit(\"prev\")\n      },\n      nextClick() {\n        this.onPause()\n        this.$emit(\"next\")\n      },\n    },\n    filters: {\n      formatSecond(second = 0) {\n        return realFormatSecond(second)\n      },\n      transPlayPause(value) {\n        return value ? \'暂停\' : \'播放\'\n      },\n      transMutedOrNot(value) {\n        return value ? \'放音\' : \'静音\'\n      },\n      transSpeed(value) {\n        return \'x\' + value\n      }\n    },\n    created() {\n      this.setControlList()\n    },\n    watch: {\n      theUrl(newVal, oldVal) {\n        this.startPlayOrPause();\n      }\n    }\n  }\n\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n  .audio-view {\n    width: 100vw;\n    background-color: rgb(42, 42, 42);\n  }\n  .audio-control-container{\n    margin: 0 auto;\n    width: 80%;\n    height: 49px;\n    color: white;\n    font-size: 12px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n  .audio-play-btn{\n    display: flex;\n  }\n  .audio-play-btn .el-button{\n    display: inline-block;\n    flex: 1;\n  }\n  .audio-control-container .play-slider{\n    width: 300px;\n    margin-left: 15px;\n    margin-right: 15px;\n  }\n  .volumn-container{\n    position: relative;\n  }\n  .volumn-container .volume-slider{\n    position: absolute;\n    top: -110px;\n    left: -8px;\n  }\n\n</style>\n```\n父组件调用：\n```vue\n<template>\n  <div class=\"home\">\n    <div v-if=\"songList[currentIndex].url\">\n      <vue-audio-master ref=\"audio\"\n        :the-url=\"songList[currentIndex].url\"\n                        @prev=\"prevHandler\"\n                        @next=\"nextHandler\"\n                        @loop_next=\"loopNextHandler\"></vue-audio-master>\n    </div>\n\n    <p v-for=\"item in songList\">\n      {{item}}\n    </p>\n  </div>\n</template>\n\n<script>\nimport VueAudioMaster from \'@/components/master/VueAudioMaster.vue\'\nimport request from \'@/network/request.js\'\n\nexport default {\n  name: \'Home\',\n  components: {\n    VueAudioMaster\n  },\n  data(){\n    return {\n      /*\n      * [{id:xxx,name:xxx,url:xxx},{},{}]\n      * */\n      songList:[],\n      currentIndex:0,   //当前播放歌曲列表中的歌曲索引\n    }\n  },\n  methods:{\n    fetchSongId(){\n      request({\n        url:\"/artist/songs?id=5771\"\n      }).then(res=>{\n        // console.log(res);\n        res.songs.forEach(item =>{\n          this.songList.push({\n            id:item.id,\n            name:item.name,\n            mv:item.mv,\n            al:item.al,\n            url:\"\",\n          })\n        })\n      }).then((res)=>{\n        console.log(res);\n        this.fetchSongUrl();\n      })\n    },\n\n    fetchSongUrl(){\n      let songListID = this.songList.map(item =>{\n        return item.id\n      })\n      let ids = songListID.join(\",\")\n      // console.log(songListID);\n      // console.log(ids);\n      request({\n        url:\"/song/url?id=\"+ids\n      }).then(res=>{\n        // console.log(res);\n        res.data.forEach((item,index) =>{\n          this.songList[index].url = item.url\n        })\n      })\n    },\n\n    //上一首\n    prevHandler(){\n      console.log(\"上一首===\"+this.currentIndex);\n      if(this.currentIndex == 0){\n        this.currentIndex = this.songList.length-1;\n      }else{\n        this.currentIndex--;\n      }\n    },\n    //下一首\n    nextHandler(){\n      console.log(\"下一首===\"+this.currentIndex);\n      if(this.currentIndex == this.songList.length-1){\n        this.currentIndex = 0;\n      }else{\n        this.currentIndex++;\n      }\n    },\n    //播放完之后循环下一首\n    loopNextHandler(){\n      if(this.currentIndex == this.songList.length-1){\n        this.currentIndex = 0;\n      }else{\n        this.currentIndex++;\n      }\n      // this.$refs.audio.onStart();\n      // this.$refs.audio.startPlay();\n      // this.$refs.audio.startPlayOrPause();\n    }\n  },\n  created() {\n    this.fetchSongId();\n  }\n}\n</script>\n```\n','原创','','','','','',0,1479452807638581249,NULL,0,0,'2022-01-15 21:31:10','2022-01-15 21:31:10'),(1482345718415982594,'【Java基础】Java面向对象编程1','java是一门纯面向对象编程语言, 我们后面写的所有程序都是在面向对象的基础上编写的。面向对象难在思想和语法上，真正应用的时候会不知不觉的渗透在你的代码里，好多程序员写程序会写','https://ae03.alicdn.com/kf/Hef545dc1d22540e0aeb1b578632268fc5.png','面向对象是最重要的一章，java是一门纯面向对象编程语言, 我们后面写的所有程序都是在面向对象的基础上编写的。面向对象难在思想和语法上，真正应用的时候会不知不觉的渗透在你的代码里，好多程序员写程序会写, 但是为什么这样写? 不知道，所以本章很多都是理解和需要思考的东西.\n在本章你要学的重点知识点:\n\n1. 类与对象\n1. 构造方法\n1. 访问权限\n1. 继承\n1. 多态 ( 最重要 )\n1. 抽象和接口\n1. 内存分析\n\n其他知识点不是说不重要. 相对而言. 最重要的是上面这几个。\n**面向对象和面向过程：**\n讲面向对象之前, 还要再提两个概念, 毕竟没有对比就没有伤害：\n面向过程:\n从名字上可以看出来, 编程的思路是按照事务的发展流程而编写的，最典型的例子就是把大象装冰箱总共分几步? 第一步, 把冰箱门打开,\n第二步, 把大象装进去,\n第三步.把冰箱门关上。\n优点: 思路简单, 写起来也简单\n缺点: 维护困难，代码量越大, 越难维护。\n面向对象:\n一切以对象为中心，我们扮演的是上帝的角色。比如, 同样是大象进冰箱, 用面向对象的思维来解决的话就是, 创建一个大象, 然后告诉大象, 进冰箱里面去，具体怎么进冰箱由大象来完成。面向对象的思维可以把”我”的工作减少到最低，由对象来完成具体的操作。\n优点: 超强的可扩展性，可维护性。\n缺点: 上手比较难, 尤其是刚开始就接触面向对象。\n## 类的组成\n**定义一个类的基本格式：**\n```shell\n[修饰符] class 类名{\n	0到多个构造器\n	0到多个成员变量\n	0到多个方法\n	0到多给初始化块\n}\n```\n修饰符可以写public final abstract或者不写，java类名要用大驼峰写法(PrimaryStu首字母大写的驼峰)。\n一个java源文件（即文件后缀名为.java的文件）可以写多个类，但是里面只能有一个用public修饰的class。\n### 构造器函数\n构造器也叫构造方法或者构造函数,构造器与类名相同，没有返回值，连void都不能写;\n构造器定义格式：\n```shell\n[修饰符]与类名相同的名(形参列表){\n	构造器方法体代码  \n}\n```\n\n- 构造器函数名称与类名相同，没有返回值，不能写void 。\n- 如果类中没有手动添加构造器，编译器会默认添加一个无参构造器 。\n- 如果手动添加了构造器（无论什么形式），默认构造器就会消失，因为构造器可以重载。\n### 成员变量\n成员变量是定义在类中，方法体之外的变量(即类变量+实例变量)。实例变量在创建对象的时候实例化；\n成员变量可以被类中方法、构造方法和特定类的语句块访问。\n修饰符(public–protected–private)三选一、static、final，使用static修饰就是静态变量了(类变量)\n\n\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 局部变量：类的方法中的变量。\n- 实例变量（全局变量）：独立于方法之外的变量，不过没有 static 修饰。\n```java\npublic class Variable{\n  static int allClicks=0; // 类变量\n  String str=\"hello world\"; // 实例变量\n  public void method(){\n     int i =0; // 局部变量\n   }\n  }\n```\n#### 局部变量\n\n- 局部变量声明在方法、构造方法或者语句块中；\n- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n- 访问修饰符不能用于局部变量；\n- 局部变量只在声明它的方法、构造方法或者语句块中可见；\n- 局部变量是在栈上分配的。\n- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n#### 实例变量\n\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n#### 类变量\n\n- 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n- 静态变量在程序开始时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。\n- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：ClassName.VariableName的方式访问。\n- 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。\n### 方法\nJava方法是语句的集合，它们在一起执行一个功能。\n方法是解决一类问题的步骤的有序组合 方法包含于类或对象中，方法在类中被创建，在其他地方被引用\n```java\nvoid printf(){\n  System.out.println(111);\n	}\n```\n上面是一个无参的返回值为空的方法，参数可以加，返回值也可以是int型也可以是别的类型。\n方法的定义：\n```shell\n[修饰符]方法的返回值类型 方法名称(形参列表){  \n	//方法体代码  \n	[return 返回值;]  \n}\n```\n方法的修饰符(public protected private)三选一、static、final、synchronize、native，使用static就是静态方法了\n### 代码块\n初始化代码块：将一些变量、语句（如打印语句）放到一个{}，主是用来初始化一些值的，它的优先级比构造函数要高，一些需要多次使用但又是固定的值可以放进初始化块中。\n使用static就是静态初始化块了，静态初始化块优先级最高，多次实例化时只执行一次\n## 一、类与对象\n类是对具体事务的描述，对某一类事务的总结，对事物的归类。比如车是一个大类包括轿车 suv mpv 房车等等。\n对象是什么? 对象就是具体的一辆车比如你购买的一辆宝马X6，就是具体要执行操作的事务。\n### 定义类\n```java\npublic class Car {  }\n```\n我们对车要进行描述，描述车需要有两个标准去描述, 1. 车有什么属性, 2. 车能干什么.\n属性: 使用成员变量来描述属性\n动作: 使用成员方法来描述动作\n成员变量是什么? 很简单, 之前不是学过变量么. 我们之前的变量是写在main方法里的. 这里的成员变量指的是直接写在类里的变量叫成员变量. 比如. 车有颜色, 车有品牌, 车有排量等等。\n成员方法是什么? 就是我们之前学习的方法. 把前面的static去掉就是成员方法. 关于static后面我们会讲，这里不用纠结，直接干掉就行。好了, 车能执行哪些动作? 跑, 跳高, 游泳等等。\n```java\npublic class Car {\n     //成员变量. 可以初始化，也可以只声明不初始化\n     String color;   // 汽车有颜色\n     String brand = \"奔驰\";   // 汽车有品牌, 所有车都是奔驰\n     String displacement;  // 汽车有排量\n     //方法\n     public void run(){\n         System.out.println(\"破车会跑\");\n     }\n     public void jump(){\n         System.out.println(\"神车~~ 会跳高\");\n     }\n     public void swim(){\n         System.out.println(\"我的车会游泳\");\n     }\n }\n```\n### 类实例化对象\n```java\npublic static void main(String[] args) {\n     Car c = new Car(); // 创建对象\n }\n```\n> Car c =new Car();\n> 这句话就是传说中的创建对象了.\n> 注意, 这里其实是一个赋值操作, 那根据赋值操作的特点. 肯定要先执行等号右边的代码, 然后赋值给等号左边. 我们挨个分析.\n> new Car(); new表示创建, 新建. 后面跟的是类名+括号. 整个这句话你可以理解为 创建一个车类型的对象. 那这个车是根据Car类创建的. 所以这个对象一定符合类的定义. 这个很好理解. 用你的图纸造的车. 肯定符合你图纸上设计的样子.\n> Car c 这是个啥? 对比一下你瞬间秒懂\n> String a …… 没错. 就是声明了一个变量. c是Car类型的. 只不过在面向对象的世界里变量是没有市场的. 大家都叫它引用. 这也就是我们讲的第二大数据类型, 引用数据类型. 说的就是咱们写的类. 声明出来的变量.\n> 整体合起来就是: 创建一个车类的对象. 然后赋值给变量c. 以后变量c就是使用的这辆车.\n\nOK, 对象创建出来了. 接下来. 怎么用呢？\n```java\nCar c = new Car();\nc.color = \"红色\"; // 汽车的颜色设置成红色\nc.displacement = \"3.6T\"; // 排量\n//c.seat = 5; // 报错. 在类中你没有写这个属性.\nSystem.out.println(c.color);\nSystem.out.println(c.brand);\nSystem.out.println(c.displacement);\nc.run();\nc.jump();\nc.swim();\n```\n类里没有的属性你不能乱用.\n总结: 类其实就是对某一类事物的归类和描述. 对象是通过类创建的，类是抽象概念, 对象是具体。\n## 二、this关键字\nthis是啥? 我们看一个例子\n```java\npublic class Car {\n     String color;\n     int seat;\n     String displacement;\n     public void run(){\n         System.out.println(color + \"颜色的车在跑\");\n     }\n     public static void main(String[] args) {\n         Car c = new Car();\n         c.color = \"红色\";\n         c.seat = 5;\n         c.displacement = \"1.6\";\n         c.run();\n     }\n }\n```\n这里注意. 在run方法里我们使用了一次color变量,此时我们发现可以正常使用.\n我们可以发现, 此时使用的color是对象里的color, 那如果我给run()传递一个参数也叫color呢?\n```java\npublic class Car {\n     String color;\n     int seat;\n     String displacement;\n     public void run(String color){\n         System.out.println(color + \"颜色的车在跑\");	//绿色颜色的车在跑\n         System.out.println(this.color + \"颜色的车在跑\");		//红色颜色的车在跑\n     }\n     public static void main(String[] args) {\n         Car c = new Car();\n         c.color = \"红色\";\n         c.seat = 5;\n         c.displacement = \"1.6\";\n         c.run(\"绿色\");\n     }\n }\n```\n方法查找变量的顺序: 方法内部(局部) > 对象\n说白了就是就近原则, 那此时我即想用局部变量又想用对象中的变量,怎么进行区分呢? 此时就需要用到this关键字.\n> 在java中, this表示当前类的对象\n> 啥叫当前类的对象,就是正在执行这个方法的对象.\n> c.run() => 在run中this就是c\n\n总结：this可以帮我们在类中获取到对象的任何信息。如果没有命名冲突，可以省略`this`，但我们不推荐省略。\n#### this()与super()使用详解\n参考：[https://blog.csdn.net/lncsdn_123/article/details/79025525](https://blog.csdn.net/lncsdn_123/article/details/79025525)\n[https://www.cnblogs.com/hasse/p/5023392.html](https://www.cnblogs.com/hasse/p/5023392.html)\n## 三、构造方法\n构造的意义就是可以帮我们在创建对象的时候给对象传递一些信息.\n构造方法的语法:\n> public 类名(参数….){\n> }\n\n注意: 构造方法的名字必须和类名一致.\n```java\npublic class Car{\n     String name;\n     String color;\n     int seat;\n     public Car(String name, String color, int seat){\n         this.name = name; // 相当于p.name = name\n         this.color = color; // 相当于p.color = color\n         this.seat = seat; // 相当于p.seat = seat\n         System.out.println(\"我就是一个可怜的构造方法\");\n     }\n     public static void main(String[] args){\n         Car p = new Car(\"大黄蜂\", \"绿色\", 5); // 创建对象的时候. 后面这个小括号其实就是在调用构造方法\n         System.out.println(p.name);\n         System.out.println(p.color);\n         System.out.println(p.seat);\n     }\n }\n```\n> 总结: 构造方法存在的意义就是在对象在创建的时候给对象设置一些属性.\n> 注意: 每个类都会有构造方法，如果不写, java会自动创建一个没有参数的构造方法.\n> 但是, 自己写了构造方法了就覆盖掉无参的构造方法\n\n### 构造方法的重载\n想这么一个事儿, 我们可以在创建对象的时候给对象传递一些信息, 通常都是在构造方法里设置一些属性. 那如果现在我写一个”大侠”类, 里面会有很多个属性,\n```java\npublic class DaXia{\n     String name;\n     String waihao;\n     int age;\n     String bangPai;\n }\n```\n```\n好了, 接下来我们去创建大侠, 比如, 创建一个\"岳不群\", 那在创建岳不群的时候, 需要给出: 名字, 年龄, 帮派.\n```\n外号和口头禅对于岳不群而言都不需要，那如果是创建一个武松呢? 需要给出: 名字, 年龄, 帮派,外号. 这就会产生一个分歧，有些大侠有外号, 有些大侠没有外号，并且, 我们知道在创建对象的时候，我们是默认调用构造方法的. 那就需要我们写两个构造方法来满足两种不同的大侠，但是构造方法的名字还必须是类名，也就意味着, 我们要写两个名字相同的方法。在上一章里学过, 方法的名字相同参数的个数或者类型不同, 叫方法的重载。没错, 这里需要我们重载构造方法。\n```java\npublic class DaXia{\n     String name;\n     String waihao;\n     int age;\n     String bangPai;\n     public DaXia(String name, int age, String bangPai){\n         this.name = name;\n         this.age = age;\n         this.bangPai = bangPai;\n     }\n     public DaXia(String name, int age, String bangPai, String waihao){\n         this.name = name;\n         this.age = age;\n         this.bangPai = bangPai;\n         this.waihao = waihao;\n     }\n }\n```\n聪明的你应该又发现一个问题,两个构造方法的写法太像了. 能不能简化一下呢? OK. 没问题. 我们还可以使用this来调用当前类中的其他构造方法\n```java\npublic class DaXia{\n     String name;\n     String waihao;\n     int age;\n     String bangPai;\n     public DaXia(String name, int age, String bangPai){\n         this.name = name;\n         this.age = age;\n         this.bangPai = bangPai;\n     }\n     public DaXia(String name, int age, String bangPai, String waihao){\n         this(name, age, bangPai); 	// 调用自己类中的其他构造方法\n         this.waihao = waihao;\n     }\n }\n```\n> this的两个作用:\n> 1. 表示当前类的对象, 可以访问成员变量和成员方法\n> 1. 可以调用当前类中的其他构造方法(重载的构造方法名都是与类名一致，通过传参不同调不同的构造方法)\n\n### 小练习\n1.用面向对象的思维来模拟LOL里的盖伦上阵杀敌\n2.植物大战僵尸\n> 植物类ZhiWu：包含name  hp  attack字段，和fight方法\n> 僵尸类JiangShi：包含name  hp  attack字段，和eat方法\n> 程序入口类Client：创建植物对象，僵尸对象，调用zw.fight()   调用js.eat()\n\nZhiWu.java\n```java\npublic class ZhiWu {\n    String name;\n    int hp;     //血量\n    int attack;     //攻击力\n    //构造方法\n    public ZhiWu(String name,int hp,int attack){\n        this.name = name;\n        this.hp = hp;\n        this.attack = attack;\n    }\n    //植物打僵尸\n    public void fight(JiangShi js){\n        System.out.println(\"植物\"+this.name+\"正在打僵尸\"+js.name);\n        //僵尸血量减少\n        js.hp -= this.attack;\n        System.out.println(\"僵尸的血量剩余：\"+js.hp);\n    }\n}\n```\nJiangShi.java\n```java\npublic class JiangShi {\n    String name;\n    int hp;     //血量\n    int attack;     //攻击力\n    //构造方法\n    public JiangShi(String name,int hp,int attack){\n        this.name = name;\n        this.hp = hp;\n        this.attack = attack;\n    }\n    //僵尸吃植物\n    public void eat(ZhiWu zw){\n        System.out.println(\"僵尸\"+this.name+\"正在吃植物\"+zw.name);\n        //植物血量减少\n        zw.hp -= this.attack;\n        System.out.println(\"植物的血量剩余：\"+zw.hp);\n    }\n}\n```\nClient.java\n```java\npublic class Client {\n    public static void main(String[] args) {\n        ZhiWu zw = new ZhiWu(\"豌豆射手\",1000,5);\n        JiangShi js = new JiangShi(\"铁头僵尸\",800,10);\n        //植物打僵尸\n        zw.fight(js);\n        //僵尸吃植物\n        js.eat(zw);\n    }\n}\n```\n## 四、static静态字段和静态方法\n假设, 我们现在回到清朝. 给清朝人上户口. 那此时就需要写一个类来装关于清朝人的信息\n```java\npublic class Person{\n     String name;\n     String country;\n     String address;\n     public Person(String name, String country, String address){\n         this.name = name;\n         this.country = country;\n         this.address = address;\n     }\n }\n```\n接下来, 创建2个人\n```java\npublic static void main(String[] args){\n     Person p1 = new Person(\"李大猛\", \"大清\", \"北京珠市口八大胡同\");\n     Person p2 = new Person(\"花花\", \"大清\", \"北京朝阳门外\");\n}\n```\nOK. 很easy. 但是, 我们想想啊. 大清亡了. 改成民国了. 那这时候程序怎么办呢?\n```java\npublic static void main(String[] args){\n     Person p1 = new Person(\"李大猛\", \"大清\", \"北京珠市口八大胡同\");\n     Person p2 = new Person(\"花花\", \"大清\", \"北京朝阳门外\");\n     p1.country = \"民国\";\n     p2.country = \"民国\";\n}\n```\n是不是每个人的country属性都要改一下. 为什么呢?\n两个对象分别是两块独立的内存区域，里面的内容也都是独立的，所以必然要改两次。但是, 你要知道，我国人民众多啊，这得改到什么时候去。那如果能把country这一项作为共享的数据，所有的对象都共享那是不是改起来就容易了，也就是说. 想办法变成这样\n这样改一份就OK了. 那怎么才能让country变成共享的呢? 就是咱今天要学的static.\n**static表示静态，被static修饰的变量会被所有的对象共享, 并且在内存里只会保留一份.**\n```java\npublic class StaticTest {\n    public String name;\n    public int age;\n    public static String country = \"china\";\n    {\n        System.out.println(\"这里是普通初始化块\");\n    }\n    static {\n        System.out.println(\"这里是静态初始化块\");\n    }\n    public StaticTest(String name,int age){\n        this.name = name;\n        this.age = age;\n        System.out.println(\"这里是构造方法\");\n    }\n    public static void MyStaticFunc(){\n        System.out.println(\"我是静态方法MyStaticFunc,国家=\"+StaticTest.country);\n    }\n    public void ShowNameFunc(){\n        System.out.println(\"我是方法ShowNameFunc，name=\"+this.name+\" ,age=\"+this.age);\n    }\n    public static void main(String[] args) {\n        StaticTest obj1 = new StaticTest(\"zhangsan\",18);\n        StaticTest.MyStaticFunc();      //静态方法通过类调用\n		//this.ShowNameFunc();        //main主函数也是一个静态方法，不能使用this\n        obj1.ShowNameFunc();\n    }\n}\n//打印结果\n这里是静态初始化块\n这里是普通初始化块\n这里是构造方法\n我是静态方法MyStaticFunc,国家=china\n我是方法ShowNameFunc，name=zhangsan ,age=18\n```\n类的执行顺序：\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1603962061391-d4825be8-a51f-4a67-818d-fc396e2526f8.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=739&size=22765&status=done&style=none&width=739)\n总结：静态字段/方法属于类，p1 p2是类Person创建的实例，实例对象可以访问类的静态字段/方法。静态字段/方法是在类实例化之前创建( this==实例)，因此静态方法中不能使用this 且不能调用非静态方法（类中没有加static的方法）\n```java\npublic class StaticTest {\n    public String name;\n    public int age;\n    public static String country = \"china\";\n    {\n        System.out.println(\"这里是普通初始化块\");\n    }\n    static {\n        System.out.println(\"这里是静态初始化块\");\n    }\n    public StaticTest(String name,int age){\n        this.name = name;\n        this.age = age;\n        System.out.println(\"这里是构造方法\");\n    }\n    public static void MyStaticFunc(){\n        System.out.println(\"我是静态方法MyStaticFunc,国家=\"+StaticTest.country);\n    }\n    public void ShowNameFunc(){\n        System.out.println(\"我是方法ShowNameFunc，name=\"+this.name+\" ,age=\"+this.age);\n    }\n    public static void main(String[] args) {\n        StaticTest obj1 = new StaticTest(\"zhangsan\",18);\n        StaticTest.MyStaticFunc();      //静态方法通过类调用\n//        this.ShowNameFunc();        //main主函数也是一个静态方法，不能使用this\n        obj1.ShowNameFunc();\n        Person p1 = new Person(\"李大猛\", \"北京珠市口八大胡同\");\n        Person p2 = new Person(\"花花\", \"北京朝阳门外\");\n        Person.country = \"民国\";\n        System.out.println(p1.country);\n        System.out.println(p2.country);\n        Person.setCountry(\"中华人民共和国\");\n        System.out.println(p1.country);\n        System.out.println(p2.country);\n    }\n}\nclass Person {\n    static String country;\n    String name;\n    String address;\n    public static void setCountry(String country){\n//        System.out.println(this.name);      //静态方法中不能使用对象，即不能用this\n        System.out.println(\"修改之前的静态字段Person.country=\"+Person.country);     //可以使用静态字段\n        Person.country = country;\n    }\n	//构造方法\n    public Person(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n}\n```\n## 五、包和导包\n[https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976](https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976)\n随着代码越写越多. 咱们不可能一直这样在src里创建java文件了，就好比你看片你不可能把所有的电影都堆桌面, 对吧, 你肯定要准备几个文件夹, 然后对这些片片进行分类, 哪些好看, 哪些无码, 哪些重口味~~， 一样的咱们的代码也是啊，不可能就这么堆src里，时间长了不好管理啊\nwindows操作系统使用文件夹来装不同的文件，在java里使用包来管理不同的java文件\n怎么创建包? 看着\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557050-65cb7cc5-1669-4bc3-b00a-3ee3d7a2d5a5.png#align=left&display=inline&height=167&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1484&status=done&style=none&width=508)\n右键-> 新建-> package\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557086-97d14e0b-b0df-4996-8b30-c8c23d6ddd96.png#align=left&display=inline&height=155&margin=%5Bobject%20Object%5D&originHeight=366&originWidth=1316&status=done&style=none&width=559)\n> 注意: 包名一般用公司域名的翻转. 一般都是com或者org开头. 还有一些公司会用net开头，然后就是项目名, 最后一般都是功能模块名. 比如 你先在写的是qq的聊天窗口那就可以: `com.qq.talk`\n\n创建出来的包是这样个样子的. 但是如果你去文件系统里看. 它是这样的.\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557130-a78a762e-427c-4100-a89b-f24dca39899a.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&originHeight=818&originWidth=1470&status=done&style=none&width=513)\n所谓的”.”其实就是文件夹.\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557176-b487b27f-5665-45ca-ac94-0628d53c1798.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=1566&status=done&style=none&width=1566)\nOK. 接下来我们到包里创建一个java文件看看\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557223-24f3520b-07f3-4236-aebd-5d7bfa3fa978.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=1556&status=done&style=none&width=1556)\n我们发现, 现在写的代码的第一行多了这样一句话叫`package com.xyq.bao;` package表示当前文件所属的包.\npackage需要注意的点:\n\n1. 必须放在有效代码的第一行. 不可以写在别处.\n1. package 后面的代码必须和文件系统的路径一致.\n\n一个包OK了. 那如果是多个包呢? 我们到src位置创建一个新包\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557291-a3494751-1828-423e-a511-5d47ef47eceb.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=1506&status=done&style=none&width=538)![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557338-f3df6aed-3d68-4ca2-aa19-f59198a396b6.png#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=1278&status=done&style=none&width=542)\nidea会自动帮我们分开,很人性化.\n接下来. 我们到dao里写一个Person类.\n```java\npackage com.xyq.dao;\npublic class Person {\n     String name;\n     String address;\n     public Person(String name, String address){\n         this.name = name;\n         this.address = address;\n     }\n     public void chi(){\n         System.out.println(this.name + \"正在吃东西\");\n     }\n }\n```\n我们到bao里调用这个类\n```java\npackage com.xyq.bao;\npublic class TestPerson {\n     public static void main(String[] args) {\n         Person p1 = new Person(\"武大郎\", \"阳谷县\"); // 这行报错\n     }\n }\n```\n我们发现 程序报错. 原因是. 自己包里没有这个叫Person的东西. 就好比, 你在你自己的房间里喊楼下的人. 听不见. 所以呢. 你需要打电话把楼下的人叫上来. 然后你俩面对面了. 你说什么他都能听到了. 此时, 我们需要导包,\n语法:\n> import 包.类\n\n```java\npackage com.xyq.bao;		//第一行\nimport com.xyq.dao.Person; // 导包\npublic class TestPerson {\n     public static void main(String[] args) {\n         Person p1 = new Person(\"武大郎\", \"阳谷县\");\n         p1.chi();\n     }\n }\n```\n在idea中导包非常简单，只需要将鼠标放到需要导入的类上 按快捷键 Alt+Enter，即可自动导包\n聪明的你一定想起来了，Scanner不就这样么，对于Scanner System这类包属于java.lang\n> 不需要导包:\n> 1. 在自己包里\n> 1. java.lang包. 我们用的String Scanner System.out.println()就是这个包里的.\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1604370903381-37380244-eef7-47d8-b0b5-de51db06cad4.png#align=left&display=inline&height=377&margin=%5Bobject%20Object%5D&name=image.png&originHeight=377&originWidth=640&size=117297&status=done&style=none&width=640)\n## 六、**修饰符**\nJava中的修饰符分为3类：\n\n- 权限修饰符：public、default默认、protected、private\n- 状态修饰符：static、final\n- 抽象修饰符：abstract\n### 1）访问权限修饰符\n这个很好理解, 你的东西你肯定不希望别人随意的看随意的访问对吧， java程序也是这样，不是啥都是对外的。有些东西自己享用就好了，有些东西是留给自己后代的，还有些东西是自己这一片邻居可以访问的，最后还有一些是大家都能访问的。\njava一共四种访问权限，参考：[菜鸟教程](https://www.runoob.com/java/java-modifier-types.html)\n\n| 权限分类 | 当前类 | 子孙类 | 同一包（子类或无关类） | 不同包（子类） | 不同包（无关类） |\n| --- | --- | --- | --- | --- | --- |\n| public | √ | √ | √ | √ | √ |\n| protected | √ | √ | √ | √ | × |\n| default | √ | √ | √ | × | × |\n| private | √ | × | × | × | × |\n\n```java\npackage com.xyq.bao;\npublic class Person {\n     String def = \"def\"; // 默认啥都不写就是default权限\n     public String pub = \"pub\"; // 公共的\n     private String pri = \"pri\"; // 自己的\n     public static void main(String[] args) {\n         Person p = new Person();\n         // 自己类里,都没问题\n         System.out.println(p.def);\n         System.out.println(p.pub);\n         System.out.println(p.pri);\n     }\n }\n```\n自己包里的其他类里试试:\n```java\npackage com.xyq.bao;\npublic class TestPackagePerson {\n     public static void main(String[] args) {\n         Person p = new Person();\n //      自己包里private不行了\n         System.out.println(p.def);\n         System.out.println(p.pub);\n //      System.out.println(p.pri); // 报错了\n     }\n }\n```\n换个包试试\n```java\npackage com.xyq.baowai;\nimport com.xyq.bao.Person;\npublic class TestPackagePerson {\n     public static void main(String[] args) {\n         Person p = new Person();\n //      包外面的其他类. 只有public可以\n         System.out.println(p.pub);\n //      System.out.println(p.def); // 报错了\n //      System.out.println(p.pri); // 报错了\n     }\n }\n```\n一般情况, 我们很少用包访问权限. 这种权限并不舒服. 说白了. 你家里的东西要么是都能让人看的, 要么就是自己用的. 很少会专门准备一些东西给你的邻居用的. 程序也一样. 很少会用默认的访问权限.\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1602590685693-b77392c7-8196-406d-995d-693b642d0b9e.png#align=left&display=inline&height=484&margin=%5Bobject%20Object%5D&name=image.png&originHeight=484&originWidth=501&size=45133&status=done&style=none&width=501)\n### 2）状态修饰符\nfinal修饰的特点：\n\n- 修饰方法：表明该方法是最终方法，不能被重写\n\n- 修饰变量：表明该变量是常量，不能再次被赋值\n\n- 修饰类：表明该类是最终类，不能被继承\n\n\nfinal修饰局部变量\n\n- 变量是基本类型：final修饰指的是基本类型的**数据值**不能改变\n- 变量是引用类型：final修饰指的是引用类型的**地址值**不能改变，但是地址里面的内容可以改变\n\n\n\nstatic关键字是静态的意思，可以修饰成员变量、成员方法\nstatic修饰特点：\n\n- 被类的所有对象共享\n\n- 可以通过类名调用（也可以通过对象名调用，推荐使用类名调用）\n\n- static修饰的静态方法只能访问静态成员和静态方法\n\n- 非静态方法可以访问静态成员和静态方法也可以访问非静态成员和非静态方法\n\n## 七、getter和setter\nGetterSetter.java 定义了私有属性name age\n```java\npackage com.xiaomi.entity;\npublic class GetterSetter {\n    private String name;\n    private int age;\n    //获取name\n    public String getName() {\n        return name;\n    }\n    //设置name\n    public void setName(String name) {\n        if(name.length() >1){\n            this.name = name;\n        }else{\n            this.name = \"匿名\";\n        }\n    }\n    //获取age\n    public int getAge() {\n        return age;\n    }\n    //设置age\n    public void setAge(int age) {\n        if(age<0){\n            this.age = 0;\n        }else{\n            this.age = age;\n        }\n    }\n    public void chi(){\n        System.out.println(this.name+\"在吃东西\");\n    }\n}\n```\n包下面的其他类TestGS访问和设置GetterSetter.java中的私有属性\n```java\npackage com.xiaomi.entity;\npublic class TestGS {\n    public static void main(String[] args) {\n        GetterSetter obj1 = new GetterSetter();\n//    obj1.name = \"周杰伦\";      //name是私有\n        obj1.setName(\"周杰伦\");\n        obj1.setAge(-1);\n        obj1.chi();\n        System.out.println(obj1.getAge());\n    }\n}\n```\n上面例子中我们把成员变量用private保护起来，然后给出set和get方法, 在外界访问这个属性的时候，就需要使用set和get方法了. 那这里的get和set就是getter和setter方法.\n上面发现对私有属性的保护要重写get set方法很浪费时间，IDEA帮我们提供了快捷方法\n**快捷键: 空白处, 右键-> generate -> getter and setter**\n一键生成get  set 方法\n## 八、继承\n### 1.继承小结\n\n- 继承是面向对象编程的一种强大的代码复用方式；\n- Java只允许单继承，所有类最终的根类是`Object`；\n- `protected`允许子类访问父类的字段和方法；\n- 子类的构造方法可以通过`super()`调用父类的构造方法；\n- 可以安全地向上转型为更抽象的类型；\n- 可以强制向下转型，最好借助`instanceof`判断；\n- 子类和父类的关系是is，has关系不能用继承。\n### 2.基本用法\n继承: 子类可以自动拥有父类中除了私有内容外的其他所有内容。\n语法:\n> public class 子类 extends 父类{\n> }\n\n那什么样的逻辑我们可以写成继承关系呢? 当出现xxx是一种xxxx的时候，就可以用继承关系。比如,学生是人，\n黑熊精是妖怪，猫 狗 是动物。\n1.首先定义了`Person`类：\n```java\nclass Person {\n    private String name;\n    private int age;\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n```\n2.现在假设需要定义一个`Student`类，字段如下：\n```java\nclass Student {\n    private String name;\n    private int age;\n    private int score;\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n    public int getScore() { … }\n    public void setScore(int score) { … }\n}\n```\n仔细观察，发现`Student`类包含了`Person`类已有的字段和方法，只是多出了一个`score`字段和相应的`getScore()`、`setScore()`方法。\n能不能在`Student`中不要写重复的代码？\n这个时候，继承就派上用场了。\n继承是面向对象编程中非常强大的一种机制，它首先**可以复用代码**。当我们让`Student`从`Person`继承时，`Student`就获得了`Person`的所有功能，我们只需要为`Student`编写新增的功能。\nJava使用`extends`关键字来实现继承：\n```java\nclass Person {\n    private String name;\n    private int age;\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\nclass Student extends Person {\n    // 不要重复name和age字段/方法,\n    // 只需要定义新增score字段/方法:\n    private int score;\n    public int getScore() { … }\n    public void setScore(int score) { … }\n}\n```\n可见，通过继承，`Student`只需要编写额外的功能，不再需要重复代码。\n**注意：**子类自动获得了父类的所有字段，严禁定义与父类重名的字段！（否则就是子类重写父类字段/方法）\n> 在OOP的术语中，我们把`Person`称为超类（super class）/父类（parent class）/基类（base class），把`Student`称为子类（subclass）/扩展类（extended class）。叫的最多的还是 父类 子类\n\n#### 继承树\n注意到我们在定义`Person`的时候，没有写`extends`。在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`。所以，任何类，除了`Object`，都会继承自某个类。下图是`Person`、`Student`的继承树：\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557390-eee3fbf6-0497-432c-8cca-c5deca322cfb.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=143&status=done&style=none&width=143)\n**Java只允许一个class继承自一个类**，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。\n类似的，如果我们定义一个继承自`Person`的`Teacher`，它们的继承树关系如下：\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557422-114f0b1a-1815-46d3-943a-8aa1d2b4a0ef.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=221&originWidth=238&status=done&style=none&width=238)\n#### protected\n希望父类的某个属性/方法能被子类重写，但不希望被其他类自由访问，可以使用protected来修饰。\n继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法。例如，`Student`类就无法访问`Person`类的`name`和`age`字段：\n```java\nclass Person {\n    private String name;\n    private int age;\n}\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; 	// 编译错误：无法访问name字段\n    }\n}\n```\n这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问：\n```java\nclass Person {\n    protected String name;\n    protected int age;\n}\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; 	// OK!\n    }\n}\n```\n因此，`protected`关键字可以把字段和方法的访问权限控制在继承树内部，一个`protected`字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。\n#### super\n`super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`。例如：\n```java\nclass Person {\n    protected String name;\n    protected int age;\n}\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + super.name;		//name  this.name  super.name 效果一样\n    }\n}\n```\n实际上，这里使用`super.name`，或者`this.name`，或者`name`，效果都是一样的。编译器寻找路径是：自己类 --> 父类 ,自己类中没有就去父类中找。\n但是，在某些时候，就必须使用`super`。我们来看一个例子：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Student s = new Student(\"Xiao Ming\", 12, 89);\n    }\n}\nclass Person {\n    protected String name;\n    protected int age;\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\nclass Student extends Person {\n    protected int score;\n    public Student(String name, int age, int score) {\n        this.score = score;\n    }\n}\n```\n运行上面的代码，会得到一个编译错误，大意是在`Student`的构造方法中，无法调用`Person`的构造方法。\n这是因为在Java中，任何`class`的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会自动帮我们自动加一句`super();`，所以`Student`类的构造方法实际上是这样：\n```java\nclass Student extends Person {\n    protected int score;\n    public Student(String name, int age, int score) {\n        super(); 	// 但是父类中的构造方法是带参数，因此这里报错\n        this.score = score;\n    }\n}\n```\n但是，当前`Person`类并没有无参数的构造方法，因此，编译失败。\n解决方法是调用`Person`类存在的某个构造方法。例如：\n```java\nclass Student extends Person {\n    protected int score;\n    public Student(String name, int age, int score) {\n        super(name, age); // 调用父类的构造方法Person(String, int)\n        this.score = score;\n    }\n}\n```\n这样就可以正常编译了！\n因此我们得出结论：如果父类没有默认的构造方法(即我们重写了父类的构造方法)，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法。\n这里还顺带引出了另一个问题：即_**子类不会继承任何父类的构造方法**_。子类默认的构造方法是编译器自动生成的，不是继承的。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1604368463608-77afb675-2d7d-48f0-854b-c9e48b6d7134.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=177&originWidth=654&size=90982&status=done&style=none&width=654)\n子类的构造方法中第一句默认是`super()`调用父类的无参构造方法，如果想要调用父类的有参构造方法需要手动写`super(\"xiong\",26)`，所以我们写类时一般都会定义一个无参构造方法。\n\n\n### 3.向上转型\n如果一个引用变量的类型是`Student`，那么它可以指向一个`Student`类型的实例：\n```java\nStudent s = new Student();\n```\n如果一个引用类型的变量是`Person`，那么它可以指向一个`Person`类型的实例：\n```java\nPerson p = new Person();\n```\n现在问题来了：如果`Student`是从`Person`继承下来的，那么，一个引用类型为`Person`的变量，能否指向`Student`类型的实例？\n```java\nPerson p = new Student(); // ???\n```\n测试一下就可以发现，这种指向是允许的！\n这是因为`Student`继承自`Person`，因此，它拥有`Person`的全部功能。`Person`类型的变量，如果指向`Student`类型的实例，对它进行操作，是没有问题的！\n这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型：\n```java\nStudent s = new Student();\nPerson p = s; 	// upcasting, ok\nObject o1 = p; 	// upcasting, ok\nObject o2 = s; 	// upcasting, ok\n```\n注意到继承树是`Student > Person > Object`，所以，可以把`Student`类型转型为`Person`，或者更高层次的`Object`。\n### 4.向下转型\n和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：\n```java\nPerson p1 = new Student(); 	// upcasting, ok\nPerson p2 = new Person();\nStudent s1 = (Student) p1; 	// ok\nPerson s2 = (Person) p2; 	// ok，自己对自己强转\nStudent s2 = (Student) p2; 	// runtime error! ClassCastException!父类不能转到子类\n```\n如果测试上面的代码，可以发现：\n`Person`类型`p1`实际指向`Student`实例，`Person`类型变量`p2`实际指向`Person`实例。在向下转型的时候，把`p1`转型为`Student`会成功，因为`p1`确实指向`Student`实例，把`p2`转型为`Student`会失败，因为`p2`的实际类型是`Person`，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。\n因此，向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。\n#### `instanceof`操作符\n为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型：\n```java\nPerson p = new Person();\nSystem.out.println(p instanceof Person); // true\nSystem.out.println(p instanceof Student); // false\nStudent s = new Student();\nSystem.out.println(s instanceof Person); // true\nSystem.out.println(s instanceof Student); // true\nStudent n = null;\nSystem.out.println(n instanceof Student); // false\n```\n`instanceof`实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为`null`，那么对任何`instanceof`的判断都为`false`。\n利用`instanceof`，在向下转型前可以先判断：\n```java\nPerson p = new Student();\nif (p instanceof Student) {\n    // 只有判断成功才会向下转型:\n    Student s = (Student) p; // 一定会成功\n}\n```\n从Java 14开始，判断`instanceof`后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：\n```java\nObject obj = \"hello\";\nif (obj instanceof String) {\n    String s = (String) obj;\n    System.out.println(s.toUpperCase());\n}\n```\n可以改写如下：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Object obj = \"hello\";\n        if (obj instanceof String s) {\n            // 可以直接使用变量s:\n            System.out.println(s.toUpperCase());\n        }\n    }\n}\n```\n使用`instanceof variable`这种判断并转型为指定类型变量的语法时，必须打开编译器开关`--source 14`和`--enable-preview`。\n### ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1602580401766-6a97b379-a020-4542-bb87-9a3404c288f5.png#align=left&display=inline&height=587&margin=%5Bobject%20Object%5D&name=image.png&originHeight=587&originWidth=713&size=83571&status=done&style=none&width=713)\n### 5.区分继承和组合\n考察下面的`Book`类：\n```java\nclass Book {\n    protected String name;\n    public String getName() {...}\n    public void setName(String name) {...}\n}\n```\n这个`Book`类也有`name`字段，那么，我们能不能让`Student`继承自`Book`呢？\n```java\nclass Student extends Book {\n    protected int score;\n}\n```\n显然，从逻辑上讲，这是不合理的，`Student`不应该从`Book`继承，而应该从`Person`继承。\n究其原因，是因为`Student`是`Person`的一种，它们是is关系，而`Student`并不是`Book`。实际上`Student`和`Book`的关系是has关系。\n具有has关系不应该使用继承，而是使用组合，即`Student`可以持有一个`Book`实例：\n```java\nclass Student extends Person {\n    protected Book book;\n    protected int score;\n}\n```\n因此，继承是is关系，组合是has关系。\n参考：[https://blog.csdn.net/weixin_43819113/article/details/90273844](https://blog.csdn.net/weixin_43819113/article/details/90273844)\n练习：\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557485-a83bc496-c663-49b5-8ba8-efe49381e2b4.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&originHeight=156&originWidth=222&status=done&style=none&width=222)\nMain.java\n```java\npublic class Main {\n	public static void main(String[] args) {\n		Person p = new Person(\"小明\", 12);\n		//此时需要显示的创建被组合的对象 b1\n		Book b1 = new Book(\"三体\",89.2);\n		Student s = new Student(\"小红\", 20, 99,b1);\n		s.BookContent();\n		// TODO: 定义PrimaryStudent，从Student继承，新增grade字段:\n		Student ps = new PrimaryStudent(\"小军\", 9, 87,b1,5);\n		System.out.println(ps.getScore());\n		ps.BookContent();\n	}\n}\n```\nPerson.java\n```java\npublic class Person {\n	protected String name;\n	protected int age;\n	\n	public Person(String name, int age) {\n		this.name = name;\n		this.age = age;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public int getAge() {\n		return age;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n}\n```\nStudent.java\n```java\npublic class Student extends Person {\n	protected int score;\n	protected Book book;\n	public Student(String name, int age, int score,Book book) {\n		super(name, age);\n		this.book = book;\n		this.score = score;\n	}\n	public int getScore() {\n		return score;\n	}\n	//重写该方法\n	public void BookContent(){\n		System.out.println(\"我是Student类，\"+this.name+\"有这本书！\");\n		this.book.BookContent();\n	}\n	public void BookSale(){\n		System.out.println(\"这本书销量非常好，已经供不应求了！\");\n	}\n}\n```\nPrimaryStudent.java\n```java\npublic class PrimaryStudent extends Student {\n	protected int grade;\n	public PrimaryStudent(String name, int age, int score,Book b1,int grade) {\n		super(name,age,score,b1);\n		this.grade = grade;\n	}\n}\n```\nBook.java\n```java\npublic class Book {\n    protected String bookname;\n    protected Double price;\n    protected String author;\n    protected String type;\n    public Book(String bookname,Double price){\n        this.bookname = bookname;\n        this.price = price;\n    }\n    public void BookContent(){\n        System.out.println(\"我是Book类，这本书的书名是：\"+this.bookname+\"，价格是：\"+this.price);\n    }\n}\n```\n## 九、Java多态\n### Java多态特点\n> 多态---顾名思义就是一种事物表现出不同的形态；举个例子：汤姆猫既是猫类（拥有猫捉老鼠的特性） 也是动物类（动物会跑会吃东西的特性）。\n\n#### 多态中成员访问特点\n\n- 成员变量：编译看左边，执行看左边\n- 成员方法：编译看左边，执行看右边\n\n这两句话怎么理解呢？\n> Animal a1 = new Dog();\n> a1.name\n> 成员变量：编译时Animal类中必须要有name属性，执行时也是运行的Animal中的name\n> \n\n> Animal a1 = new Dog();\n> a1.eat();\n> 成员方法：编译时Animal类中必须要有eat方法(可以是抽象方法)，执行时运行的是右边Dog中的eat方法\n\n为什么成员变量和成员方法的访问不一样呢？\n> 因为成员方法有重写，而成员变量没有\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/1559629/1604375950039-0cb064b1-c70a-40c8-b480-d3f858ce4f08.png#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=image.png&originHeight=728&originWidth=687&size=106521&status=done&style=none&width=687)\n### 重写(Override)与重载(Overload)\n#### 重写(Override)\n重写是子类对父类的允许访问的方法的实现进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**\n> 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：\n```java\nclass Animal{\n   public void move(){\n      System.out.println(\"动物可以移动\");\n   }\n}\n \nclass Dog extends Animal{\n   public void move(){\n      System.out.println(\"狗可以跑和走\");\n   }\n}\n \npublic class TestDog{\n   public static void main(String args[]){\n      Animal a = new Animal(); // Animal 对象\n      Animal b = new Dog(); // Dog 对象\n \n      a.move();// 执行 Animal 类的方法\n      b.move();//执行 Dog 类的方法\n   }\n}\n```\n以上实例编译运行结果如下：\n```\n动物可以移动\n狗可以跑和走\n```\n在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。\n这是由于在编译阶段，只是检查参数的引用类型。\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。\n因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。\n思考以下例子：\n```java\npackage com.polymorphism.entity;\npublic class OverrideOverload {\n    public static void main(String args[]){\n        Animal a = new Animal(); // Animal 对象\n        Animal b = new Dog(); // Dog 对象\n        a.move();   // 执行 Animal 类的方法\n        b.move();   //执行 Dog 类的方法\n//        b.bark();   //编译失败，是因为 Animal 类中不存在 bark 方法\n        Dog d1 = new Dog();\n        d1.bark();      //编译成功，是因为 Dog 类中存在 bark 方法\n    }\n}\nclass Animal{\n    public void move(){\n        System.out.println(\"动物可以移动\");\n    }\n}\nclass Dog extends Animal{\n    public void move(){\n        System.out.println(\"狗可以跑和走\");\n    }\n    public void bark(){\n        System.out.println(\"狗可以吠叫\");\n    }\n}\n```\n#### 方法的重写规则\n\n- 参数列表必须完全与被重写方法的相同。\n- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。(public>默认>protected>private)\n- 父类的成员方法只能被它的子类重写。\n- 声明为 final 的方法不能被重写。\n- 声明为 static 的方法不能被重写，但是能够被再次声明。\n- 被访问控制符private修饰的方法不能被重写。\n- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n- 构造方法不能被重写。\n- 如果不能继承一个方法，则不能重写这个方法。\n#### 重载(Overload)\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n最常用的地方就是构造器的重载。\n**重载规则:**\n\n- 被重载的方法必须改变参数列表(参数个数、参数顺序、参数类型 不同都能造成重载)；\n- 被重载的方法可以改变返回类型；\n- 被重载的方法可以改变访问修饰符；\n- 被重载的方法可以声明新的或更广的检查异常；\n- 方法能够在同一个类中或者在一个子类中被重载。\n- 无法以返回值类型作为重载函数的区分标准。\n\n实例:\n```java\npublic class Overloading {\n    public int test(){\n        System.out.println(\"test1\");\n        return 1;\n    }\n    public void test(int a){\n        System.out.println(\"test2\");\n    }\n    //以下两个参数类型顺序不同\n    public String test(int a,String s){\n        System.out.println(\"test3\");\n        return \"returntest3\";\n    }\n    public String test(String s,int a){\n        System.out.println(\"test4\");\n        return \"returntest4\";\n    }\n    public static void main(String[] args){\n        Overloading o = new Overloading();\n        System.out.println(o.test());\n        o.test(1);\n        System.out.println(o.test(1,\"test3\"));\n        System.out.println(o.test(\"test4\",1));\n    }\n}\n```\n打印：\n> test1\n> 1\n> test2\n> test3\n> returntest3\n> test4\n> returntest4\n\n#### 重写与重载之间的区别\n| 区别点 | 重载方法overloading | 重写方法overriding |\n| :--- | :--- | :--- |\n| 参数列表 | 必须修改 | 一定不能修改 |\n| 返回类型 | 可以修改 | 一定不能修改 |\n| 异常 | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |\n| 访问 | 可以修改 | 一定不能做更严格的限制（可以降低限制） |\n\n#### 总结:\n方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。\n\n- 方法重载是一个类中定义了多个方法名相同,而他们的参数不同,则称为方法的重载(Overloading)。\n- 方法重写是在子类中存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法,就称为重写(Overriding)。\n- 方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。\n\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557546-36df1755-3ebd-4944-befa-401aa5b3f02c.png#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=305&originWidth=730&status=done&style=none&width=730)\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557577-d8b2f920-bc3e-49ef-b252-01a15e65da95.png#align=left&display=inline&height=415&margin=%5Bobject%20Object%5D&originHeight=415&originWidth=750&status=done&style=none&width=750)\n**[_@_Override ](/Override ) **\n是伪代码,表示重写。(当然不写@Override也可以)，不过写上有如下好处:\n1、可以当注释用,方便阅读；\n2、编译器可以给你验证@Override下面的方法是否正确的重写父类方法，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。\n### 多态特性\n[https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232](https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232)\n**小结：**\n\n- 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；\n- Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；\n- `final`修饰符有多种作用：\n   - `final`修饰的方法可以阻止被覆写；\n   - `final`修饰的class可以阻止被继承；\n   - `final`修饰的字段必须在创建对象时初始化，随后不可修改。\n#### 覆写（Override）\n在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。\n例如，在`Person`类中，我们定义了`run()`方法：\n```java\nclass Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\n```\n在子类`Student`中，覆写这个`run()`方法：\n```java\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n```\nOverride和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是`Override`。\n注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。\n```java\nclass Person {\n    public void run() { … }\n}\nclass Student extends Person {\n    // 不是Override，因为参数不同:\n    public void run(String s) { … }\n    // 不是Override，因为返回值不同:\n    public int run() { … }\n}\n```\n加上`@Override`可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。\n```java\npublic class Main {\n    public static void main(String[] args) {\n    }\n}\nclass Person {\n    public void run() {}\n}\npublic class Student extends Person {\n    @Override // Compile error!\n    public void run(String s) {}\n}\n```\n但是`@Override`不是必需的。\n在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如：\n```\nPerson p = new Student();\n```\n现在，我们考虑一种情况，如果子类覆写了父类的方法：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Student();\n        p.run(); // 应该打印Person.run还是Student.run?\n    }\n}\nclass Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n```\n那么，一个实际类型为`Student`，引用类型为`Person`的变量，调用其`run()`方法，调用的是`Person`还是`Student`的`run()`方法？\n运行一下上面的代码就可以知道，实际上调用的方法是`Student`的`run()`方法。因此可得出结论：\nJava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。\n这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。\n#### 多态\n多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：\n```java\nPerson p = new Student();\np.run(); // 无法确定运行时究竟调用哪个run()方法\n```\n有童鞋会问，从上面的代码一看就明白，肯定调用的是`Student`的`run()`方法啊。\n但是，假设我们编写这样一个方法：\n```java\npublic void runTwice(Person p) {\n    p.run();\n    p.run();\n}\n```\n它传入的参数类型是`Person`，我们是无法知道传入的参数实际类型究竟是`Person`，还是`Student`，还是`Person`的其他子类，因此，也无法确定调用的是不是`Person`类定义的`run()`方法。\n所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？\n我们还是来举栗子。\n假设我们定义一种收入，需要给它报税，那么先定义一个`Income`类：\n```java\nclass Income {\n    protected double income;\n    public double getTax() {\n        return income * 0.1; // 税率10%\n    }\n}\n```\n对于工资收入，可以减去一个基数，那么我们可以从`Income`派生出`SalaryIncome`，并覆写`getTax()`：\n```java\nclass Salary extends Income {\n    @Override\n    public double getTax() {\n        if (income <= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\n```\n如果你享受国务院特殊津贴，那么按照规定，可以全部免税：\n```java\nclass StateCouncilSpecialAllowance extends Income {\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n```\n现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：\n```java\npublic double totalTax(Income... incomes) {\n    double total = 0;\n    for (Income income: incomes) {\n        total = total + income.getTax();\n    }\n    return total;\n}\n```\n来试一下：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:\n        Income[] incomes = new Income[] {\n            new Income(3000),\n            new Salary(7500),\n            new StateCouncilSpecialAllowance(15000)\n        };\n        System.out.println(totalTax(incomes));		//800\n    }\n    public static double totalTax(Income... incomes) {\n        double total = 0;\n        for (Income income: incomes) {\n            total = total + income.getTax();\n        }\n        return total;\n    }\n}\nclass Income {\n    protected double income;\n    public Income(double income) {\n        this.income = income;\n    }\n    public double getTax() {\n        return income * 0.1; // 税率10%\n    }\n}\nclass Salary extends Income {\n    public Salary(double income) {\n        super(income);\n    }\n    @Override\n    public double getTax() {\n        if (income <= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\nclass StateCouncilSpecialAllowance extends Income {\n    public StateCouncilSpecialAllowance(double income) {\n        super(income);\n    }\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n```\n观察`totalTax()`方法：利用多态，`totalTax()`方法只需要和`Income`打交道，它完全不需要知道`Salary`和`StateCouncilSpecialAllowance`的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从`Income`派生，然后正确覆写`getTax()`方法就可以。把新的类型传入`totalTax()`，不需要修改任何代码。\n可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。\n#### 覆写Object方法\n因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：\n\n- `toString()`：把instance输出为`String`；\n- `equals()`：判断两个instance是否逻辑相等；\n- `hashCode()`：计算一个instance的哈希值。\n\n在必要的情况下，我们可以覆写`Object`的这几个方法。例如：\n```java\nclass Person {\n    ...\n    // 显示更有意义的字符串:\n    @Override\n    public String toString() {\n        return \"Person:name=\" + name;\n    }\n    // 比较是否相等:\n    @Override\n    public boolean equals(Object o) {\n        // 当且仅当o为Person类型:\n        if (o instanceof Person) {\n            Person p = (Person) o;\n            // 并且name字段相同时，返回true:\n            return this.name.equals(p.name) && (this.age == p.age);\n        }\n        return false;\n    }\n    // 计算hash:\n    @Override\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n}\n```\n#### 调用super-重写父类\n在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。例如：\n```java\nclass Person {\n    protected String name;\n    public String hello() {\n        return \"Hello, \" + name;\n    }\n}\nStudent extends Person {\n    @Override\n    public String hello() {\n        // 调用父类的hello()方法:\n        return super.hello() + \"!\";\n    }\n}\n```\n#### final不可变\n继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：\n```java\nclass Person {\n    protected String name;\n    public final String hello() {\n        return \"Hello, \" + name;\n    }\n}\nStudent extends Person {\n    // compile error: 不允许覆写\n    @Override\n    public String hello() {\n    }\n}\n```\n如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：\n```java\nfinal class Person {\n    protected String name;\n}\n// compile error: 不允许继承自Person\nStudent extends Person {\n}\n```\n对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。例如：\n```java\nclass Person {\n    public final String name = \"Unamed\";\n}\n```\n对`final`字段重新赋值会报错：\n```java\nPerson p = new Person();\np.name = \"New Name\"; // compile error!\n```\n可以在构造方法中初始化final字段：\n```java\nclass Person {\n    public final String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n这种方法更为常用，因为可以保证实例一旦创建，其`final`字段就不可修改。\n### 练习：\n![](https://cdn.nlark.com/yuque/0/2020/png/1559629/1595344557616-c0fa49ed-3497-43a7-a5b7-d2db9355dbc3.png#align=left&display=inline&height=516&margin=%5Bobject%20Object%5D&originHeight=833&originWidth=880&status=done&style=none&width=545)\n参考：[https://book.apeland.cn/details/126/](https://book.apeland.cn/details/126/)\n','原创','','','','','',0,1455457723817291777,NULL,0,0,'2022-01-15 21:35:34','2022-01-15 21:35:34'),(1487439411107942402,'【CSS】Grid 网格布局教程','阮一峰老师经典的Css教程-Grid布局','https://ae04.alicdn.com/kf/H1bb068430cd74327ace871a2780c59691.png','一、概述\n网格布局（Grid）是最强大的 CSS 布局方案。\n\n它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。\nhttps://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png![](https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png)\n\n上图这样的布局，就是 Grid 布局的拿手好戏。\n\nGrid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。\n\nFlex 布局是轴线布局，只能指定\"项目\"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成\"行\"和\"列\"，产生单元格，然后指定\"项目所在\"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。\n\n二、基本概念\n学习 Grid 布局之前，需要了解一些基本概念。\n\n2.1 容器和项目\n采用网格布局的区域，称为\"容器\"（container）。容器内部采用网格定位的子元素，称为\"项目\"（item）。\n```html\n<div>\n  <div><p>1</p></div>\n  <div><p>2</p></div>\n  <div><p>3</p></div>\n</div>\n\n```\n\n上面代码中，最外层的<div>元素就是容器，内层的三个<div>元素就是项目。\n\n注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<p>元素就不是项目。Grid 布局只对项目生效。\n\n2.2 行和列\n容器里面的水平区域称为\"行\"（row），垂直区域称为\"列\"（column）。\n![](https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png)\n\n上图中，水平的深色区域就是\"行\"，垂直的深色区域就是\"列\"。\n\n2.3 单元格\n行和列的交叉区域，称为\"单元格\"（cell）。\n\n正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。\n\n2.4 网格线\n划分网格的线，称为\"网格线\"（grid line）。水平网格线划分出行，垂直网格线划分出列。\n\n正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。\n\n![](https://www.wangbase.com/blogimg/asset/201903/1_bg2019032503.png)\n\n上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。\n\n三、容器属性\nGrid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。\n\n3.1 display 属性\ndisplay: grid指定一个容器采用网格布局。\n```css\ndiv {\n  display: grid;\n}\n\n```\n\n\n上图是display: grid的效果。\n\n默认情况下，容器元素都是块级元素，但也可以设成行内元素。\n```css\ndiv {\n  display: inline-grid;\n}\n\n```\n\n上面代码指定div是一个行内元素，该元素内部采用网格布局。\n\n\n\n上图是display: inline-grid的效果。\n\n注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。\n\n3.2\ngrid-template-columns 属性，\ngrid-template-rows 属性\n容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。\n```css\n.container {\n  display: grid;\n  grid-template-columns: 100px 100px 100px;\n  grid-template-rows: 100px 100px 100px;\n}\n\n```\n上面代码指定了一个三行三列的网格，列宽和行高都是100px。\n除了使用绝对单位，也可以使用百分比。\n```css\n.container {\n  display: grid;\n  grid-template-columns: 33.33% 33.33% 33.33%;\n  grid-template-rows: 33.33% 33.33% 33.33%;\n}\n\n```\n\n（1）repeat()\n\n有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。\n\n\n.container {\n  display: grid;\n  grid-template-columns: repeat(3, 33.33%);\n  grid-template-rows: repeat(3, 33.33%);\n}\nrepeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。\n\nrepeat()重复某种模式也是可以的。\n\ngrid-template-columns: repeat(2, 100px 20px 80px);\n上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。\n\n（2）auto-fill 关键字\n\n有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充\n```csss\n.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, 100px);\n}\n\n```\n上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。\n（3）fr 关键字\n为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为\"片段\"）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。\n```css\n.container {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n}\n\n```\n\n上面代码表示两个相同宽度的列。\nfr可以与绝对长度的单位结合使用，这时会非常方便。\n```css\n.container {\n  display: grid;\n  grid-template-columns: 150px 1fr 2fr;\n}\n\n```\n\n上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。\n\n','原创','','','','','',0,1479452807638581249,NULL,0,0,'2022-01-29 22:56:05','2022-01-29 22:56:29');

/*Table structure for table `t_blog_tags` */

DROP TABLE IF EXISTS `t_blog_tags`;

CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL COMMENT '博客id',
  `tags_id` bigint(20) NOT NULL COMMENT '标签id',
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`) USING BTREE,
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_blog_tags` */

insert  into `t_blog_tags`(`blogs_id`,`tags_id`) values (1349746223141113858,1349746439126798338),(1350003826215661569,1350009490803556354),(1350016254991171585,1349746439126798338),(1350017257060728834,1350017258792976385),(1350017862483345409,1350017864416919553),(1350053816522887170,1350053816560635905),(1350053816522887170,1350053816858431490),(1456185591853690881,1349746439126798338),(1456185591853690881,1350009490803556354),(1457913602323931137,1349746439126798338),(1479450970399211521,8),(1479451767195336706,8),(1479453248040501250,1),(1479453248040501250,4),(1479453248040501250,5),(1479453248040501250,6),(1479743679928328193,7),(1479743679928328193,10),(1479744913028538370,2),(1479744913028538370,7),(1479744913028538370,10),(1479746765459677185,4),(1479746765459677185,5),(1479747500322709506,7),(1482341517241712642,1),(1482341517241712642,5),(1482341517241712642,4),(1482344609567834113,1),(1482344609567834113,5),(1482344609567834113,4),(1482345718415982594,7),(1487439411107942402,5);

/*Table structure for table `t_comment` */

DROP TABLE IF EXISTS `t_comment`;

CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id（评论人）',
  `content` text COLLATE utf8mb4_unicode_ci,
  `blog_id` bigint(20) DEFAULT NULL COMMENT '博客id',
  `parent_comment_id` bigint(20) DEFAULT '-1' COMMENT '父评论id',
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`) USING BTREE,
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`) USING BTREE,
  KEY `user_id` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1480014054637539331 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_comment` */

insert  into `t_comment`(`id`,`user_id`,`content`,`blog_id`,`parent_comment_id`,`create_time`) values (2,3,'详细的文章对我帮助很大',1350003826215661569,-1,'2021-12-01 17:37:36'),(3,4,'作者牛逼',1350003826215661569,-1,'2021-12-01 17:37:41'),(4,5,'学到了',1350003826215661569,2,'2021-11-26 17:19:23'),(5,3,'对呀我们理解的一样',1350003826215661569,2,'2021-11-26 17:20:16'),(6,1460162377352384513,'好棒棒',1350003826215661569,3,'2021-11-26 17:21:02'),(7,1463067857401815041,'球妹说的好',1350003826215661569,6,'2021-11-26 17:22:24'),(8,1460162377352384513,'反馈信息测试?',1350003826215661569,3,NULL),(1466342383111864321,1,'哈哈?',1350003826215661569,6,'2021-12-02 17:44:02'),(1466343116292980738,1,'xiaoming?shuode',1350003826215661569,7,'2021-12-02 17:46:57'),(1468909971297787906,1,'旅游网站包含的知识点还是很丰富的?',1349746223141113858,-1,'2021-12-09 19:46:43'),(1468910148553269250,1,'springboot+vue前后端是大势所趋',1349746223141113858,1468909971297787906,'2021-12-09 19:47:25'),(1468910587554291713,1460162377352384513,'easy-captcha验证码很棒?',1349746223141113858,1468910148553269250,'2021-12-09 19:49:10'),(1471308645990551554,1,'mybatis是最好的spring操作数据库框架?',1350016254991171585,-1,'2021-12-16 10:38:11'),(1479798375200186370,1,'requests是最好用的网络请求库',1479450970399211521,-1,'2022-01-08 20:53:21'),(1479798803690283010,1,'selenium是对抗反爬虫的有效手段',1479450970399211521,1479798375200186370,'2022-01-08 20:55:03'),(1479799036109250561,1,'爬虫是我入门Python的开端',1479450970399211521,-1,'2022-01-08 20:55:58'),(1479799408517308418,1,'我也是看的老男孩的Python全栈教程',1479450970399211521,1479799036109250561,'2022-01-08 20:57:27'),(1480008122725666817,1,'谢谢支持',1350003826215661569,6,'2022-01-09 10:46:48'),(1480014054637539330,1,'requests库是对urllib3库进一步的封装，入门Python直接学习它就好了',1479450970399211521,1479798375200186370,'2022-01-09 11:10:23');

/*Table structure for table `t_links` */

DROP TABLE IF EXISTS `t_links`;

CREATE TABLE `t_links` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_address` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '博客地址',
  `blog_name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '博客名称',
  `picture_address` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '首图',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1480113913336012802 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_links` */

insert  into `t_links`(`id`,`blog_address`,`blog_name`,`picture_address`,`create_time`,`update_time`) values (1455826744785899522,'https://www.cnblogs.com/XJT2018/p/14457779.html','Java工程师的学习路线','https://ae04.alicdn.com/kf/He153b5d6bc22461cb0f468d7ebf45176e.png',NULL,NULL),(1455827610150506497,'https://github.com/xdragon0/xiaoLBlog','小L星光博客github','https://camo.githubusercontent.com/7c6a1ae491c48283b80c8e476c8750c0b1b00ba6db8fd164cdf0172492123e76/68747470733a2f2f696d616765732e67697465652e636f6d2f75706c6f6164732f696d616765732f323032312f303330392f3130353435335f63316564663862385f373431353733312e706e67',NULL,NULL),(1455828229418520577,'https://www.yuque.com/yuquexiongjt/qh2h6g/nrn1ze','Docker入门到精通','https://ae02.alicdn.com/kf/H5eee37801de9479a9c41f3c80a98f4d6n.png',NULL,NULL),(1455839354105237506,'https://blog.csdn.net/m0_45234510/article/details/120867596?spm=1001.2014.3001.5501','算法题解（回溯篇）','https://img-blog.csdnimg.cn/cf9e87a2a180488c883fe9a7b7fe8620.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeC1kcmFnb244ODk5,size_20,color_FFFFFF,t_70,g_se,x_16',NULL,NULL),(1455839626240069634,'https://www.yuque.com/yuquexiongjt/qh2h6g/iirn0m','语雀-我的MyBatis','https://ae04.alicdn.com/kf/Hc8a23f122e014149a61bf9cee77dfc5dC.png',NULL,NULL),(1480105025085722625,'https://www.yuque.com/yuquexiongjt/qh2h6g/gmg9wr','验证码Jar包：easy-captcha','https://ae02.alicdn.com/kf/H4a137bdba5ca400dbc33d4b5a2529952X.png','2022-01-09 17:19:44','2022-01-09 17:19:44'),(1480112628507406337,'https://spring.io/projects/spring-boot','Spring框架官网','https://ae04.alicdn.com/kf/H124ec34f68cc4e9ab310ed976c27e6d0S.png','2022-01-09 17:42:04','2022-01-09 17:42:04'),(1480113913336012801,'http://momentjs.cn/','Moment.js官网','https://ae04.alicdn.com/kf/H09d3a93214f84c80bd7d9b3455307741G.png','2022-01-09 17:47:10','2022-01-09 17:47:10');

/*Table structure for table `t_message` */

DROP TABLE IF EXISTS `t_message`;

CREATE TABLE `t_message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '留言id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `creator_id` bigint(20) DEFAULT NULL COMMENT '留言者id',
  `content` text COLLATE utf8mb4_unicode_ci COMMENT '留言内容,含html标签',
  `parent_message_id` bigint(20) DEFAULT '-1' COMMENT '父留言id，用户给留言者的回复',
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1469244799692009475 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `t_message` */

insert  into `t_message`(`id`,`user_id`,`creator_id`,`content`,`parent_message_id`,`create_time`) values (1,1,3,'python爬虫是很有用的文章',-1,'2021-12-09 20:33:27'),(2,1,3,'666很棒666',-1,'2021-12-09 20:32:31'),(3,1,4,'java入门基础很实在',-1,NULL),(4,1,5,'Java是最好的编程语言，基础要打牢',3,NULL),(1469227864598212610,1,1460162377352384513,'<p>博主能不能出一篇springboot+vue前后端分离的小项目<span style=\"font-size: 14px;\">?</span><span style=\"font-size: 14px;\">?</span><span style=\"font-size: 14px;\">?</span></p>',-1,'2021-12-10 16:49:54'),(1469229071010066433,1,1460162377352384513,'<p>好的我会尽快出一个前后端分离的博客系统<span style=\"font-size: 14px;\">?</span></p><p>技术栈：</p><ul class=\"w-e-todo\"><li><span contenteditable=\"false\"><input type=\"checkbox\" checked=\"true\"/></span>springboot</li></ul><ul class=\"w-e-todo\"><li><span contenteditable=\"false\"><input type=\"checkbox\" checked=\"true\"/></span>mybaits</li></ul><ul class=\"w-e-todo\"><li><span contenteditable=\"false\"><input type=\"checkbox\" checked=\"true\"/></span>mysql</li></ul><ul class=\"w-e-todo\"><li><span contenteditable=\"false\"><input type=\"checkbox\" checked=\"true\"/></span>vue</li></ul>',-1,'2021-12-10 16:54:42'),(1469244799692009474,1,1,'<h1 id=\"hzkg6\">我是明教教主张无忌<span style=\"font-size: 14px;\">?</span></h1>',-1,'2021-12-10 17:57:12');

/*Table structure for table `t_perms` */

DROP TABLE IF EXISTS `t_perms`;

CREATE TABLE `t_perms` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) NOT NULL COMMENT '权限表达式',
  `url` varchar(256) DEFAULT NULL COMMENT '限定访问的url',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

/*Data for the table `t_perms` */

insert  into `t_perms`(`id`,`name`,`url`) values (1,'user:*:*',NULL),(2,'order:*:*',NULL),(3,'user:add:*',NULL),(4,'order:add:*',NULL);

/*Table structure for table `t_role` */

DROP TABLE IF EXISTS `t_role`;

CREATE TABLE `t_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色id',
  `name` varchar(256) DEFAULT NULL COMMENT '角色名',
  `name_zh` varchar(256) DEFAULT NULL COMMENT '角色中文名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_role` */

insert  into `t_role`(`id`,`name`,`name_zh`) values (1,'admin','管理员'),(2,'user_manager','用户管理员'),(3,'blog_manager','博客管理员'),(4,'user','普通用户'),(5,'addinfo_manager','添加信息的管理员');

/*Table structure for table `t_role_perms` */

DROP TABLE IF EXISTS `t_role_perms`;

CREATE TABLE `t_role_perms` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `roldid` bigint(20) DEFAULT NULL COMMENT '角色id',
  `permsid` bigint(20) DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `t_role_perms` */

insert  into `t_role_perms`(`id`,`roldid`,`permsid`) values (1,1,1),(2,1,2),(3,2,1),(4,3,2),(5,5,3),(6,5,4);

/*Table structure for table `t_tag` */

DROP TABLE IF EXISTS `t_tag`;

CREATE TABLE `t_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `color` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '颜色',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_tag` */

insert  into `t_tag`(`id`,`color`,`name`) values (1,'primary','Vue'),(2,NULL,'mybatis'),(3,'info','redis'),(4,NULL,'JavaScript'),(5,NULL,'前端'),(6,NULL,'HTML'),(7,NULL,'Java'),(8,NULL,'Python爬虫'),(10,'success','Spring'),(11,'warning','Docker'),(12,NULL,'Css'),(13,NULL,'Springboot'),(14,NULL,'SpringCloud');

/*Table structure for table `t_type` */

DROP TABLE IF EXISTS `t_type`;

CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL COMMENT '分类id',
  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_type` */

insert  into `t_type`(`id`,`name`) values (1350003757823340545,'SpringBoot'),(1455457539423105025,'Shiro'),(1455457723817291777,'java'),(1455457842704838658,'cpp'),(1455457901559312386,'python'),(1455458262223319042,'go'),(1455467085071806466,'django'),(1478015205903446017,'sql'),(1479452728248795137,'JavaScript'),(1479452807638581249,'前端框架'),(1479747590579937282,'Linux'),(1479747639200309250,'Linux部署'),(1487439625973747713,'Css');

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '密码',
  `nickname` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '头像',
  `email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '邮箱',
  `description` varchar(512) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '用户描述',
  `salt` varchar(256) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '密码加盐',
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1489218899214925827 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

/*Data for the table `t_user` */

insert  into `t_user`(`id`,`username`,`password`,`nickname`,`avatar`,`email`,`description`,`salt`,`create_time`,`update_time`) values (1,'admin','6363d0b5f6f32889b2f5b90e5cf9d725','超级管理员','https://ae03.alicdn.com/kf/H3b8cb5ac5b4e40939c2b458e4245d569A.png','1556187290@qq.com','星星之光，照亮远方','ym4nsm','2022-01-15 22:26:56','2022-01-15 22:26:56'),(3,'usermanager','8952949f3c2e056f3e273652dbc5c2ea','用户管理员','/classpath/fileContainer/avatarImages/2021-11-23/af492dfb2f1147c59e48919cf75b3aea-pexels-pixabay-258112.jpg','lihua@qq.com','guanliyonghu','3wlmk6','2021-11-23 16:02:29','2021-11-23 16:02:29'),(4,'ordermanager','1ee38d14a605d3cf2026414cbd1b7dea','朱小明','/classpath/fileContainer/avatarImages/2022-01-03/e4bc4823da514934996f9ea22b16cc9b-Snipaste_2022-01-03_19-25-21.png','zhuxiaoming@qq.com','朱小明是订单管理员，主要负责本站订单业务','yzijzr','2022-01-03 19:28:45','2022-01-03 19:28:45'),(5,'addinfomanager','2dd2d21696eed2a963d9a1eacf8a462d','妹爷','/classpath/fileContainer/avatarImages/2022-01-03/a9a6df4c32024b7d9c61800e8557caf9-meiye.png','meiye@qq.com','妹爷是添加信息管理员，责任是添加信息别的啥也干不了','694i0m','2022-01-03 19:29:33','2022-01-03 19:29:33'),(1460162377352384513,'qiuqiu','47245971c2060d5577c401cea32af11f','球球','/classpath/fileContainer/avatarImages/2022-01-03/778a3ed0e44449a38f2706688c3b7839-qiuqiu.png','qiuqiu@163.com','球球是个搞笑配角','r1pkv2','2022-01-03 22:58:59','2022-01-03 22:58:59'),(1462986895452176386,'liudehua','df358d2ef3ad1c791e063a69d35fcc78','华仔','/classpath/fileContainer/avatarImages/2021-11-23/e3ded1056af54e669767c3ce4bf4e37f-liudehua.jpg','liudehua@gmail.com','流行音乐-香港四大天王-著名演员','h4leiy','2021-11-23 16:39:49','2021-11-23 16:39:49'),(1463067857401815041,'maotai','ec72af7d39f09907a192c8318ad1356c','茅台(台哥)','/classpath/fileContainer/avatarImages/2021-11-23/73ce19845a3a4c019ae78098635bd8be-maotai.jpg','maotai@163.com','台哥-台总','njdu46','2021-11-23 16:55:11','2021-11-23 16:55:11'),(1480196819274285057,'xiong','c6fabe2c664701b3414b921025761456','小熊','/classpath/fileContainer/avatarImages/2022-01-10/02b65de872204317bfc00970f22f0464-pig2019.jpg','1351655382@qq.com','小熊程序员精通Java、Python、JavaScript、前端、SQL等','gouav3','2022-01-10 23:02:59','2022-01-10 23:02:59'),(1480196988422176769,'zhangsan','c087b0c32b674bbc333f8a878f7c56d2','张三','/classpath/fileContainer/avatarImages/2022-01-10/1e566884341c480387523771163017cb-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','zhangsan@163.com','张三同学是个菜鸡','qw94ye','2022-01-10 23:03:29','2022-01-10 23:03:29'),(1480197017820053506,'lisi','17e1b24255be67921ad4aedf55a472fd','李四','/classpath/fileContainer/avatarImages/2022-01-30/ce18dfef07034db0be528c6e13c82f9f-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','lisi@qq.com','李四是个打酱油的角色','t8xuay','2022-01-30 22:40:15','2022-01-30 22:40:15'),(1480197092294115330,'JackeyLove','c99ea3eee29746e72e856675df7201c3','杰克辣舞','/classpath/fileContainer/avatarImages/2022-01-30/ef2981df677c436793b386f8b9b95d0a-5.jpg','jack2022@qq.com','辣味十足','73891y','2022-01-30 22:41:14','2022-01-30 22:41:14'),(1480197135793242114,'spring','f5488c3b061b22887c065e9cf0de2349','春天',NULL,NULL,NULL,'ifv7fs','2022-01-09 23:18:29','2022-01-09 23:18:29'),(1480197179405615105,'togo','2a8da0a5b88a1bbfc9310fb6e1467994','土狗',NULL,NULL,NULL,'jbm9oi','2022-01-09 23:18:43','2022-01-09 23:18:43'),(1489218899214925826,'小小','3bba81a8e2549bc7bd1f595f2ab47063','一只小小鸟','','13516382@qq.com','我是一只小小小小鸟','34r8kr','2022-02-03 20:47:48','2022-02-03 20:47:48');

/*Table structure for table `t_user_file` */

DROP TABLE IF EXISTS `t_user_file`;

CREATE TABLE `t_user_file` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `old_file_name` varchar(256) CHARACTER SET utf8 DEFAULT NULL COMMENT '源文件名',
  `new_file_name` varchar(256) CHARACTER SET utf8 DEFAULT NULL COMMENT '新文件名',
  `ext` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '文件后缀名',
  `path` varchar(256) CHARACTER SET utf8 DEFAULT NULL COMMENT '文件存储路径',
  `size` varchar(256) CHARACTER SET utf8 DEFAULT NULL COMMENT '文件大小',
  `file_type` int(11) DEFAULT NULL COMMENT '文件类型 1图片2文档3音频4视频5压缩包6其他',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `down_counts` int(11) DEFAULT NULL COMMENT '下载次数',
  `upload_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '上传时间',
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1488873857803644930 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `t_user_file` */

insert  into `t_user_file`(`id`,`old_file_name`,`new_file_name`,`ext`,`path`,`size`,`file_type`,`user_id`,`down_counts`,`upload_time`) values (1459460264393609218,'xunlei.png','5ba9613e62ba45049fb142100ccb36a0-xunlei.png','.png','/classpath/fileContainer/avatarImages/2021-11-13/5ba9613e62ba45049fb142100ccb36a0-xunlei.png','150778',1,5,0,'2022-01-19 21:44:30'),(1459460620234166273,'xunlei.png','ec162a58541e46e9be3b75412b252311-xunlei.png','.png','/classpath/fileContainer/avatarImages/2021-11-13/ec162a58541e46e9be3b75412b252311-xunlei.png','150778',1,5,2,'2022-01-19 21:44:30'),(1459460986497568769,'keep.png','ab694154588843a7aa33707c8e692718-keep.png','.png','/classpath/fileContainer/avatarImages/2021-11-13/ab694154588843a7aa33707c8e692718-keep.png','16870',1,5,0,'2022-01-19 21:44:31'),(1462762990615580674,'111.jpg','21fb6a85d05240ea9aec24970bb60a0e-111.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-22/21fb6a85d05240ea9aec24970bb60a0e-111.jpg','346695',1,3,0,'2022-01-19 21:44:32'),(1462763797377372162,'111.jpg','c58ceb3860af4f66a3647ccbffa4cc1a-111.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-22/c58ceb3860af4f66a3647ccbffa4cc1a-111.jpg','346695',1,3,0,'2022-01-19 21:44:33'),(1462972092369264642,'pexels-ron-lach-10260876.jpg','369b141b6ffb4bd4b2042bba1bfa9d06-pexels-ron-lach-10260876.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/369b141b6ffb4bd4b2042bba1bfa9d06-pexels-ron-lach-10260876.jpg','7256189',1,3,0,'2022-01-19 21:44:33'),(1462987480595333122,'pexels-pixabay-258112.jpg','011dcf41d3c84a6990f30fb89a5c173a-pexels-pixabay-258112.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/011dcf41d3c84a6990f30fb89a5c173a-pexels-pixabay-258112.jpg','4045855',1,1,0,'2022-01-19 21:44:36'),(1462991230038867969,'pexels-10254185.jpg','b87ddbd63aa2486ab55fe5337b444e01-pexels-10254185.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/b87ddbd63aa2486ab55fe5337b444e01-pexels-10254185.jpg','2835047',1,1,0,'2022-01-19 21:44:37'),(1462991949403959298,'keep.png','818eb49bd0c24a1083b27c4990ae0571-keep.png','.png','/classpath/fileContainer/avatarImages/2021-11-23/818eb49bd0c24a1083b27c4990ae0571-keep.png','16870',1,1,0,'2022-01-19 21:44:38'),(1463053435480485889,'pexels-pixabay-258112.jpg','950ee9c246dc40558fb75066a413134f-pexels-pixabay-258112.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/950ee9c246dc40558fb75066a413134f-pexels-pixabay-258112.jpg','4045855',1,1,0,'2022-01-19 21:44:41'),(1463055138267209729,'pexels-pixabay-258112.jpg','af492dfb2f1147c59e48919cf75b3aea-pexels-pixabay-258112.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/af492dfb2f1147c59e48919cf75b3aea-pexels-pixabay-258112.jpg','4045855',1,3,0,'2022-01-19 21:44:40'),(1463063293608992770,'朱小明.jpg','c276d680011249b7b9b6756bbe58f5b0-朱小明.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/c276d680011249b7b9b6756bbe58f5b0-朱小明.jpg','42062',1,4,0,'2022-01-19 21:44:42'),(1463063426593595394,'zhuxiaoming.jpg','760c1b77509b49759c7fc448cca2732c-zhuxiaoming.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/760c1b77509b49759c7fc448cca2732c-zhuxiaoming.jpg','42062',1,4,0,'2022-01-19 21:44:45'),(1463063804143869954,'meiye.jpg','bac30c3e55384b2dbad876df4677eb67-meiye.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/bac30c3e55384b2dbad876df4677eb67-meiye.jpg','101966',1,5,0,'2022-01-19 21:44:43'),(1463064401404370946,'qiuqiu.jpg','160b691418674e08aba44fcc47981e43-qiuqiu.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/160b691418674e08aba44fcc47981e43-qiuqiu.jpg','40649',1,1460162377352384513,0,'2022-01-19 21:44:46'),(1463064727847051265,'liudehua.jpg','e3ded1056af54e669767c3ce4bf4e37f-liudehua.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/e3ded1056af54e669767c3ce4bf4e37f-liudehua.jpg','38673',1,1462986895452176386,0,'2022-01-19 21:44:47'),(1463068539915739137,'maotai.jpg','73ce19845a3a4c019ae78098635bd8be-maotai.jpg','.jpg','/classpath/fileContainer/avatarImages/2021-11-23/73ce19845a3a4c019ae78098635bd8be-maotai.jpg','63525',1,1463067857401815041,0,'2022-01-19 21:44:50'),(1467788625176055810,'pexels-ron-lach-10260876.jpg','cf3d1f81841847f5ab0e29ab72c6c97f-pexels-ron-lach-10260876.jpg','.jpg','/classpath/fileContainer/2021-12-06/cf3d1f81841847f5ab0e29ab72c6c97f-pexels-ron-lach-10260876.jpg','7256189',1,1462986895452176386,0,'2022-01-19 21:44:51'),(1477965129021755393,'Snipaste_2022-01-03_19-25-21.png','e4bc4823da514934996f9ea22b16cc9b-Snipaste_2022-01-03_19-25-21.png','.png','/classpath/fileContainer/avatarImages/2022-01-03/e4bc4823da514934996f9ea22b16cc9b-Snipaste_2022-01-03_19-25-21.png','109244',1,4,0,'2022-01-19 21:44:54'),(1477965330549673985,'meiye.png','a9a6df4c32024b7d9c61800e8557caf9-meiye.png','.png','/classpath/fileContainer/avatarImages/2022-01-03/a9a6df4c32024b7d9c61800e8557caf9-meiye.png','765240',1,5,0,'2022-01-19 21:44:52'),(1478017835761414146,'qiuqiu.png','b6fb84685936443eae2905b99377d257-qiuqiu.png','.png','/classpath/fileContainer/avatarImages/2022-01-03/b6fb84685936443eae2905b99377d257-qiuqiu.png','221639',1,1460162377352384513,0,'2022-01-19 21:44:55'),(1478018054012022786,'qiuqiu.png','778a3ed0e44449a38f2706688c3b7839-qiuqiu.png','.png','/classpath/fileContainer/avatarImages/2022-01-03/778a3ed0e44449a38f2706688c3b7839-qiuqiu.png','221639',1,1460162377352384513,0,'2022-01-19 21:45:00'),(1479804284529926146,'Java学习资源.pdf','8fd2605453a045cbb7bb6cf4d49db45d-Java学习资源.pdf','.pdf','/classpath/fileContainer/2022-01-08/8fd2605453a045cbb7bb6cf4d49db45d-Java学习资源.pdf','58355',2,1,0,'2022-01-19 21:45:02'),(1479804379769987074,'《森林狂想曲》森林版(cover) .mp3','5f948239e04247ca923bbfebe34b951f-《森林狂想曲》森林版(cover) .mp3','.mp3','/classpath/fileContainer/2022-01-08/5f948239e04247ca923bbfebe34b951f-《森林狂想曲》森林版(cover) .mp3','9777154',3,1,0,'2022-01-19 21:45:05'),(1479804428704931842,'《世间美好与你环环相扣》总会出现一个人 让你感觉人间值得.mp4','3bd42b7df5f94b3cadc973e36a4c9a56-《世间美好与你环环相扣》总会出现一个人 让你感觉人间值得.mp4','.mp4','/classpath/fileContainer/2022-01-08/3bd42b7df5f94b3cadc973e36a4c9a56-《世间美好与你环环相扣》总会出现一个人 让你感觉人间值得.mp4','33052836',4,1,0,'2022-01-19 21:45:06'),(1479804875134066689,'广东十年爱情故事-广东雨神.mp3','75b4bef2f7d2477cb48db10377395254-广东十年爱情故事-广东雨神.mp3','.mp3','/classpath/fileContainer/2022-01-08/75b4bef2f7d2477cb48db10377395254-广东十年爱情故事-广东雨神.mp3','3429399',3,1,0,'2022-01-19 21:45:10'),(1479806563064602625,'120个Java经典面试题和答案（上）.pdf','a46a46f4ee2a4b28a8130879aac68ee3-120个Java经典面试题和答案（上）.pdf','.pdf','/classpath/fileContainer/2022-01-08/a46a46f4ee2a4b28a8130879aac68ee3-120个Java经典面试题和答案（上）.pdf','501832',2,1,0,'2022-01-19 21:45:13'),(1480555769421160450,'pig2019.jpg','02b65de872204317bfc00970f22f0464-pig2019.jpg','.jpg','/classpath/fileContainer/avatarImages/2022-01-10/02b65de872204317bfc00970f22f0464-pig2019.jpg','20427',1,1480196819274285057,0,'2022-01-19 21:45:15'),(1480555896504377346,'e77dde6f71e5fa6529f6caedce6eb9bb.jpg','1e566884341c480387523771163017cb-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','.jpg','/classpath/fileContainer/avatarImages/2022-01-10/1e566884341c480387523771163017cb-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','835993',1,1480196988422176769,0,'2022-01-19 21:45:16'),(1481635350508994561,'v2-7bb3a283686e8fd6592e073f300a23ee_r.jpg','366e8c1f7ea2434aa27c856e5f9779f1-v2-7bb3a283686e8fd6592e073f300a23ee_r.jpg','.jpg','/classpath/fileContainer/2022-01-13/366e8c1f7ea2434aa27c856e5f9779f1-v2-7bb3a283686e8fd6592e073f300a23ee_r.jpg','709803',1,1,0,'2022-01-19 21:45:17'),(1481635482717650945,'v2-90c7a0913ff5557d6b602a2cf4c632e6_r.jpg','da0bc4d2119443ecbdb25be3ad2c39ec-v2-90c7a0913ff5557d6b602a2cf4c632e6_r.jpg','.jpg','/classpath/fileContainer/2022-01-13/da0bc4d2119443ecbdb25be3ad2c39ec-v2-90c7a0913ff5557d6b602a2cf4c632e6_r.jpg','205977',1,1,0,'2022-01-19 21:45:18'),(1481635527420542977,'爱上紫禁城.jpg','9a9fe6452ac64524ab4b2d2cba8e573a-爱上紫禁城.jpg','.jpg','/classpath/fileContainer/2022-01-13/9a9fe6452ac64524ab4b2d2cba8e573a-爱上紫禁城.jpg','1301378',1,1,0,'2022-01-19 21:45:43'),(1481635557825052673,'克拉女神江琴.jpg','44ee752dd8b245799f80429951a9143c-克拉女神江琴.jpg','.jpg','/classpath/fileContainer/2022-01-13/44ee752dd8b245799f80429951a9143c-克拉女神江琴.jpg','1014346',1,1,0,'2022-01-19 21:45:20'),(1483451534468554754,'阿冗 - 你的答案.mp3','0d925953bc1a428e8ab334a70485aea2-阿冗 - 你的答案.mp3','.mp3','/classpath/fileContainer/2022-01-18/0d925953bc1a428e8ab334a70485aea2-阿冗 - 你的答案.mp3','3519376',3,1,0,'2022-01-19 21:45:23'),(1483451659932770305,'Java学习资源.pdf','51fec228845349d2b2474b186b749c1b-Java学习资源.pdf','.pdf','/classpath/fileContainer/2022-01-18/51fec228845349d2b2474b186b749c1b-Java学习资源.pdf','58355',2,1,0,'2022-01-19 21:45:27'),(1483451815243653122,'动力节点-java的23种设计模式.pdf','b961720c51354010bcdbd43aba54a023-动力节点-java的23种设计模式.pdf','.pdf','/classpath/fileContainer/2022-01-18/b961720c51354010bcdbd43aba54a023-动力节点-java的23种设计模式.pdf','1787098',2,1,0,'2022-01-19 21:45:30'),(1483452396549021698,'cont-1750164-15817659_adpkg-ad_hd.mp4','b6381d2968ef475e8cd86f9359abf5e5-cont-1750164-15817659_adpkg-ad_hd.mp4','.mp4','/classpath/fileContainer/2022-01-18/b6381d2968ef475e8cd86f9359abf5e5-cont-1750164-15817659_adpkg-ad_hd.mp4','28971302',4,1,0,'2022-01-19 21:45:33'),(1483452421136031746,'cont-1750184-15817958_adpkg-ad_hd.mp4','1b38195cd677423bb8fc9175dbccb13c-cont-1750184-15817958_adpkg-ad_hd.mp4','.mp4','/classpath/fileContainer/2022-01-18/1b38195cd677423bb8fc9175dbccb13c-cont-1750184-15817958_adpkg-ad_hd.mp4','3881565',4,1,0,'2022-01-19 21:45:38'),(1485639811766165505,'4ff5fdaecfd4069b737aad91fe366c64.7z','75664ba748f54a00b4dff2cb3a2f7484-4ff5fdaecfd4069b737aad91fe366c64.7z','.7z','/classpath/fileContainer/2022-01-24/75664ba748f54a00b4dff2cb3a2f7484-4ff5fdaecfd4069b737aad91fe366c64.7z','1220082',5,3,0,'2022-01-24 23:47:41'),(1485640104637636610,'100个API接口文档.txt','f97f9168da99440a8b85b3a30e84522e-100个API接口文档.txt','.txt','/classpath/fileContainer/2022-01-24/f97f9168da99440a8b85b3a30e84522e-100个API接口文档.txt','6049',2,3,0,'2022-01-24 23:46:17'),(1485640914159280130,'陈粒 - 走马.mp3','d79ce075d7af433d9a73dcfb61624a12-陈粒 - 走马.mp3','.mp3','/classpath/fileContainer/2022-01-24/d79ce075d7af433d9a73dcfb61624a12-陈粒 - 走马.mp3','3787128',3,3,0,'2022-01-24 23:49:30'),(1485640967024287745,'TED演讲：当网络暴力失控后.mp4','9a646349b704419f89ade8a30a721cdf-TED演讲：当网络暴力失控后.mp4','.mp4','/classpath/fileContainer/2022-01-24/9a646349b704419f89ade8a30a721cdf-TED演讲：当网络暴力失控后.mp4','21480834',4,3,0,'2022-01-24 23:49:43'),(1485641066001473538,'mysql练习.txt','cc9785c039a64dd8a016b01e822c0a06-mysql练习.txt','.txt','/classpath/fileContainer/2022-01-24/cc9785c039a64dd8a016b01e822c0a06-mysql练习.txt','10831',2,3,0,'2022-01-24 23:50:06'),(1485984137323044865,'Spring Boot 2.5.0.pdf','ee70c6f996854617b5c9f528c9e2a58d-Spring Boot 2.5.0.pdf','.pdf','/classpath/fileContainer/2022-01-25/ee70c6f996854617b5c9f528c9e2a58d-Spring Boot 2.5.0.pdf','1473934',2,1460162377352384513,0,'2022-01-25 22:33:21'),(1485984206126407681,'广东十年爱情故事-广东雨神.mp3','b8ea6222bfc84ba7837514bbab3da88c-广东十年爱情故事-广东雨神.mp3','.mp3','/classpath/fileContainer/2022-01-25/b8ea6222bfc84ba7837514bbab3da88c-广东十年爱情故事-广东雨神.mp3','3429399',3,1460162377352384513,0,'2022-01-25 22:33:37'),(1485988076323958786,'花粥-出山.mp3','7ca5ba050faa4cce97898a8fe7b3c018-花粥-出山.mp3','.mp3','/classpath/fileContainer/2022-01-25/7ca5ba050faa4cce97898a8fe7b3c018-花粥-出山.mp3','3207462',3,1460162377352384513,0,'2022-01-25 22:49:00'),(1485988180606939138,'建党百年主题MV《星辰大海》 （正确音频版本）_哔哩哔哩_bilibili.mp4','cdbb90c45fb6418ebe3b8373a44be268-建党百年主题MV《星辰大海》 （正确音频版本）_哔哩哔哩_bilibili.mp4','.mp4','/classpath/fileContainer/2022-01-25/cdbb90c45fb6418ebe3b8373a44be268-建党百年主题MV《星辰大海》 （正确音频版本）_哔哩哔哩_bilibili.mp4','3370954',4,1460162377352384513,0,'2022-01-25 22:49:25'),(1485988347598958593,'常用.7z','a5d4afc33d0744c89e5f88adaaa7c9de-常用.7z','.7z','/classpath/fileContainer/2022-01-25/a5d4afc33d0744c89e5f88adaaa7c9de-常用.7z','1281',5,1460162377352384513,0,'2022-01-25 23:04:23'),(1485991491363983362,'老男孩python全栈开发3期目录.7z','f46d7365e53e49ce8ed13b66a45374e3-老男孩python全栈开发3期目录.7z','.7z','/classpath/fileContainer/2022-01-25/f46d7365e53e49ce8ed13b66a45374e3-老男孩python全栈开发3期目录.7z','13051',5,1460162377352384513,0,'2022-01-25 23:04:26'),(1485992251346698241,'阿冗 - 你的答案.mp3','618584fa42af444ab572c9b8f4c32462-阿冗 - 你的答案.mp3','.mp3','/classpath/fileContainer/2022-01-25/618584fa42af444ab572c9b8f4c32462-阿冗 - 你的答案.mp3','3519376',3,1460162377352384513,0,'2022-01-25 23:05:35'),(1485992299010768897,'大欢-多年以后.mp3','1ed4e262611f47389e6a070859766db2-大欢-多年以后.mp3','.mp3','/classpath/fileContainer/2022-01-25/1ed4e262611f47389e6a070859766db2-大欢-多年以后.mp3','3890230',3,1460162377352384513,0,'2022-01-25 23:05:47'),(1485992345131335681,'顾小洁 - 醉千年.mp3','26c6318fc177424f85bc456bc08d346c-顾小洁 - 醉千年.mp3','.mp3','/classpath/fileContainer/2022-01-25/26c6318fc177424f85bc456bc08d346c-顾小洁 - 醉千年.mp3','961068',3,1460162377352384513,0,'2022-01-25 23:05:58'),(1485992473086967810,'【编程不良人】JSONWebToken.pdf','7ff00bbd1f804174be57c0c728f8c3d9-【编程不良人】JSONWebToken.pdf','.pdf','/classpath/fileContainer/2022-01-25/7ff00bbd1f804174be57c0c728f8c3d9-【编程不良人】JSONWebToken.pdf','1102753',2,1460162377352384513,0,'2022-01-25 23:06:28'),(1487797804674965506,'e77dde6f71e5fa6529f6caedce6eb9bb.jpg','ce18dfef07034db0be528c6e13c82f9f-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','.jpg','/classpath/fileContainer/avatarImages/2022-01-30/ce18dfef07034db0be528c6e13c82f9f-e77dde6f71e5fa6529f6caedce6eb9bb.jpg','835993',1,1480197017820053506,0,'2022-01-30 22:40:13'),(1487798055532093441,'5.jpg','ef2981df677c436793b386f8b9b95d0a-5.jpg','.jpg','/classpath/fileContainer/avatarImages/2022-01-30/ef2981df677c436793b386f8b9b95d0a-5.jpg','1744982',1,1480197092294115330,0,'2022-01-30 22:41:13'),(1488872932250775554,'v2-337edbc2c8e9a885c42a370592635a9e_r.jpg','91ff515ab3f64152a96828bd5c075fb6-v2-337edbc2c8e9a885c42a370592635a9e_r.jpg','.jpg','/classpath/fileContainer/2022-02-02/91ff515ab3f64152a96828bd5c075fb6-v2-337edbc2c8e9a885c42a370592635a9e_r.jpg','402814',1,1480197092294115330,0,'2022-02-02 21:52:23'),(1488872950873485313,'爱上紫禁城.jpg','6f338551be5b469592c3ae0f266cda19-爱上紫禁城.jpg','.jpg','/classpath/fileContainer/2022-02-02/6f338551be5b469592c3ae0f266cda19-爱上紫禁城.jpg','1301378',1,1480197092294115330,0,'2022-02-02 21:52:28'),(1488872991616954370,'t01164a798a68fbf958.jpg','f533f5c60e2644d9819117451e6a7f08-t01164a798a68fbf958.jpg','.jpg','/classpath/fileContainer/2022-02-02/f533f5c60e2644d9819117451e6a7f08-t01164a798a68fbf958.jpg','150375',1,1480197092294115330,0,'2022-02-02 21:52:37'),(1488873069480013826,'大欢-多年以后.mp3','8f5734335ea747178b2c8339a0cb11de-大欢-多年以后.mp3','.mp3','/classpath/fileContainer/2022-02-02/8f5734335ea747178b2c8339a0cb11de-大欢-多年以后.mp3','3890230',3,1480197092294115330,0,'2022-02-02 21:52:56'),(1488873479250931713,'cont-1750257-15822500-hd.mp4','460ca130a8954bd6bb8ad5c1ccf22a2d-cont-1750257-15822500-hd.mp4','.mp4','/classpath/fileContainer/2022-02-02/460ca130a8954bd6bb8ad5c1ccf22a2d-cont-1750257-15822500-hd.mp4','11135758',4,1480197092294115330,0,'2022-02-02 21:54:34'),(1488873491624128514,'cont-1751050-10008579-144129-hd.mp4','9dd5fa33cfd24d138e0f60e17b5af66c-cont-1751050-10008579-144129-hd.mp4','.mp4','/classpath/fileContainer/2022-02-02/9dd5fa33cfd24d138e0f60e17b5af66c-cont-1751050-10008579-144129-hd.mp4','1336081',4,1480197092294115330,0,'2022-02-02 21:54:36'),(1488873643499876353,'Java面试题全集（中） - CSDN博客.pdf','1e04a2ca3ca4461fab327a1e15718eaa-Java面试题全集（中） - CSDN博客.pdf','.pdf','/classpath/fileContainer/2022-02-02/1e04a2ca3ca4461fab327a1e15718eaa-Java面试题全集（中） - CSDN博客.pdf','1008327',2,1480197092294115330,0,'2022-02-02 21:55:13'),(1488873857803644929,'叩丁狼-MyBatis3实战.7z','f468a94c8b964f01857cb6ccfdb94ed8-叩丁狼-MyBatis3实战.7z','.7z','/classpath/fileContainer/2022-02-02/f468a94c8b964f01857cb6ccfdb94ed8-叩丁狼-MyBatis3实战.7z','2428085',5,1480197092294115330,0,'2022-02-02 21:56:04');

/*Table structure for table `t_user_role` */

DROP TABLE IF EXISTS `t_user_role`;

CREATE TABLE `t_user_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userid` bigint(20) DEFAULT NULL COMMENT '用户id',
  `roleid` bigint(20) DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

/*Data for the table `t_user_role` */

insert  into `t_user_role`(`id`,`userid`,`roleid`) values (1,1,1),(3,3,2),(4,4,3),(5,5,5),(6,1462986895452176386,4),(7,1460162377352384513,4),(8,1463067857401815041,4),(9,1480196819274285057,1),(10,1480196988422176769,3),(11,1480197017820053506,2),(12,1480197092294115330,4),(13,1480197135793242114,3),(14,1480197179405615105,4),(15,1489218899214925826,2);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
